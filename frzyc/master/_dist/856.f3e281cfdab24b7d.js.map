{"version":3,"file":"856.f3e281cfdab24b7d.js","mappings":"mBA4BO,SAASA,EACdC,EACAC,GAEA,GAAKD,GAAQC,EAEb,OADCC,MAAMC,QAAQF,IAASG,QAAQC,MAAMJ,GAC/BA,EAAKK,QAAO,CAACC,EAAGC,IAAO,MAADD,OAAC,EAADA,EAAIC,IAAIR,EACvC,CAmDO,SAASS,EACdC,EACAC,GAEA,OAAOC,OAAOC,YAAYH,EAAMC,KAAI,CAACG,EAAGC,IAAMJ,EAAIG,EAAGC,KACvD,CAeO,SAASC,EACdhB,EACAiB,GAEA,OAAOL,OAAOC,YACZD,OAAOM,QAAQlB,GAAKW,KAAI,EAAEH,EAAGW,GAAIJ,IAAM,CAACP,EAAGS,EAAGE,EAAGX,EAAGO,MAExD,CAqBO,SAASK,EAAkBC,GAChC,MAAM,IAAIC,MAAO,oCAAmCD,IACtD,CAQO,SAASE,KAAgBC,GAC9B,OAAOA,EAAElB,QAAO,CAACC,EAAGkB,IAAMlB,EAAEmB,SAASC,GAAMF,EAAEd,KAAKiB,GAAM,CAACD,EAAG,CAACC,IAAIC,YAAU,CACzE,IAEJ,CCpJO,MA+DMC,EAA2B,CACtC,SACA,YACA,OACA,QACA,cACA,SACA,UACA,SACA,UACA,UACA,WACA,SACA,OACA,QACA,QACA,QACA,OACA,OACA,UACA,SACA,QACA,QACA,QACA,OACA,kBACA,QACA,gBACA,gBACA,QACA,SACA,SACA,OACA,YACA,cACA,QACA,OACA,OACA,OACA,SACA,QACA,YACA,SACA,OACA,eACA,QACA,UACA,oBACA,OACA,SACA,kBACA,SACA,UACA,YACA,QACA,WACA,QACA,WACA,YACA,OACA,UACA,SACA,UACA,SACA,SACA,QACA,UACA,SACA,WAOWC,EAAkB,CAC7B,gBACA,cACA,kBACA,kBC5IK,MAAMC,EAAqB,CAChC,aACA,eACA,YACA,kBACA,uBACA,aACA,uBACA,mBACA,gBACA,0BACA,qBACA,sBACA,uBACA,UACA,eACA,mBACA,eACA,sBACA,aACA,aACA,WACA,gBACA,gBACA,iBACA,cACA,gBACA,YACA,oBACA,yBACA,mBACA,sBACA,wBACA,kBACA,UACA,yBACA,yBACA,W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","sources":["webpack:///./src/app/Util/Util.ts","webpack:///../../libs/consts/src/character.ts","webpack:///../../libs/consts/src/artifact.ts","webpack:///../../libs/util/src/lib/util.ts","webpack:///../../libs/util/src/lib/object.ts","webpack:///../../libs/util/src/lib/array.ts","webpack:///./src/app/Formula/utils.ts","webpack:///./src/app/Formula/internal.ts","webpack:///./src/app/Formula/optimization.ts","webpack:///./src/app/Solver/common.ts","webpack:///./src/app/Solver/GOSolver/BNBSplitWorker/polyUB.ts","webpack:///./src/app/Solver/GOSolver/BNBSplitWorker/solveLP.ts","webpack:///./src/app/Solver/GOSolver/BNBSplitWorker/linearUB.ts","webpack:///./src/app/Solver/GOSolver/BNBSplitWorker/heuristicSplitting.ts","webpack:///./src/app/Solver/GOSolver/BNBSplitWorker/index.ts","webpack:///./src/app/Solver/GOSolver/ComputeWorker.ts","webpack:///./src/app/Solver/GOSolver/DefaultSplitWorker.ts","webpack:///./src/app/Solver/GOSolver/BackgroundWorker.ts"],"sourcesContent":["/**\n * Assumes that the object entries are all primitives + objects\n * shallow copy the object,\n * deep copy the\n * @param obj\n * @returns\n */\nexport function deepClone<T>(obj: T): T {\n  if (!obj) return obj\n  if (!Object.keys(obj).length) return {} as T\n  const ret = { ...obj }\n  Object.entries(obj).forEach(([k, v]: any) => {\n    if (typeof v !== 'object') return\n    ret[k] = JSON.parse(JSON.stringify(v))\n  })\n  return ret\n}\n\n//assign obj.[keys...] = value\nexport function layeredAssignment(obj, keys: readonly string[], value) {\n  keys.reduce((accu, key, i, arr) => {\n    if (i === arr.length - 1) return (accu[key] = value)\n    if (!accu[key]) accu[key] = {}\n    return accu[key]\n  }, obj)\n  return obj\n}\n//get the value in a nested object, giving array of path\nexport function objPathValue(\n  obj: object | undefined,\n  keys: readonly string[]\n): any {\n  if (!obj || !keys) return undefined\n  !Array.isArray(keys) && console.error(keys)\n  return keys.reduce((a, k) => a?.[k], obj)\n}\n//delete the value denoted by the path. Will also delete empty objects as well.\nexport function deletePropPath(obj, path) {\n  const tempPath = [...path]\n  const lastKey = tempPath.pop()\n  const objPathed = objPathValue(obj, tempPath)\n  delete objPathed?.[lastKey]\n}\n\nexport function objClearEmpties(o) {\n  for (const k in o) {\n    if (typeof o[k] !== 'object') continue\n    objClearEmpties(o[k])\n    if (!Object.keys(o[k]).length) delete o[k]\n  }\n}\nexport function crawlObject(\n  obj: any,\n  keys: string[] = [],\n  validate: (o: any, keys: string[]) => boolean,\n  cb: (o: any, keys: string[]) => void\n) {\n  if (validate(obj, keys)) cb(obj, keys)\n  else\n    obj &&\n      typeof obj === 'object' &&\n      Object.entries(obj).forEach(([key, val]) =>\n        crawlObject(val, [...keys, key], validate, cb)\n      )\n}\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\nexport const getObjectKeysRecursive = (obj) =>\n  typeof obj === 'object'\n    ? Object.values(obj)\n        .flatMap(getObjectKeysRecursive)\n        .concat(Object.keys(obj))\n    : typeof obj === 'string'\n    ? [obj]\n    : []\n\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\n  return typeof value === 'function' ? (value as any)(arg) : value\n}\n\n/**\n * fromEntries doesn't result in StrictDict, this is just a utility wrapper.\n * @deprecated\n * @param items\n * @param map\n * @returns\n */\nexport function objectKeyValueMap<T, K extends string | number, V>(\n  items: readonly T[],\n  map: (item: T, i: number) => [K, V]\n): StrictDict<`${K}`, V> {\n  return Object.fromEntries(items.map((t, i) => map(t, i))) as any\n}\n\n/**\n * @deprecated use the @genshin-optimizer/util `objMap` function.\n * @param obj\n * @param fn\n */\nexport function objectMap<K extends string, V, T>(\n  obj: Record<K, Exclude<V, undefined>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Record<K, T>\nexport function objectMap<K extends string, V, T>(\n  obj: Partial<Record<K, V>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Partial<Record<K, T>>\nexport function objectMap<K extends string, V, T>(\n  obj: Partial<Record<K, V>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Partial<Record<K, T>> {\n  return Object.fromEntries(\n    Object.entries(obj).map(([k, v], i) => [k, fn(v, k, i)])\n  ) as any\n}\n\n/**\n * @deprecated use the @genshin-optimizer/util `rangeGen` function.\n * @param from\n * @param to\n */\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\n  for (let i = from; i <= to; i++) yield i\n}\n\n/**\n * range of [from, to], inclusive\n * @deprecated use the @genshin-optimizer/util `range` function.\n * @param from\n * @param to\n */\nexport function range(from: number, to: number): number[] {\n  return [...rangeGen(from, to)]\n}\n\nexport function assertUnreachable(value: never): never {\n  throw new Error(`Should not reach this with value ${value}`)\n}\n\n/**\n * cartesian product of list of arrays\n * @deprecated use the @genshin-optimizer/util `cartesian` function.\n * @param q\n * @returns\n */\nexport function cartesian<T>(...q: T[][]): T[][] {\n  return q.reduce((a, b) => a.flatMap((d) => b.map((e) => [d, [e]].flat())), [\n    [],\n  ] as T[][])\n}\n","export const allGenderKeys = ['F', 'M'] as const\nexport type GenderKey = (typeof allGenderKeys)[number]\n\nexport const allElementKeys = [\n  'anemo',\n  'geo',\n  'electro',\n  'hydro',\n  'pyro',\n  'cryo',\n  'dendro',\n] as const\nexport type ElementKey = (typeof allElementKeys)[number]\n\nexport const allElementWithPhyKeys = ['physical', ...allElementKeys] as const\nexport type ElementWithPhyKey = (typeof allElementWithPhyKeys)[number]\n\nexport const allRegionKeys = [\n  'mondstadt',\n  'liyue',\n  'inazuma',\n  'sumeru',\n  'fontaine',\n  'natlan',\n  'snezhnaya',\n  'khaenriah',\n] as const\nexport type RegionKey = (typeof allRegionKeys)[number]\n\nexport const allAscensionKeys = [0, 1, 2, 3, 4, 5, 6] as const\nexport type AscensionKey = (typeof allAscensionKeys)[number]\n\nexport const allMoveKeys = [\n  'normal',\n  'charged',\n  'plunging',\n  'skill',\n  'burst',\n  'elemental',\n] as const\nexport type MoveKey = (typeof allMoveKeys)[number]\n\nexport const characterSpecializedStatKeys = [\n  'hp_',\n  'atk_',\n  'def_',\n  'eleMas',\n  'enerRech_',\n  'heal_',\n  'critRate_',\n  'critDMG_',\n  'physical_dmg_',\n  'anemo_dmg_',\n  'geo_dmg_',\n  'electro_dmg_',\n  'hydro_dmg_',\n  'pyro_dmg_',\n  'cryo_dmg_',\n  'dendro_dmg_',\n] as const\nexport type CharacterSpecializedStatKey =\n  (typeof characterSpecializedStatKeys)[number]\n\nexport const nonTravelerCharacterKeys = [\n  'Albedo',\n  'Alhaitham',\n  'Aloy',\n  'Amber',\n  'AratakiItto',\n  'Baizhu',\n  'Barbara',\n  'Beidou',\n  'Bennett',\n  'Candace',\n  'Chongyun',\n  'Collei',\n  'Cyno',\n  'Dehya',\n  'Diluc',\n  'Diona',\n  'Dori',\n  'Eula',\n  'Faruzan',\n  'Fischl',\n  'Ganyu',\n  'Gorou',\n  'HuTao',\n  'Jean',\n  'KaedeharaKazuha',\n  'Kaeya',\n  'KamisatoAyaka',\n  'KamisatoAyato',\n  'Kaveh',\n  'Keqing',\n  'Kirara',\n  'Klee',\n  'KujouSara',\n  'KukiShinobu',\n  'Layla',\n  'Lisa',\n  'Mika',\n  'Mona',\n  'Nahida',\n  'Nilou',\n  'Ningguang',\n  'Noelle',\n  'Qiqi',\n  'RaidenShogun',\n  'Razor',\n  'Rosaria',\n  'SangonomiyaKokomi',\n  'Sayu',\n  'Shenhe',\n  'ShikanoinHeizou',\n  'Somnia',\n  'Sucrose',\n  'Tartaglia',\n  'Thoma',\n  'Tighnari',\n  'Venti',\n  'Wanderer',\n  'Xiangling',\n  'Xiao',\n  'Xingqiu',\n  'Xinyan',\n  'YaeMiko',\n  'Yanfei',\n  'Yaoyao',\n  'Yelan',\n  'Yoimiya',\n  'YunJin',\n  'Zhongli',\n] as const\nexport type NonTravelerCharacterKey = (typeof nonTravelerCharacterKeys)[number]\n\nexport const travelerElements = ['anemo', 'geo', 'electro', 'dendro'] as const\nexport type TravelerElementKey = (typeof travelerElements)[number]\n\nexport const allTravelerKeys = [\n  'TravelerAnemo',\n  'TravelerGeo',\n  'TravelerElectro',\n  'TravelerDendro',\n] as const\nexport type TravelerKey = (typeof allTravelerKeys)[number]\n\nexport const travelerEleMap: Partial<Record<ElementKey, TravelerKey>> = {\n  anemo: 'TravelerAnemo',\n  geo: 'TravelerGeo',\n  electro: 'TravelerElectro',\n  dendro: 'TravelerDendro',\n} as const\n\nexport const locationGenderedCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  'TravelerF',\n  'TravelerM',\n] as const\nexport type LocationGenderedCharacterKey =\n  (typeof locationGenderedCharacterKeys)[number]\n\nexport const allCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  ...allTravelerKeys,\n] as const\nexport type CharacterKey = (typeof allCharacterKeys)[number]\n\nexport const allLocationCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  'Traveler',\n] as const\nexport type LocationCharacterKey = (typeof allLocationCharacterKeys)[number]\n\nexport type LocationKey = LocationCharacterKey | ''\n\nexport function charKeyToLocGenderedCharKey(\n  charKey: CharacterKey,\n  gender: GenderKey\n): LocationGenderedCharacterKey {\n  if (allTravelerKeys.includes(charKey as TravelerKey))\n    return `Traveler${gender}`\n  return charKey as LocationGenderedCharacterKey\n}\n\nexport function charKeyToLocCharKey(\n  charKey: CharacterKey\n): LocationCharacterKey {\n  if (allTravelerKeys.includes(charKey as TravelerKey)) return 'Traveler'\n  return charKey as LocationCharacterKey\n}\n\nexport function locCharKeyToCharKey(\n  locKey: LocationCharacterKey,\n  travelerEle: ElementKey = 'anemo'\n): CharacterKey {\n  if (locKey === 'Traveler') return travelerEleMap[travelerEle] as CharacterKey\n  return locKey as CharacterKey\n}\n\nexport function travelerElement(element: TravelerElementKey): TravelerKey {\n  return ('Traveler' +\n    element.toUpperCase().slice(0, 1) +\n    element.slice(1)) as TravelerKey\n}\n","import type { RarityKey } from './common'\n\nexport const allArtifactSetKeys = [\n  'Adventurer',\n  'ArchaicPetra',\n  'Berserker',\n  'BlizzardStrayer',\n  'BloodstainedChivalry',\n  'BraveHeart',\n  'CrimsonWitchOfFlames',\n  'DeepwoodMemories',\n  'DefendersWill',\n  'DesertPavilionChronicle',\n  'EchoesOfAnOffering',\n  'EmblemOfSeveredFate',\n  'FlowerOfParadiseLost',\n  'Gambler',\n  'GildedDreams',\n  'GladiatorsFinale',\n  'HeartOfDepth',\n  'HuskOfOpulentDreams',\n  'Instructor',\n  'Lavawalker',\n  'LuckyDog',\n  'MaidenBeloved',\n  'MartialArtist',\n  'NoblesseOblige',\n  'NymphsDream',\n  'OceanHuedClam',\n  'PaleFlame',\n  'PrayersForDestiny',\n  'PrayersForIllumination',\n  'PrayersForWisdom',\n  'PrayersToSpringtime',\n  'ResolutionOfSojourner',\n  'RetracingBolide',\n  'Scholar',\n  'ShimenawasReminiscence',\n  'TenacityOfTheMillelith',\n  'TheExile',\n  'ThunderingFury',\n  'Thundersoother',\n  'TinyMiracle',\n  'TravelingDoctor',\n  'VermillionHereafter',\n  'ViridescentVenerer',\n  'VourukashasGlow',\n  'WanderersTroupe',\n] as const\nexport type ArtifactSetKey = (typeof allArtifactSetKeys)[number]\n\nexport const allArtifactSlotKeys = [\n  'flower',\n  'plume',\n  'sands',\n  'goblet',\n  'circlet',\n] as const\nexport type ArtifactSlotKey = (typeof allArtifactSlotKeys)[number]\n\nexport const artMaxLevel: Record<RarityKey, number> = {\n  1: 4,\n  2: 4,\n  3: 12,\n  4: 16,\n  5: 20,\n} as const\n\nexport const artSubstatRollData: Record<\n  RarityKey,\n  { low: number; high: number; numUpgrades: number }\n> = {\n  1: { low: 0, high: 0, numUpgrades: 1 },\n  2: { low: 0, high: 1, numUpgrades: 2 },\n  3: { low: 1, high: 2, numUpgrades: 3 },\n  4: { low: 2, high: 3, numUpgrades: 4 },\n  5: { low: 3, high: 4, numUpgrades: 5 },\n} as const\n\nexport const artifactSandsStatKeys = [\n  'hp_',\n  'def_',\n  'atk_',\n  'eleMas',\n  'enerRech_',\n] as const\nexport type ArtifactSandsStatKey = (typeof artifactSandsStatKeys)[number]\n\nexport const artifactGobletStatKeys = [\n  'hp_',\n  'def_',\n  'atk_',\n  'eleMas',\n  'physical_dmg_',\n  'anemo_dmg_',\n  'geo_dmg_',\n  'electro_dmg_',\n  'hydro_dmg_',\n  'pyro_dmg_',\n  'cryo_dmg_',\n  'dendro_dmg_',\n] as const\nexport type ArtifactGobletStatKey = (typeof artifactGobletStatKeys)[number]\n\nexport const artifactCircletStatKeys = [\n  'hp_',\n  'def_',\n  'atk_',\n  'eleMas',\n  'critRate_',\n  'critDMG_',\n  'heal_',\n] as const\nexport type ArtifactCircletStatKey = (typeof artifactCircletStatKeys)[number]\nexport const artSlotsData = {\n  flower: { name: 'Flower of Life', stats: ['hp'] as readonly MainStatKey[] },\n  plume: { name: 'Plume of Death', stats: ['atk'] as readonly MainStatKey[] },\n  sands: {\n    name: 'Sands of Eon',\n    stats: artifactSandsStatKeys as readonly MainStatKey[],\n  },\n  goblet: {\n    name: 'Goblet of Eonothem',\n    stats: artifactGobletStatKeys as readonly MainStatKey[],\n  },\n  circlet: {\n    name: 'Circlet of Logos',\n    stats: artifactCircletStatKeys as readonly MainStatKey[],\n  },\n} as const\n\nexport const allMainStatKeys = [\n  'hp',\n  'hp_',\n  'atk',\n  'atk_',\n  'def_',\n  'eleMas',\n  'enerRech_',\n  'critRate_',\n  'critDMG_',\n  'physical_dmg_',\n  'anemo_dmg_',\n  'geo_dmg_',\n  'electro_dmg_',\n  'hydro_dmg_',\n  'pyro_dmg_',\n  'cryo_dmg_',\n  'dendro_dmg_',\n  'heal_',\n] as const\nexport const allSubstatKeys = [\n  'hp',\n  'hp_',\n  'atk',\n  'atk_',\n  'def',\n  'def_',\n  'eleMas',\n  'enerRech_',\n  'critRate_',\n  'critDMG_',\n] as const\nexport type MainStatKey = (typeof allMainStatKeys)[number]\nexport type SubstatKey = (typeof allSubstatKeys)[number]\n\n// GO currently only support 3-5 star artifacts\nexport const allArtifactRarityKeys = [5, 4, 3] as const\nexport type ArtifactRarity = (typeof allArtifactRarityKeys)[number]\n","export function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\n  return typeof value === 'function' ? (value as any)(arg) : value\n}\n\nexport function assertUnreachable(value: never): never {\n  throw new Error(`Should not reach this with value ${value}`)\n}\n","export function crawlObject(\n  obj: any,\n  keys: string[] = [],\n  validate: (o: any, keys: string[]) => boolean,\n  cb: (o: any, keys: string[]) => void\n) {\n  if (validate(obj, keys)) cb(obj, keys)\n  else\n    obj &&\n      typeof obj === 'object' &&\n      Object.entries(obj).forEach(([key, val]) =>\n        crawlObject(val, [...keys, key], validate, cb)\n      )\n}\n\n//assign obj.[keys...] = value\nexport function layeredAssignment<T>(\n  obj: any,\n  keys: readonly (number | string)[],\n  value: T\n) {\n  keys.reduce((accu, key, i, arr) => {\n    if (i === arr.length - 1) return (accu[key] = value)\n    if (!accu[key]) accu[key] = {}\n    return accu[key]\n  }, obj)\n  return obj\n}\n\n/**\n * Filter the object to only have key:value for a correspoding array of keys\n * Assumes that `keys` is a superset of Object.keys(obj)\n * @param obj\n * @param keys\n * @returns\n */\nexport function objFilterKeys<K extends string, K2 extends string, V>(\n  obj: Record<K, V>,\n  keys: K2[]\n): Record<K2, V> {\n  return Object.fromEntries(\n    Object.entries(obj).filter(([k]) => keys.includes(k as K2))\n  ) as Record<K2, V>\n}\n\nexport function objMap<K extends string | number, V, V2>(\n  obj: Record<K, V>,\n  f: (v: V, k: K, i: number) => V2\n): Record<K, V2> {\n  return Object.fromEntries(\n    Object.entries(obj).map(([k, v], i) => [k, f(v as V, k as K, i)])\n  ) as Record<K, V2>\n}\n\n/**\n * Generate an object from an array of keys, and a function that maps the key to a value\n * @param keys\n * @param map\n * @returns\n */\nexport function objKeyMap<K extends string | number, V>(\n  keys: readonly K[],\n  map: (key: K, i: number) => V\n): Record<K, V> {\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as Record<K, V>\n}\n\nexport function objKeyValMap<\n  K extends string | number,\n  K2 extends string | number,\n  V\n>(items: readonly K[], map: (item: K, i: number) => [K2, V]): Record<K2, V> {\n  return Object.fromEntries(items.map((t, i) => map(t, i))) as Record<K2, V>\n}\n\n//multiplies every numerical value in the obj by a multiplier.\nexport function objMultiplication(obj: Record<string, unknown>, multi: number) {\n  if (multi === 1) return obj\n  Object.keys(obj).forEach((prop: any) => {\n    if (typeof obj[prop] === 'object')\n      objMultiplication(\n        (obj as Record<string, Record<string, unknown>>)[prop],\n        multi\n      )\n    if (typeof obj[prop] === 'number')\n      obj[prop] = (obj as Record<string, number>)[prop] * multi\n  })\n  return obj\n}\n//delete the value denoted by the path. Will also delete empty objects as well.\nexport function deletePropPath(\n  obj: Record<string, unknown>,\n  path: readonly string[]\n) {\n  const tempPath = [...path]\n  const lastKey = tempPath.pop()\n  if (!lastKey) return\n  const objPathed = objPathValue(obj, tempPath)\n  delete objPathed?.[lastKey]\n}\n\n//get the value in a nested object, giving array of path\nexport function objPathValue(\n  obj: object | undefined,\n  keys: readonly string[]\n): any {\n  if (!obj || !keys) return undefined\n  return keys.reduce((a, k) => (a as any)?.[k], obj)\n}\n\nexport function objClearEmpties(o: Record<string, unknown>) {\n  for (const k in o) {\n    if (typeof o[k] !== 'object') continue\n    objClearEmpties(o[k] as Record<string, unknown>)\n    if (!Object.keys(o[k] as Record<string, unknown>).length) delete o[k]\n  }\n}\n\nexport const getObjectKeysRecursive = (obj: unknown): string[] =>\n  typeof obj === 'object'\n    ? Object.values(obj as Record<string, unknown>)\n        .flatMap(getObjectKeysRecursive)\n        .concat(Object.keys(obj as Record<string, unknown>))\n    : typeof obj === 'string'\n    ? [obj]\n    : []\n\nexport function deepFreeze<T>(obj: T, layers = 5): T {\n  if (layers === 0) return obj\n  if (typeof obj === 'object')\n    Object.values(Object.freeze(obj)).forEach((o) => deepFreeze(o, layers--))\n  return obj\n}\n","export function getArrLastElement<E>(arr: E[]): E | null {\n  return arr.length ? arr[arr.length - 1] : null\n}\n\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\n  for (let i = from; i <= to; i++) yield i\n}\n\n/** range of [from, to], inclusive */\nexport function range(from: number, to: number): number[] {\n  return [...rangeGen(from, to)]\n}\n\n/** Will change `arr` in-place */\nexport function toggleInArr<T>(arr: T[], value: T) {\n  const ind = arr.indexOf(value)\n  if (ind < 0) arr.push(value)\n  else arr.splice(ind, 1)\n  return arr\n}\n\n// cartesian product of list of arrays\nexport function cartesian<T>(...q: T[][]): T[][] {\n  return q.reduce((a, b) => a.flatMap((d) => b.map((e) => [d, [e]].flat())), [\n    [],\n  ] as T[][])\n}\n\nexport function toggleArr<T>(arr: T[], value: T) {\n  return arr.includes(value) ? arr.filter((a) => a !== value) : [...arr, value]\n}\n\n// Move an item in an array from one position to another\nexport function arrayMove<T>(arr: T[], oldIndex: number, newIndex: number) {\n  if (newIndex < 0 || newIndex >= arr.length) return arr\n  if (oldIndex < 0 || oldIndex >= arr.length) return arr\n  arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0])\n  return arr\n}\n","import { objKeyMap } from '@genshin-optimizer/util'\nimport type { OptNode } from './optimization'\nimport type {\n  ComputeNode,\n  ConstantNode,\n  Data,\n  DataNode,\n  Info,\n  LookupNode,\n  MatchNode,\n  NumNode,\n  ReadNode,\n  StrNode,\n  StrPrioNode,\n  SubscriptNode,\n  ThresholdNode,\n} from './type'\n\ntype Opt = number | OptNode\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype N_S = Num | Str\ntype AnyNode = NumNode | StrNode\n\nexport const todo: OptNode = constant(NaN, { name: 'TODO' })\nexport const one = percent(1),\n  naught = percent(0)\nexport const none = constant('none')\n\nexport function constant(value: number, info?: Info): ConstantNode<number>\nexport function constant(\n  value: string | undefined,\n  info?: Info\n): ConstantNode<string | undefined>\nexport function constant(\n  value: number | string | undefined,\n  info?: Info\n): ConstantNode<number> | ConstantNode<string | undefined>\nexport function constant(\n  value: number | string | undefined,\n  info?: Info\n): ConstantNode<number | string | undefined> {\n  return typeof value === 'number'\n    ? { operation: 'const', operands: [], type: 'number', value, info }\n    : { operation: 'const', operands: [], type: 'string', value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): ConstantNode<number> {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { unit: '%', ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: OptNode, info: Info): OptNode\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: AnyNode, info: Info): AnyNode\nexport function infoMut(node: AnyNode, info: Info): AnyNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, NumNode>,\n  defaultV: Num | 'none',\n  info?: Info\n): LookupNode<NumNode>\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, StrNode>,\n  defaultV: Str | 'none',\n  info?: Info\n): LookupNode<StrNode>\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, AnyNode>,\n  defaultV: N_S | 'none',\n  info?: Info\n): LookupNode<AnyNode> {\n  return {\n    operation: 'lookup',\n    operands:\n      defaultV !== 'none' ? [intoV(index), intoV(defaultV)] : [intoV(index)],\n    table,\n    info,\n  }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function min(...values: Num[]): ComputeNode\nexport function min(...values: Num[]): ComputeNode {\n  return { operation: 'min', operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function max(...values: Num[]): ComputeNode\nexport function max(...values: Num[]): ComputeNode {\n  return { operation: 'max', operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function sum(...values: Num[]): ComputeNode\nexport function sum(...values: Num[]): ComputeNode {\n  return { operation: 'add', operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function prod(...values: Num[]): ComputeNode\nexport function prod(...values: Num[]): ComputeNode {\n  return { operation: 'mul', operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Opt, c: Opt): ComputeNode<OptNode, OptNode>\nexport function frac(x: Num, c: Num): ComputeNode\nexport function frac(x: Num, c: Num): ComputeNode {\n  return { operation: 'sum_frac', operands: intoOps([x, c]) }\n}\nexport function res(base: Opt): ComputeNode<OptNode, OptNode>\nexport function res(base: Num): ComputeNode\nexport function res(base: Num): ComputeNode {\n  return { operation: 'res', operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? eq : neq */\nexport function compareEq(\n  v1: Num,\n  v2: Num,\n  eq: Num,\n  neq: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function compareEq(\n  v1: Num,\n  v2: Num,\n  eq: Str,\n  neq: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function compareEq(\n  v1: Str,\n  v2: Str,\n  eq: Num,\n  neq: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function compareEq(\n  v1: Str,\n  v2: Str,\n  eq: Str,\n  neq: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function compareEq(\n  v1: N_S,\n  v2: N_S,\n  eq: N_S,\n  neq: N_S,\n  info?: Info\n): MatchNode<AnyNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(eq), intoV(neq)],\n    info,\n  }\n}\n/** v1 == v2 ? pass : 0 */\nexport function equal(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function equal(\n  v1: Str,\n  v2: Str,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function equal(\n  v1: N_S,\n  v2: N_S,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(0)],\n    emptyOn: 'unmatch',\n  }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function equalStr(\n  v1: Str,\n  v2: Str,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function equalStr(\n  v1: N_S,\n  v2: N_S,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(undefined)],\n    emptyOn: 'unmatch',\n  }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function unequal(\n  v1: Str,\n  v2: Str,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function unequal(\n  v1: N_S,\n  v2: N_S,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(0), intoVInfo(pass, info)],\n    emptyOn: 'match',\n  }\n}\n/** v1 != v2 ? pass : `undefined` */\nexport function unequalStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function unequalStr(\n  v1: Str,\n  v2: Str,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function unequalStr(\n  v1: N_S,\n  v2: N_S,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(undefined), intoVInfo(pass, info)],\n    emptyOn: 'match',\n  }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(\n  v1: Opt,\n  v2: Opt,\n  pass: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function greaterEq(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function greaterEq(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(0)],\n    emptyOn: 'l',\n  }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): ThresholdNode<StrNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(undefined)],\n    emptyOn: 'l',\n  }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(\n  v1: Opt,\n  v2: Opt,\n  pass: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function lessThan(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function lessThan(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoV(0), intoVInfo(pass, info)],\n    emptyOn: 'ge',\n  }\n}\n/** v1 >= v2 ? ge : le */\nexport function threshold(\n  v1: Opt,\n  v2: Opt,\n  ge: Opt,\n  le: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function threshold(\n  v1: Num,\n  v2: Num,\n  ge: Num,\n  le: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function threshold(\n  v1: Num,\n  v2: Num,\n  ge: Num,\n  le: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoV(ge), intoV(le)],\n    info,\n  }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(\n  nodeList: T,\n  prefix: string[] = []\n): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== 'read')\n      throw new Error(\n        `Found ${(nodeList as any).operation} node while making reader`\n      )\n    return { ...nodeList, path: prefix }\n  } else {\n    return objKeyMap(Object.keys(nodeList), (key) =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])\n    ) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(\n  base: AnyNode,\n  data: Data\n): DataNode<NumNode> | DataNode<StrNode>\nexport function data(\n  base: AnyNode,\n  data: Data\n): DataNode<NumNode> | DataNode<StrNode> {\n  return { operation: 'data', operands: [base as any], data }\n}\nexport function resetData(\n  base: NumNode,\n  data: Data,\n  info?: Info\n): DataNode<NumNode>\nexport function resetData(\n  base: StrNode,\n  data: Data,\n  info?: Info\n): DataNode<StrNode>\nexport function resetData(\n  base: AnyNode,\n  data: Data,\n  info?: Info\n): DataNode<AnyNode>\nexport function resetData(\n  base: AnyNode,\n  data: Data,\n  info?: Info\n): DataNode<AnyNode> {\n  return { operation: 'data', operands: [base], data, reset: true, info }\n}\n\nexport function dynRead(\n  name: string,\n  accu: ReadNode<number>['accu'] = 'add',\n  info?: Info\n): ReadNode<number> {\n  return {\n    operation: 'read',\n    operands: [],\n    path: ['dyn', name],\n    accu,\n    type: 'number',\n    info,\n  }\n}\nexport function customRead(\n  path: readonly string[],\n  info?: Info\n): ReadNode<number> {\n  return { operation: 'read', operands: [], path, info, type: 'number' }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: 'read', operands: [], path, type: 'string' }\n}\nexport function read(\n  accu?: ReadNode<number>['accu'],\n  info?: Info\n): ReadNode<number> {\n  return {\n    operation: 'read',\n    operands: [],\n    path: [],\n    accu,\n    info,\n    type: 'number',\n  }\n}\n/**\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\n */\nexport function stringRead(\n  accu?: ReadNode<string | undefined>['accu']\n): ReadNode<string | undefined> {\n  return { operation: 'read', operands: [], path: [], accu, type: 'string' }\n}\nexport function stringPrio(...operands: Str[]): StrPrioNode {\n  return { operation: 'prio', operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(\n  index: NumNode,\n  list: V[],\n  info?: Info\n): SubscriptNode<V> {\n  return { operation: 'subscript', operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: N_S[]): AnyNode[] {\n  return values.map((value) =>\n    typeof value === 'object' ? value : constant(value)\n  )\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: N_S): AnyNode\nfunction intoV(value: N_S): AnyNode {\n  return typeof value !== 'object' ? constant(value) : value\n}\nfunction intoVInfo(value: Num, info: Info | undefined): NumNode\nfunction intoVInfo(value: Str, info: Info | undefined): StrNode\nfunction intoVInfo(value: N_S, info: Info | undefined): AnyNode\nfunction intoVInfo(value: N_S, info: Info | undefined): AnyNode {\n  if (!info) return intoV(value)\n  return typeof value !== 'object'\n    ? constant(value, info)\n    : infoMut({ ...value }, info)\n}\n\ntype _NodeList = { [key: string]: NodeList } & { operation?: never }\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n","import type { AnyNode, Base, NodeData, NumNode, StrNode } from './type'\nimport { constant } from './utils'\n\nexport function deepNodeClone<\n  T extends NodeData<NumNode | StrNode | undefined>\n>(data: T): T {\n  const map = new Map()\n  function internal(orig: any) {\n    if (typeof orig !== 'object') return orig\n    const old = map.get(orig)\n    if (old) return old\n\n    const cache: any = Array.isArray(orig)\n      ? orig.map((val) => internal(val))\n      : Object.fromEntries(\n          Object.entries(orig).map(([key, val]) => [\n            key,\n            key === 'info' ? val : internal(val),\n          ])\n        )\n    map.set(orig, cache)\n    return cache\n  }\n  return internal(data)\n}\n\nexport function forEachNodes<T extends Base<T> = AnyNode>(\n  formulas: T[],\n  topDown: (formula: T) => void,\n  bottomUp: (formula: T) => void\n): void {\n  const visiting = new Set<T>(),\n    visited = new Set<T>()\n\n  function traverse(formula: T) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error('Found cyclical dependency during formula traversal')\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas<\n  Input extends Base<Input> = AnyNode,\n  Interim extends Base<Interim> = Input,\n  Output extends Base<Output> = Interim\n>(\n  formulas: Input[],\n  topDownMap: (formula: Input | Interim) => Interim,\n  bottomUpMap: (current: Interim | Output, orig: Input | Interim) => Output\n): Output[] {\n  const visiting = new Set<Input | Interim>()\n  const topDownMapped = new Map<Input | Interim, Output>()\n  const bottomUpMapped = new Map<Interim, Output>()\n\n  function check(formula: Input | Interim): Output {\n    let topDown: Interim | Output | undefined = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error('Found cyclical dependency during formula mapping')\n      return constant(NaN) as any\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: Interim): Interim | Output {\n    const operands = formula.operands.map(check)\n    return arrayEqual<Interim | Output>(operands, formula.operands)\n      ? formula\n      : { ...formula, operands }\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual<Input | Output>(result, formulas)\n    ? (formulas as any)\n    : result\n}\n\nexport function customMapFormula<Context, Output, Input extends Base<Input>>(\n  formulas: Input[],\n  context: Context,\n  map: (\n    formula: Input,\n    context: Context,\n    map: (node: Input, context: Context) => Output\n  ) => Output\n): Output[] {\n  const contextMapping = new Map<Context, [Set<Input>, Map<Input, Output>]>()\n  function internalMap(formula: Input, context: Context): Output {\n    let current = contextMapping.get(context)\n    if (!current)\n      contextMapping.set(context, (current = [new Set(), new Map()]))\n    const [visiting, mapping] = current\n\n    const old = mapping.get(formula)\n    if (old) return old\n\n    if (visiting.has(formula))\n      throw new Error('Found cyclical dependency during formula mapping')\n\n    visiting.add(formula)\n    const newFormula = map(formula, context, internalMap)\n    mapping.set(formula, newFormula)\n    visiting.delete(formula)\n\n    return newFormula\n  }\n  return formulas.map((formula) => internalMap(formula, context))\n}\n\nfunction arrayEqual<T>(\n  a: readonly T[] | undefined,\n  b: readonly T[] | undefined\n): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import type { ArtifactBuildData } from '../Solver/common'\nimport { assertUnreachable, objPathValue } from '../Util/Util'\nimport { customMapFormula, forEachNodes, mapFormulas } from './internal'\nimport type {\n  AnyNode,\n  CommutativeMonoidOperation,\n  ComputeNode,\n  ConstantNode,\n  Data,\n  NumNode,\n  Operation,\n  ReadNode,\n  StrNode,\n  StrPrioNode,\n  ThresholdNode,\n} from './type'\nimport { constant } from './utils'\n\nexport type OptNode =\n  | ComputeNode<OptNode, OptNode>\n  | ThresholdNode<OptNode, OptNode, OptNode>\n  | ReadNode<number>\n  | ConstantNode<number>\n\nconst allCommutativeMonoidOperations: StrictDict<\n  CommutativeMonoidOperation,\n  (_: number[]) => number\n> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<\n  Operation | 'threshold',\n  (_: number[]) => number\n> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number =>\n    value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(\n  Object.keys(allCommutativeMonoidOperations) as NumNode['operation'][]\n)\n\nexport function optimize(\n  formulas: NumNode[],\n  topLevelData: Data,\n  shouldFold = (_formula: ReadNode<number | string | undefined>) => false\n): OptNode[] {\n  let opts = constantFold(formulas, topLevelData, shouldFold)\n  opts = flatten(opts)\n  opts = constantFold(opts, {})\n  return deduplicate(opts)\n}\nexport function precompute(\n  formulas: OptNode[],\n  initial: ArtifactBuildData['values'],\n  binding: (\n    readNode: ReadNode<number> | ReadNode<string | undefined>\n  ) => string,\n  slotCount: number\n): (_: ArtifactBuildData[]) => number[] {\n  let body = `\n\"use strict\";\n// copied from the code above\nfunction res(res) {\n  if (res < 0) return 1 - res / 2\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\n  return 1 - res\n}\nconst x0=0` // making sure `const` has at least one entry\n\n  let i = 1\n  const names = new Map<NumNode | StrNode, string>()\n  forEachNodes(\n    formulas,\n    (_) => {},\n    (f) => {\n      const { operation, operands } = f,\n        name = `x${i++}`,\n        operandNames = operands.map((x: OptNode) => names.get(x)!)\n      names.set(f, name)\n      switch (operation) {\n        case 'read': {\n          const key = binding(f)\n          let arr = new Array(slotCount)\n            .fill(null)\n            .map((x, i) => `(b[${i}].values[\"${key}\"] ?? 0)`)\n          if (initial[key] && initial[key] !== 0) {\n            arr = [initial[key].toString(), ...arr]\n          }\n          body += `,${name}=${arr.join('+')}`\n          break\n        }\n        case 'const':\n          names.set(f, `(${f.value})`)\n          break\n        case 'add':\n        case 'mul':\n          body += `,${name}=${operandNames.join(\n            operation === 'add' ? '+' : '*'\n          )}`\n          break\n        case 'min':\n        case 'max':\n          body += `,${name}=Math.${operation}(${operandNames})`\n          break\n        case 'threshold': {\n          const [value, threshold, pass, fail] = operandNames\n          body += `,${name}=(${value}>=${threshold})?${pass}:${fail}`\n          break\n        }\n        case 'res':\n          body += `,${name}=res(${operandNames[0]})`\n          break\n        case 'sum_frac':\n          body += `,${name}=${operandNames[0]}/(${operandNames[0]}+${operandNames[1]})`\n          break\n\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n  body += `;\\nreturn [${formulas.map((f) => names.get(f)!)}]`\n  return new (Function as any)(`b`, body)\n}\n\nfunction flatten(formulas: OptNode[]): OptNode[] {\n  return mapFormulas(\n    formulas,\n    (f) => f,\n    (_formula) => {\n      let result = _formula\n      if (commutativeMonoidOperationSet.has(_formula.operation as Operation)) {\n        const formula = _formula as ComputeNode<OptNode>\n        const { operation } = formula\n\n        let flattened = false\n        const operands = formula.operands.flatMap((dep) =>\n          dep.operation === operation\n            ? ((flattened = true), dep.operands)\n            : [dep]\n        )\n        result = flattened ? { ...formula, operands } : formula\n      }\n\n      return result\n    }\n  )\n}\n\nfunction arrayCompare<T>(\n  a: readonly T[],\n  b: readonly T[],\n  cmp: (a: T, b: T) => number\n): number {\n  if (a.length !== b.length) return a.length - b.length\n  for (let i = 0; i < a.length; i++) {\n    const cc = cmp(a[i], b[i])\n    if (cc !== 0) return cc\n  }\n  return 0\n}\n/**\n * Converts `formulas` to a unique normal form via sorting. Commutative operations are\n * also sorted to enforce unique operand ordering. As a consequence, duplicated nodes\n * become easy to find, so we combine identical nodes into the same reference. The\n * sort follows the below fields sequentially:\n *  ```\n *    node height  - height of subtree; distance to furthest leaf.\n *    node type    - Ordering is [const, read, add, mul, min, max, sum_frac, threshold, res]\n *    When types are same:\n *      const:             n.value\n *      read:              alphabetical on path\n *      add/mul/min/max:   sort the operands, then compare sequentially\n *      frac/thresh/res:   compare operands sequentially\n *  ```\n *\n * Sorting is efficient because sorting by ascending height first lets us memoize the\n * ordering of all the children and find a bijection with the natual numbers.\n */\nfunction deduplicate(formulas: OptNode[]): OptNode[] {\n  const nodeHeightMap = new Map<OptNode, number>()\n  const layers = [[]] as OptNode[][]\n  forEachNodes(\n    formulas,\n    (_) => {},\n    (n) => {\n      switch (n.operation) {\n        case 'const':\n        case 'read':\n          layers[0].push(n)\n          nodeHeightMap.set(n, 0)\n          break\n        default: {\n          const h =\n            Math.max(...n.operands.map((op) => nodeHeightMap.get(op)!)) + 1\n          if (layers.length <= h) layers.push([])\n          layers[h].push(n)\n          nodeHeightMap.set(n, h)\n          break\n        }\n      }\n    }\n  )\n\n  function cmpNode(n1: OptNode, n2: OptNode): number {\n    const h1 = nodeHeightMap.get(n1)!,\n      h2 = nodeHeightMap.get(n2)!\n    if (h1 !== h2) return h1 - h2\n    const op1 = n1.operation,\n      op2 = n2.operation\n    if (op1 !== op2) return op1.localeCompare(op2)\n\n    switch (op1) {\n      case 'const':\n        if (op1 !== op2) throw Error('ily jslint')\n        return n1.value - n2.value\n      case 'read':\n        if (op1 !== op2) throw Error('ily jslint')\n        return arrayCompare(n1.path, n2.path, (s1, s2) => s1.localeCompare(s2))\n      case 'res':\n      case 'threshold':\n      case 'sum_frac': {\n        if (op1 !== op2) throw Error('ily jslint')\n        const s1 = n1.operands.map((op) => nodeSortMap.get(op)!),\n          s2 = n2.operands.map((op) => nodeSortMap.get(op)!)\n        return arrayCompare(s1, s2, (n1, n2) => n1 - n2)\n      }\n      case 'add':\n      case 'mul':\n      case 'min':\n      case 'max': {\n        if (op1 !== op2) throw Error('ily jslint')\n        const s1 = n1.operands.map((op) => nodeSortMap.get(op)!),\n          s2 = n2.operands.map((op) => nodeSortMap.get(op)!)\n        s1.sort((a, b) => a - b)\n        s2.sort((a, b) => a - b)\n        return arrayCompare(s1, s2, (n1, n2) => n1 - n2)\n      }\n    }\n  }\n\n  let ix = 0\n  const nodeSortMap = new Map<OptNode, number>()\n  const sortedNodes = [] as OptNode[]\n  layers.forEach((layer) => {\n    layer.sort(cmpNode)\n    sortedNodes.push(layer[0])\n    nodeSortMap.set(layer[0], ix++)\n    for (let i = 1; i < layer.length; i++) {\n      if (cmpNode(layer[i - 1], layer[i]) === 0)\n        nodeSortMap.set(layer[i], nodeSortMap.get(layer[i - 1])!)\n      else {\n        sortedNodes.push(layer[i])\n        nodeSortMap.set(layer[i], ix++)\n      }\n    }\n  })\n\n  sortedNodes.forEach((n, i) => {\n    switch (n.operation) {\n      case 'add':\n      case 'mul':\n      case 'min':\n      case 'max':\n        sortedNodes[i] = {\n          ...n,\n          operands: [...n.operands].sort(\n            (a, b) => nodeSortMap.get(a)! - nodeSortMap.get(b)!\n          ),\n        }\n    }\n  })\n\n  return mapFormulas(\n    formulas,\n    (f) => sortedNodes[nodeSortMap.get(f)!],\n    (_) => _\n  )\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(\n  formulas: NumNode[],\n  topLevelData: Data,\n  shouldFold = (_formula: ReadNode<number | string | undefined>) => false\n): OptNode[] {\n  type Context = {\n    data: Data[]\n    processed: Map<NumNode | StrNode, OptNode | StrNode>\n  }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return customMapFormula<typeof context, OptNode | StrNode, AnyNode>(\n    formulas,\n    context,\n    (formula, context, map) => {\n      const { operation } = formula,\n        fold = (x: NumNode, c: typeof context) => map(x, c) as OptNode\n      const foldStr = (x: StrNode, c: typeof context) => map(x, c) as StrNode\n      let result: OptNode | StrNode\n      switch (operation) {\n        case 'const':\n          result = formula\n          break\n        case 'add':\n        case 'mul':\n        case 'max':\n        case 'min': {\n          const f = allOperations[operation]\n          const numericOperands: number[] = []\n          const formulaOperands: OptNode[] = formula.operands\n            .filter((formula) => {\n              const folded = fold(formula, context)\n              return folded.operation === 'const'\n                ? (numericOperands.push(folded.value), false)\n                : true\n            })\n            .map((x) => fold(x, context))\n          const numericValue = f(numericOperands)\n\n          // Fold degenerate cases. This may incorrectly compute NaN\n          // results, which shouldn't appear under expected usage.\n          // - zero\n          //   - 0 * ... = 0\n          // - infinity\n          //   - max(infinity, ...) = infinity\n          //   - infinity + ... = infinity\n          // - (-infinity)\n          //   - min(-infinity, ...) - infinity\n          //   - (-infinity) + ... = -infinity\n          // - NaN\n          //   - operation(NaN, ...) = NaN\n          if (!isFinite(numericValue)) {\n            if (\n              operation !== 'mul' &&\n              (operation !== 'max' || numericValue > 0) &&\n              (operation !== 'min' || numericValue < 0)\n            ) {\n              result = constant(numericValue)\n              break\n            }\n          } else if (operation === 'mul' && numericValue === 0) {\n            result = constant(numericValue)\n            break\n          }\n\n          if (numericValue !== f([]))\n            // Skip vacuous values\n            formulaOperands.push(constant(numericValue))\n          if (formulaOperands.length <= 1)\n            result = formulaOperands[0] ?? constant(f([]))\n          else result = { operation, operands: formulaOperands }\n          break\n        }\n        case 'res':\n        case 'sum_frac': {\n          const operands = formula.operands.map((x) => fold(x, context))\n          const f = allOperations[operation]\n          if (operands.every((x) => x.operation === 'const'))\n            result = constant(\n              f(operands.map((x) => (x as ConstantNode<number>).value))\n            )\n          else result = { ...formula, operands }\n          break\n        }\n        case 'lookup': {\n          const index = foldStr(formula.operands[0], context)\n          if (index.operation === 'const') {\n            const selected = formula.table[index.value!] ?? formula.operands[1]\n            if (selected) {\n              result = map(selected, context)\n              break\n            }\n          }\n          throw new Error(`Unsupported ${operation} node while folding`)\n        }\n        case 'prio': {\n          const first = formula.operands.find((op) => {\n            const folded = foldStr(op, context)\n            if (folded.operation !== 'const')\n              throw new Error(`Unsupported ${operation} node while folding`)\n            return folded.value !== undefined\n          })\n          result = first ? foldStr(first, context) : constant(undefined)\n          break\n        }\n        case 'small': {\n          let smallest = undefined as\n            | ConstantNode<string | undefined>\n            | undefined\n          for (const operand of formula.operands) {\n            const folded = foldStr(operand, context)\n            if (folded.operation !== 'const')\n              throw new Error(`Unsupported ${operation} node while folding`)\n            if (\n              smallest?.value === undefined ||\n              (folded.value !== undefined && folded.value < smallest.value)\n            )\n              smallest = folded\n          }\n          result = smallest ?? constant(undefined)\n          break\n        }\n        case 'match': {\n          const [v1, v2, match, unmatch] = formula.operands.map(\n            (x: NumNode | StrNode) => map(x, context)\n          )\n          if (v1.operation !== 'const' || v2.operation !== 'const')\n            throw new Error(`Unsupported ${operation} node while folding`)\n          result = v1.value === v2.value ? match : unmatch\n          break\n        }\n        case 'threshold': {\n          const [value, threshold, pass, fail] = formula.operands.map(\n            (x) => map(x, context) as OptNode\n          )\n          if (\n            pass.operation === 'const' &&\n            fail.operation === 'const' &&\n            pass.value === fail.value\n          )\n            result = pass\n          else if (\n            value.operation === 'const' &&\n            threshold.operation === 'const'\n          )\n            result = value.value >= threshold.value ? pass : fail\n          else result = { ...formula, operands: [value, threshold, pass, fail] }\n          break\n        }\n        case 'subscript': {\n          const index = fold(formula.operands[0], context)\n          if (index.operation !== 'const')\n            throw new Error('Found non-constant subscript node while folding')\n          result = constant(formula.list[index.value])\n          break\n        }\n        case 'read': {\n          const operands = context.data\n            .map((x) => objPathValue(x, formula.path) as NumNode | StrNode)\n            .filter((x) => x)\n\n          if (operands.length === 0) {\n            if (shouldFold(formula)) {\n              const { accu } = formula\n              if (accu === undefined || accu === 'small')\n                result =\n                  formula.type === 'string'\n                    ? constant(undefined)\n                    : constant(NaN)\n              else result = constant(allOperations[accu]([]))\n            } else result = formula\n          } else if (formula.accu === undefined || operands.length === 1)\n            result = map(operands[operands.length - 1], context)\n          else\n            result = map(\n              { operation: formula.accu, operands } as\n                | ComputeNode\n                | StrPrioNode,\n              context\n            )\n          break\n        }\n        case 'data': {\n          if (formula.reset) context = origin\n          const nextMap = nextContextMap.get(context)!\n          let nextContext = nextMap.get(formula.data)\n          if (!nextContext) {\n            nextContext = {\n              data: [...context.data, formula.data],\n              processed: new Map(),\n            }\n            nextContextMap.set(nextContext, new Map())\n            nextMap.set(formula.data, nextContext)\n          }\n          result = map(formula.operands[0], nextContext)\n          break\n        }\n        default:\n          assertUnreachable(operation)\n      }\n\n      if (result.info) {\n        result = { ...result }\n        delete result.info\n      }\n      return result\n    }\n  ) as OptNode[]\n}\n\nexport const testing = {\n  constantFold,\n  flatten,\n  deduplicate,\n}\n","import {\n  allArtifactSlotKeys,\n  type ArtifactSetKey,\n  type ArtifactSlotKey,\n} from '@genshin-optimizer/consts'\nimport {\n  assertUnreachable,\n  objKeyMap,\n  objMap,\n  range,\n} from '@genshin-optimizer/util'\nimport type {\n  ArtSetExclusion,\n  ArtSetExclusionKey,\n} from '../Database/DataManagers/BuildSettingData'\nimport { forEachNodes, mapFormulas } from '../Formula/internal'\nimport type { OptNode } from '../Formula/optimization'\nimport { allOperations, constantFold } from '../Formula/optimization'\nimport type { ConstantNode } from '../Formula/type'\nimport { constant, dynRead, max, min, sum, threshold } from '../Formula/utils'\n\ntype MicropassOperation =\n  | 'reaffine'\n  | 'pruneArtRange'\n  | 'pruneNodeRange'\n  | 'pruneOrder'\nexport function pruneAll(\n  nodes: OptNode[],\n  minimum: number[],\n  arts: ArtifactsBySlot,\n  numTop: number,\n  exclusion: ArtSetExclusion,\n  forced: Dict<MicropassOperation, boolean>\n): { nodes: OptNode[]; arts: ArtifactsBySlot } {\n  let should = forced\n  /** If `key` makes progress, all operations in `value` should be performed */\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\n    pruneOrder: { pruneNodeRange: true },\n    pruneArtRange: { pruneNodeRange: true },\n    pruneNodeRange: { reaffine: true },\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true },\n  }\n  let count = 0\n  while (Object.values(should).some((x) => x) && count++ < 20) {\n    if (should.pruneOrder) {\n      delete should.pruneOrder\n      const newArts = pruneOrder(arts, numTop, exclusion)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneOrder }\n      }\n    }\n    if (should.pruneArtRange) {\n      delete should.pruneArtRange\n      const newArts = pruneArtRange(nodes, arts, minimum)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneArtRange }\n      }\n    }\n    if (should.pruneNodeRange) {\n      delete should.pruneNodeRange\n      const newNodes = pruneNodeRange(nodes, arts)\n      if (nodes !== newNodes) {\n        nodes = newNodes\n        should = { ...should, ...deps.pruneNodeRange }\n      }\n    }\n    if (should.reaffine) {\n      delete should.reaffine\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\n      if (nodes !== newNodes || arts !== newArts) {\n        nodes = newNodes\n        arts = newArts\n        should = { ...should, ...deps.reaffine }\n      }\n    }\n  }\n  return { nodes, arts }\n}\n\nexport function pruneExclusion(\n  nodes: OptNode[],\n  exclusion: ArtSetExclusion\n): OptNode[] {\n  const maxValues: Dict<keyof typeof exclusion, number> = {}\n  for (const [key, e] of Object.entries(exclusion)) {\n    if (!e.includes(4)) continue\n    maxValues[key] = e.includes(2) ? 1 : 3\n  }\n  return mapFormulas(\n    nodes,\n    (f) => f,\n    (f) => {\n      if (f.operation !== 'threshold') return f\n\n      const [v, t, pass, fail] = f.operands\n      if (v.operation === 'read' && t.operation === 'const') {\n        const key = v.path[v.path.length - 1],\n          thres = t.value\n        if (key in maxValues) {\n          const max: number = maxValues[key]\n          if (max < thres) return fail\n          if (thres === 2 && exclusion[key]!.includes(2))\n            return threshold(v, 4, pass, fail)\n        }\n      }\n      return f\n    }\n  )\n}\n\nfunction reaffine(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot,\n  forceRename = false\n): { nodes: OptNode[]; arts: ArtifactsBySlot } {\n  const affineNodes = new Set<OptNode>(),\n    topLevelAffine = new Set<OptNode>()\n\n  function visit(node: OptNode, isAffine: boolean): OptNode {\n    if (isAffine) affineNodes.add(node)\n    else\n      node.operands.forEach(\n        (op) => affineNodes.has(op) && topLevelAffine.add(op)\n      )\n    return node\n  }\n\n  const dynKeys = new Set<string>()\n\n  nodes = mapFormulas(\n    nodes,\n    (_) => _,\n    (f) => {\n      const { operation } = f\n      switch (operation) {\n        case 'read':\n          dynKeys.add(f.path[1])\n          return visit(f, true)\n        case 'add': {\n          const affineOps = f.operands.filter((op) => affineNodes.has(op))\n          const nonAffineOps = f.operands.filter((op) => !affineNodes.has(op))\n          if (nonAffineOps.length === 0) return visit(f, true)\n          if (affineOps.length <= 1) return visit(f, false)\n          const affine = visit(sum(...affineOps), true)\n          return visit(sum(affine, ...nonAffineOps), false)\n        }\n        case 'mul': {\n          const nonConst = f.operands.filter((op) => op.operation !== 'const')\n          return visit(\n            f,\n            nonConst.length === 0 ||\n              (nonConst.length === 1 && affineNodes.has(nonConst[0]))\n          )\n        }\n        case 'const':\n          return visit(f, true)\n        case 'res':\n        case 'threshold':\n        case 'sum_frac':\n        case 'max':\n        case 'min':\n          return visit(f, false)\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n\n  nodes\n    .filter((node) => affineNodes.has(node))\n    .forEach((node) => topLevelAffine.add(node))\n  if (\n    [...topLevelAffine].every(\n      ({ operation }) => operation === 'read' || operation === 'const'\n    ) &&\n    Object.keys(arts.base).length === dynKeys.size\n  )\n    return { nodes, arts }\n\n  let current = -1\n  function nextDynKey(): string {\n    while (dynKeys.has(`${++current}`));\n    return `${current}`\n  }\n\n  const affine = [...topLevelAffine].filter((f) => f.operation !== 'const')\n  const affineMap = new Map(\n    affine.map((node) => [\n      node,\n      !forceRename && node.operation === 'read' && node.path[0] === 'dyn'\n        ? node\n        : dynRead(nextDynKey()),\n    ])\n  )\n  nodes = mapFormulas(\n    nodes,\n    (f) => affineMap.get(f) ?? f,\n    (f) => f\n  )\n\n  function reaffineArt(stat: DynStat): DynStat {\n    const values = constantFold(\n      [...affineMap.keys()],\n      {\n        dyn: objMap(stat, (value) => constant(value)),\n      } as any,\n      (_) => true\n    )\n    return Object.fromEntries(\n      [...affineMap.values()].map((v, i) => [\n        v.path[1],\n        (values[i] as ConstantNode<number>).value,\n      ])\n    )\n  }\n  const result = {\n    nodes,\n    arts: {\n      base: reaffineArt(arts.base),\n      values: objKeyMap(allArtifactSlotKeys, (slot) =>\n        arts.values[slot].map(({ id, set, values }) => ({\n          id,\n          set,\n          values: reaffineArt(values),\n        }))\n      ),\n    },\n  }\n  const offsets = Object.entries(reaffineArt({}))\n  for (const arts of Object.values(result.arts.values))\n    for (const { values } of arts)\n      for (const [key, baseValue] of offsets) values[key] -= baseValue\n  return result\n}\n/** Remove artifacts that cannot be in top `numTop` builds */\nfunction pruneOrder(\n  arts: ArtifactsBySlot,\n  numTop: number,\n  exclusion: ArtSetExclusion\n): ArtifactsBySlot {\n  let progress = false\n  /**\n   * Note:\n   * This function assumes that every base (reaffined) stats are monotonically increasing. That is, artifacts\n   * with higher stats are better. This remains true as long as the main and substats are in increasing. Set\n   * effects that decrease enemy resistance (which is monotonically decreasing) does not violate this assumption\n   * as set effects are not handled here.\n   */\n  const allowRainbow = !exclusion.rainbow?.length,\n    keys = Object.keys(arts.base)\n  const noSwitchIn = new Set(\n    Object.entries(exclusion)\n      .filter(([_, v]) => v.length)\n      .map(([k]) => k) as ArtifactSetKey[]\n  )\n  const noSwitchOut = new Set(\n    Object.entries(exclusion)\n      .filter(([_, v]) => v.includes(2) && !v.includes(4))\n      .map(([k]) => k) as ArtifactSetKey[]\n  )\n  const values = objKeyMap(allArtifactSlotKeys, (slot) => {\n    const list = arts.values[slot]\n    const newList = list.filter((art) => {\n      let count = 0\n      return list.every((other) => {\n        const otherBetterEqual = keys.every(\n          (k) => (other.values[k] ?? 0) >= (art.values[k] ?? 0)\n        )\n        const otherMaybeBetter = keys.some(\n          (k) => (other.values[k] ?? 0) > (art.values[k] ?? 0)\n        )\n        const otherBetter =\n          otherBetterEqual && (otherMaybeBetter || other.id > art.id)\n        const canSwitch =\n          (allowRainbow &&\n            !noSwitchIn.has(other.set!) &&\n            !noSwitchOut.has(art.set!)) ||\n          art.set === other.set\n        if (otherBetter && canSwitch) count++\n        return count < numTop\n      })\n    })\n    if (newList.length !== list.length) progress = true\n    return newList\n  })\n  return progress ? { base: arts.base, values } : arts\n}\n/** Remove artifacts that cannot reach `minimum` in any build */\nfunction pruneArtRange(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot,\n  minimum: number[]\n): ArtifactsBySlot {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  const wrap = { arts }\n  while (true) {\n    const artRanges = objKeyMap(allArtifactSlotKeys, (slot) =>\n      computeArtRange(wrap.arts.values[slot])\n    )\n    const otherArtRanges = objKeyMap(allArtifactSlotKeys, (key) =>\n      addArtRange(\n        Object.entries(artRanges)\n          .map((a) => (a[0] === key ? baseRange : a[1]))\n          .filter((x) => x)\n      )\n    )\n\n    let progress = false\n    const values = objKeyMap(allArtifactSlotKeys, (slot) => {\n      const result = wrap.arts.values[slot].filter((art) => {\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\n        const newRange = computeNodeRange(nodes, read)\n        return nodes.every(\n          (node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity)\n        )\n      })\n      if (result.length !== wrap.arts.values[slot].length) progress = true\n      return result\n    })\n    if (!progress) break\n    wrap.arts = { base: wrap.arts.base, values }\n  }\n  return wrap.arts\n}\nfunction pruneNodeRange(nodes: OptNode[], arts: ArtifactsBySlot): OptNode[] {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  const reads = addArtRange([\n    baseRange,\n    ...Object.values(arts.values).map((values) => computeArtRange(values)),\n  ])\n  const nodeRange = computeNodeRange(nodes, reads)\n\n  return mapFormulas(\n    nodes,\n    (f) => {\n      {\n        const { min, max } = nodeRange.get(f)!\n        if (min === max) return constant(min)\n      }\n      const { operation } = f\n      const operandRanges = f.operands.map((x) => nodeRange.get(x)!)\n      switch (operation) {\n        case 'threshold': {\n          const [value, threshold, pass, fail] = operandRanges\n          if (value.min >= threshold.max) return f.operands[2]\n          else if (value.max < threshold.min) return f.operands[3]\n          if (\n            pass.max === pass.min &&\n            fail.max === fail.min &&\n            pass.min === fail.min &&\n            isFinite(pass.min)\n          )\n            return constant(pass.max)\n          break\n        }\n        case 'min': {\n          const newOperands = f.operands.filter((_, i) => {\n            const op1 = operandRanges[i]\n            return operandRanges.every((op2) => op1.min <= op2.max)\n          })\n          if (newOperands.length < operandRanges.length)\n            return min(...newOperands)\n          break\n        }\n        case 'max': {\n          const newOperands = f.operands.filter((_, i) => {\n            const op1 = operandRanges[i]\n            return operandRanges.every((op2) => op1.max >= op2.min)\n          })\n          if (newOperands.length < operandRanges.length)\n            return max(...newOperands)\n          break\n        }\n      }\n      return f\n    },\n    (f) => f\n  )\n}\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\n  const result: DynMinMax = {}\n  ranges.forEach((range) => {\n    Object.entries(range).forEach(([key, value]) => {\n      if (result[key]) {\n        result[key].min += value.min\n        result[key].max += value.max\n      } else result[key] = { ...value }\n    })\n  })\n  return result\n}\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\n  const result: DynMinMax = {}\n  if (arts.length) {\n    Object.keys(arts[0].values)\n      .filter((key) => arts.every((art) => art.values[key]))\n      .forEach(\n        (key) =>\n          (result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\n      )\n    arts.forEach(({ values }) => {\n      for (const [key, value] of Object.entries(values)) {\n        if (!result[key]) result[key] = { min: 0, max: value }\n        else {\n          if (result[key].max < value) result[key].max = value\n          if (result[key].min > value) result[key].min = value\n        }\n      }\n    })\n  }\n  return result\n}\nexport function computeFullArtRange(arts: ArtifactsBySlot): DynMinMax {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  return addArtRange([\n    baseRange,\n    ...Object.values(arts.values).map((values) => computeArtRange(values)),\n  ])\n}\nexport function computeNodeRange(\n  nodes: OptNode[],\n  reads: DynMinMax\n): Map<OptNode, MinMax> {\n  const range = new Map<OptNode, MinMax>()\n\n  forEachNodes(\n    nodes,\n    (_) => {},\n    (f) => {\n      const { operation } = f\n      const operands = f.operands.map((op) => range.get(op)!)\n      let current: MinMax\n      switch (operation) {\n        case 'read':\n          if (f.path[0] !== 'dyn')\n            throw new Error(\n              `Found non-dyn path ${f.path} while computing range`\n            )\n          current = reads[f.path[1]] ?? { min: 0, max: 0 }\n          break\n        case 'const':\n          current = computeMinMax([f.value])\n          break\n        case 'add':\n        case 'min':\n        case 'max':\n          current = {\n            min: allOperations[operation](operands.map((x) => x.min)),\n            max: allOperations[operation](operands.map((x) => x.max)),\n          }\n          break\n        case 'res':\n          current = {\n            min: allOperations[operation]([operands[0].max]),\n            max: allOperations[operation]([operands[0].min]),\n          }\n          break\n        case 'mul':\n          current = operands.reduce((accu, current) =>\n            computeMinMax([\n              accu.min * current.min,\n              accu.min * current.max,\n              accu.max * current.min,\n              accu.max * current.max,\n            ])\n          )\n          break\n        case 'threshold':\n          if (operands[0].min >= operands[1].max) current = operands[2]\n          else if (operands[0].max < operands[1].min) current = operands[3]\n          else current = computeMinMax([], [operands[2], operands[3]])\n          break\n        case 'sum_frac': {\n          const [x, c] = operands,\n            sum = { min: x.min + c.min, max: x.max + c.max }\n          if (sum.min <= 0 && sum.max >= 0)\n            current =\n              x.min <= 0 && x.max >= 0\n                ? { min: NaN, max: NaN }\n                : { min: -Infinity, max: Infinity }\n          // TODO: Check this\n          else\n            current = computeMinMax([\n              x.min / sum.min,\n              x.min / sum.max,\n              x.max / sum.min,\n              x.max / sum.max,\n            ])\n          break\n        }\n        default:\n          assertUnreachable(operation)\n      }\n      range.set(f, current)\n    }\n  )\n  return range\n}\nfunction computeMinMax(\n  values: readonly number[],\n  minMaxes: readonly MinMax[] = []\n): MinMax {\n  const max = Math.max(...values, ...minMaxes.map((x) => x.max))\n  const min = Math.min(...values, ...minMaxes.map((x) => x.min))\n  return { min, max }\n}\n\nexport function filterArts(\n  arts: ArtifactsBySlot,\n  filters: RequestFilter\n): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objKeyMap(allArtifactSlotKeys, (slot) => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case 'id':\n          return arts.values[slot].filter((art) => filter.ids.has(art.id))\n        case 'exclude':\n          return arts.values[slot].filter((art) => !filter.sets.has(art.set!))\n        case 'required':\n          return arts.values[slot].filter((art) => filter.sets.has(art.set!))\n      }\n    }),\n  }\n}\n\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\n  return builds\n    .flatMap((x) => x)\n    .sort((a, b) => b.value - a.value)\n    .slice(0, maxNum)\n}\nexport function mergePlot(plots: PlotData[]): PlotData {\n  let scale = 0.01\n  const reductionScaling = 2,\n    maxCount = 1500\n  let keys = new Set(\n    plots.flatMap((x) =>\n      Object.values(x).map((v) => Math.round(v.plot! / scale))\n    )\n  )\n  while (keys.size > maxCount) {\n    scale *= reductionScaling\n    keys = new Set([...keys].map((key) => Math.round(key / reductionScaling)))\n  }\n  const result: PlotData = {}\n  for (const plot of plots)\n    for (const build of Object.values(plot)) {\n      const x = Math.round(build.plot! / scale) * scale\n      if (!result[x] || result[x]!.value < build.value) result[x] = build\n    }\n  return result\n}\n\nexport function countBuilds(arts: ArtifactsBySlot): number {\n  return allArtifactSlotKeys.reduce(\n    (_count, slot) => _count * arts.values[slot].length,\n    1\n  )\n}\n\nexport function* filterFeasiblePerm(\n  filters: Iterable<RequestFilter>,\n  _artSets: ArtifactsBySlot\n): Iterable<RequestFilter> {\n  const artSets = objMap(\n    _artSets.values,\n    (values) => new Set(values.map((v) => v.set))\n  )\n  filter_loop: for (const filter of filters) {\n    for (const [slot, f] of Object.entries(filter)) {\n      const available = artSets[slot]!\n      switch (f.kind) {\n        case 'required':\n          if ([...f.sets].every((s) => !available.has(s))) continue filter_loop\n          break\n        case 'exclude':\n          if ([...available].every((s) => f.sets.has(s!))) continue filter_loop\n          break\n        case 'id':\n          break\n      }\n    }\n    yield filter\n  }\n}\nexport function exclusionToAllowed(\n  exclusion: number[] | undefined\n): Set<number> {\n  return new Set(\n    exclusion?.includes(2)\n      ? exclusion.includes(4)\n        ? [0, 1]\n        : [0, 1, 4, 5]\n      : exclusion?.includes(4)\n      ? [0, 1, 2, 3]\n      : [0, 1, 2, 3, 4, 5]\n  )\n}\n/** A *disjoint* set of `RequestFilter` satisfying the exclusion rules */\nexport function* artSetPerm(\n  exclusion: ArtSetExclusion,\n  _artSets: ArtifactSetKey[]\n): Iterable<RequestFilter> {\n  /**\n   * This generation algorithm is separated into two parts:\n   * - \"Shape\" generation\n   *   - It first generates all build \"shapes\", e.g., AABBC, ABBCD\n   *   - It then filters the generated shapes according to the rainbow exclusion, e.g., removes ABBCD if excluding 3 rainbows\n   *   - It then merges the remaining shapes into wildcards, e.g. AABAA + AABAB + AABAC => AABA*\n   * - Shape filling\n   *   - From the given shapes, it tries to fill in all non-rainbow slots, e.g., slots A and B of AABBC, with actual artifacts\n   *   - It then fills the rainbow slots, e.g., slot C of AABBC while ensuring the exclusion rule of each sets\n   */\n  const artSets = [...new Set(_artSets)],\n    allowedRainbows = exclusionToAllowed(exclusion.rainbow)\n  let shapes: number[][] = []\n  function populateShapes(\n    current: number[],\n    list: Set<number>,\n    rainbows: number[]\n  ) {\n    if (current.length === 5) {\n      if (allowedRainbows.has(rainbows.length)) shapes.push(current)\n      return\n    }\n    for (const i of list)\n      populateShapes(\n        [...current, i],\n        list,\n        rainbows.filter((j) => j !== i)\n      )\n    populateShapes(\n      [...current, current.length],\n      new Set([...list, current.length]),\n      [...rainbows, current.length]\n    )\n  }\n  populateShapes([0], new Set([0]), [0])\n  function indexOfShape(shape: number[], replacing: number) {\n    if (range(replacing + 1, 4).some((i) => shape[i] !== 5)) return undefined\n    shape = [...shape]\n    shape[replacing] = 5\n    return shape.reduce((a, b) => a * 6 + b, 0)\n  }\n  for (let replacing = 4; replacing >= 0; replacing--) {\n    const required: Map<number, number> = new Map()\n    for (const shape of shapes) {\n      const id = indexOfShape(shape, replacing)\n      if (id === undefined) continue\n      required.set(\n        id,\n        (required.get(id) ?? new Set(shape.slice(0, replacing)).size + 1) - 1\n      )\n    }\n    for (const [id, remaining] of required.entries()) {\n      if (remaining === 0) {\n        const shape = [\n          ...shapes.find((shape) => indexOfShape(shape, replacing) === id)!,\n        ]\n        shape[replacing] = 5\n        shapes = shapes.filter((shape) => indexOfShape(shape, replacing) !== id)\n        shapes.push(shape)\n      }\n    }\n  }\n\n  // Shapes are now calculated and merged, proceed to fill in the sets\n\n  const noFilter = { kind: 'exclude' as const, sets: new Set<ArtifactSetKey>() }\n  const result: RequestFilter = objKeyMap(allArtifactSlotKeys, (_) => noFilter)\n\n  const counts = {\n    ...objMap(exclusion as Record<ArtSetExclusionKey, (2 | 4)[]>, (_) => 0),\n    ...objKeyMap(artSets, (_) => 0),\n  }\n  const allowedCounts = objMap(\n    exclusion as Record<ArtSetExclusionKey, (2 | 4)[]>,\n    exclusionToAllowed\n  )\n\n  function* check(shape: number[]) {\n    const used: Set<ArtifactSetKey> = new Set(),\n      rainbows: number[] = []\n    let groupped: number[][] = []\n    for (const i of shape) {\n      groupped.push([])\n      if (i === 5) rainbows.push(groupped.length - 1)\n      else groupped[i].push(groupped.length - 1)\n    }\n    groupped = groupped\n      .filter((v) => v.length)\n      .sort((a, b) => b.length - a.length)\n    let usableRainbows = rainbows.length\n\n    // Inception.. because js doesn't like functions inside a for-loop\n    function* check(i: number) {\n      if (i === groupped.length) return yield* check_free(0)\n\n      for (const set of artSets) {\n        if (used.has(set)) continue\n        const length = groupped[i].length,\n          allowedSet = allowedCounts[set]\n        let requiredRainbows = 0\n\n        if (allowedSet && !allowedSet.has(length)) {\n          // Look ahead and see if we have enough rainbows to fill to the next `allowedSet` if we use the current set\n          requiredRainbows =\n            (range(length + 1, 5).find((l) => allowedSet.has(l)) ?? 6) - length\n          if (requiredRainbows > usableRainbows) continue // Not enough rainbows. Next..\n        }\n\n        used.add(set)\n        counts[set] = groupped[i].length\n        groupped[i].forEach(\n          (j) =>\n            (result[allArtifactSlotKeys[j]] = {\n              kind: 'required',\n              sets: new Set([set]),\n            })\n        )\n        usableRainbows -= requiredRainbows\n\n        yield* check(i + 1)\n\n        usableRainbows += requiredRainbows\n        counts[set] = 0\n        used.delete(set)\n      }\n    }\n    // We separate filling rainbow slots from groupped slots because it has an entirely\n    // different set of rules regarding what can be filled and what states to be kept.\n    function* check_free(i: number) {\n      const remaining = rainbows.length - i,\n        isolated: ArtifactSetKey[] = [],\n        missing: ArtifactSetKey[] = [],\n        rejected: ArtifactSetKey[] = []\n      let required = 0\n      for (const set of artSets) {\n        const allowedSet = allowedCounts[set],\n          count = counts[set]\n        if (!allowedSet) continue\n        if (range(1, remaining).every((j) => !allowedSet.has(count + j)))\n          rejected.push(set)\n        else if (!allowedSet.has(count)) {\n          required += [...allowedSet].find((x) => x > count)! - count\n          missing.push(set)\n        } else if (range(0, remaining).some((j) => !allowedSet.has(count + j)))\n          isolated.push(set)\n      }\n      if (required > remaining) return\n      if (i === rainbows.length) {\n        yield { ...result }\n        return\n      }\n      if (required === remaining) {\n        for (const set of missing) {\n          counts[set]++\n          result[allArtifactSlotKeys[rainbows[i]]] = {\n            kind: 'required',\n            sets: new Set([set]),\n          }\n          yield* check_free(i + 1)\n          counts[set]--\n        }\n        return\n      }\n      for (const set of [...isolated, ...missing]) {\n        counts[set]++\n        result[allArtifactSlotKeys[rainbows[i]]] = {\n          kind: 'required',\n          sets: new Set([set]),\n        }\n        yield* check_free(i + 1)\n        counts[set]--\n      }\n      result[allArtifactSlotKeys[rainbows[i]]] = {\n        kind: 'exclude',\n        sets: new Set([...missing, ...rejected, ...isolated]),\n      }\n      yield* check_free(i + 1)\n    }\n    yield* check(0)\n  }\n  for (const shape of shapes) yield* check(shape)\n}\n\nexport type RequestFilter = StrictDict<\n  ArtifactSlotKey,\n  | { kind: 'required'; sets: Set<ArtifactSetKey> }\n  | { kind: 'exclude'; sets: Set<ArtifactSetKey> }\n  | { kind: 'id'; ids: Set<string> }\n>\n\nexport type DynStat = { [key in string]: number }\nexport type ArtifactBuildData = {\n  id: string\n  set?: ArtifactSetKey\n  values: DynStat\n}\nexport type ArtifactsBySlot = {\n  base: DynStat\n  values: StrictDict<ArtifactSlotKey, ArtifactBuildData[]>\n}\n\nexport type PlotData = Dict<number, Build>\nexport interface Build {\n  value: number\n  plot?: number\n  artifactIds: string[]\n}\n\nexport type DynMinMax = { [key in string]: MinMax }\nexport type MinMax = { min: number; max: number }\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { customMapFormula, forEachNodes } from '../../../Formula/internal'\nimport type { OptNode } from '../../../Formula/optimization'\nimport { allOperations } from '../../../Formula/optimization'\nimport type { ConstantNode } from '../../../Formula/type'\nimport { prod, threshold } from '../../../Formula/utils'\nimport { assertUnreachable, cartesian } from '../../../Util/Util'\nimport type { ArtifactsBySlot, MinMax } from '../../common'\nimport { computeFullArtRange, computeNodeRange } from '../../common'\nimport type { Linear } from './linearUB'\n\n/**\n * With xi being the variables and pi(x1, x2, ...) being polynomials on xi\n *    LinTerm  = $c + w1*x1 + w2*x2 + ...\n *    PolyProd = $k * p1 * p2 * ...\n *    PolySum  = $c + p1 + p2 + ...\n *\n * $c is used as additive constant, $k is used as multiplicative constant.\n */\nexport type PolynomialWithBounds = PolyProd | PolySum | LinTerm\ntype LinTerm = { type: 'lin'; lin: Linear; min: number; max: number }\ntype PolyProd = {\n  type: 'prod'\n  terms: PolynomialWithBounds[]\n  $k: number\n  min: number\n  max: number\n}\ntype PolySum = {\n  type: 'sum'\n  terms: PolynomialWithBounds[]\n  $c: number\n  min: number\n  max: number\n}\n\nfunction constP(n: number): LinTerm {\n  return { type: 'lin', lin: { $c: n }, min: n, max: n }\n}\nfunction readP(k: string, minmax: MinMax): LinTerm {\n  return { type: 'lin', lin: { [k]: 1, $c: 0 }, ...minmax }\n}\nfunction sumP(...terms: (PolynomialWithBounds | number)[]): PolySum {\n  const c = (terms.filter((v) => typeof v === 'number') as number[]).reduce(\n    (a, b) => a + b,\n    0\n  )\n  const poly = terms.filter(\n    (v) => typeof v !== 'number'\n  ) as PolynomialWithBounds[]\n  return {\n    type: 'sum',\n    terms: poly,\n    $c: c,\n    min: poly.reduce((a, { min }) => a + min, c),\n    max: poly.reduce((a, { max }) => a + max, c),\n  }\n}\nfunction prodP(...terms: (PolynomialWithBounds | number)[]): PolyProd {\n  const k = (terms.filter((v) => typeof v === 'number') as number[]).reduce(\n    (a, b) => a * b,\n    1\n  )\n  const poly = terms.filter(\n    (v) => typeof v !== 'number'\n  ) as PolynomialWithBounds[]\n  const minMax = poly.reduce(\n    ({ min: min1, max: max1 }, { min: min2, max: max2 }) => {\n      return {\n        min: Math.min(min1 * min2, min1 * max2, max1 * min2, max1 * max2),\n        max: Math.max(min1 * min2, min1 * max2, max1 * min2, max1 * max2),\n      }\n    },\n    { min: k, max: k }\n  )\n  return { type: 'prod', terms: poly, $k: k, ...minMax }\n}\n\nfunction slopePoint(\n  slope: number,\n  x0: number,\n  y0: number,\n  poly: PolynomialWithBounds\n): PolynomialWithBounds {\n  return sumP(y0 - slope * x0, prodP(slope, poly))\n}\nfunction interpolate(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  poly: PolynomialWithBounds,\n  upper: boolean\n): PolynomialWithBounds {\n  if (Math.abs(x0 - x1) < 1e-10)\n    return constP(upper ? Math.max(y0, y1) : Math.min(y0, y1))\n  return slopePoint((y1 - y0) / (x1 - x0), x0, y0, poly)\n}\n\nexport function polyUB(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot\n): SumOfMonomials[] {\n  const minMaxes = new Map<OptNode, MinMax>()\n  forEachNodes(\n    nodes,\n    (f) => {\n      const { operation } = f\n      if (operation === 'mul') minMaxes.set(f, { min: NaN, max: NaN })\n      switch (operation) {\n        case 'mul':\n        case 'min':\n        case 'max':\n        case 'threshold':\n        case 'res':\n        case 'sum_frac':\n          f.operands.forEach((op) => minMaxes.set(op, { min: NaN, max: NaN }))\n      }\n    },\n    (_) => _\n  )\n  const statMinMax = computeFullArtRange(arts)\n  const nodeRanges = computeNodeRange([...minMaxes.keys()], statMinMax)\n  for (const [node, minMax] of nodeRanges.entries()) minMaxes.set(node, minMax)\n\n  const upper = 'u',\n    lower = 'l',\n    exact = 'e'\n  type Context = typeof upper | typeof lower | typeof exact\n  const poly = customMapFormula<Context, PolynomialWithBounds, OptNode>(\n    nodes,\n    upper,\n    (f, context, _map) => {\n      const { operation } = f\n      const map: (op: OptNode, c?: Context) => PolynomialWithBounds = (\n        op,\n        c = context\n      ) => _map(op, c)\n      const oppositeContext = context === upper ? lower : upper\n\n      switch (operation) {\n        case 'const':\n          return constP(f.value)\n        case 'read':\n          return readP(f.path[1], minMaxes.get(f)!)\n        case 'add':\n          return sumP(...f.operands.map((op) => map(op)))\n        case 'mul': {\n          if (context === exact)\n            return prodP(...f.operands.map((op) => map(op)))\n          const { min: minf, max: maxf } = minMaxes.get(f)!\n          if (minf === maxf) return constP(minf) // Handles zero coeff\n          const zeroCrossing =\n            minf * maxf < 0 ||\n            f.operands.some((op) => {\n              const { min, max } = minMaxes.get(op)!\n              return min * max < 0\n            })\n          if (zeroCrossing) return map(f, exact)\n\n          const signf = minf === 0 ? maxf : minf\n          const op = allOperations[operation]\n          const k = op(\n            f.operands\n              .filter((op) => op.operation === 'const')\n              .map((c) => (c as ConstantNode<number>).value)\n          )\n          const polys = f.operands\n            .filter((op) => op.operation !== 'const')\n            .map((op) => {\n              const { min, max } = minMaxes.get(op)!\n              const sign = min === 0 ? max : min\n              const ctx = signf * sign > 0 ? context : oppositeContext\n              const p = map(op, ctx)\n\n              if (\n                (ctx === lower && max > 0 && p.min < -min) ||\n                (ctx === upper && min < 0 && p.max > -max)\n              )\n                throw new PolyError(\n                  'Unallowed large crossing post approximation',\n                  operation\n                )\n\n              return p\n            })\n          return prodP(k, ...polys)\n        }\n        case 'min':\n        case 'max': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          const op = allOperations[operation]\n          const xs = f.operands.filter((op) => op.operation !== 'const'),\n            [xOp] = xs\n          if (xs.length !== 1) throw new PolyError('Multivariate', operation)\n\n          const x = map(xOp),\n            c = op(\n              f.operands\n                .filter((op) => op.operation === 'const')\n                .map((c) => (c as ConstantNode<number>).value)\n            )\n          if (\n            (operation === 'max' && context === lower) ||\n            (operation === 'min' && context === upper)\n          )\n            return x\n          const { min, max } = minMaxes.get(xOp)!,\n            yMin = op([min, c]),\n            yMax = op([max, c])\n          return interpolate(min, yMin, max, yMax, x, context === upper)\n        }\n        case 'res': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          if (context === lower)\n            throw new PolyError('Unsupported direction', operation)\n          const op = allOperations[operation]\n          const [xOp] = f.operands,\n            { min, max } = minMaxes.get(xOp)!\n          const x = map(xOp, oppositeContext)\n          // Linear region 1 - base/2 or concave region with peak at base = 0\n          if (min < 0 && max < 1.75) return sumP(1, prodP(-0.5, x))\n          // Clamp `min` to guarantee upper bound\n          else\n            return interpolate(\n              min,\n              op([min]),\n              max,\n              op([max]),\n              x,\n              context === upper\n            )\n        }\n        case 'sum_frac': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          if (context === lower)\n            throw new PolyError('Unsupported direction', operation)\n          const [xOp, cOp] = f.operands\n          if (cOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          const x = map(xOp),\n            c = cOp.value,\n            { min, max } = minMaxes.get(xOp)!\n          if (min <= -c)\n            throw new PolyError('Unallowed negative argument', operation)\n          const loc = Math.sqrt((min + c) * (max + c))\n          return slopePoint(c / (loc + c) / (loc + c), loc, loc / (loc + c), x)\n        }\n        case 'threshold': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          const [vOp, tOp, pOp, fOp] = f.operands\n          if (tOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          const { min, max } = minMaxes.get(vOp)!\n          if (min >= tOp.value) return map(pOp)\n          if (max < tOp.value) return map(fOp)\n\n          if (fOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          if (pOp.operation !== 'const') {\n            if (fOp.value !== 0)\n              throw new PolyError('Unsupported pattern', operation)\n\n            const threshOp = threshold(vOp, tOp, 1, fOp),\n              mulOp = prod(threshOp, pOp)\n            // Populate `minMaxes` to ensure consistency\n            const { min, max } = minMaxes.get(pOp)!\n            minMaxes.set(threshOp, { min: 0, max: 1 })\n            minMaxes.set(mulOp, {\n              min: Math.min(min, 0),\n              max: Math.max(max, 0),\n            })\n            return map(mulOp)\n          }\n          const thresh = tOp.value,\n            pass = pOp.value,\n            fail = fOp.value\n          const isFirstHalf = pass > fail === (context === upper)\n\n          const v = map(vOp, isFirstHalf ? upper : lower)\n          if (isFirstHalf) {\n            const slope = (pass - fail) / (thresh - min)\n            return slopePoint(slope, thresh, pass, v)\n          }\n          // not first half -> return const(fail)\n          // Can also interpolate slopePoint on 2nd half, but I choose not to\n          return constP(fail)\n        }\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n\n  return poly.map((p) => expandPoly(p))\n}\n\nexport type SumOfMonomials = Monomial[]\ntype Monomial = {\n  $k: number\n  terms: string[]\n}\nfunction constM(v: number): Monomial {\n  return { $k: v, terms: [] }\n}\nfunction weightedReadM(key: string, v: number): Monomial {\n  return { $k: v, terms: [key] }\n}\nfunction sumM(...monomials: Monomial[][]): Monomial[] {\n  return monomials.flat()\n}\nfunction prodM(...monomials: Monomial[][]): Monomial[] {\n  return cartesian(...monomials).map((monos) =>\n    monos.reduce(\n      (ret, nxt) => {\n        ret.$k *= nxt.$k\n        ret.terms.push(...nxt.terms)\n        return ret\n      },\n      { $k: 1, terms: [] }\n    )\n  )\n}\nfunction foldLikeTerms(mon: Monomial[]): Monomial[] {\n  mon.forEach((m) => m.terms.sort())\n  mon.sort(({ terms: termsA }, { terms: termsB }) => {\n    if (termsA.length !== termsB.length) return termsA.length - termsB.length\n    for (let i = 0; i < termsA.length; i++) {\n      if (termsA[i] !== termsB[i]) return termsA[i] < termsB[i] ? -1 : +1\n    }\n    return 0\n  })\n\n  for (let i = mon.length - 2; i >= 0; i--) {\n    if (mon[i].$k === 0) {\n      mon.splice(i, 1)\n      continue\n    }\n    const a = mon[i].terms\n    const b = mon[i + 1].terms\n    if (a.length !== b.length) continue\n    if (a.every((ai, i) => ai === b[i])) {\n      mon[i].$k = mon[i].$k + mon[i + 1].$k\n      mon.splice(i + 1, 1)\n    }\n  }\n  return mon\n}\nfunction expandPoly(node: PolynomialWithBounds): SumOfMonomials {\n  function toExpandedPoly(n: PolynomialWithBounds): Monomial[] {\n    switch (n.type) {\n      case 'lin':\n        return Object.entries(n.lin)\n          .filter(([_, v]) => v !== 0)\n          .map(([k, v]) => {\n            if (k === '$c') return constM(v)\n            return weightedReadM(k, v)\n          })\n      case 'sum':\n        return sumM(...n.terms.map((t) => toExpandedPoly(t)), [constM(n.$c)])\n      case 'prod':\n        return prodM(...n.terms.map((t) => toExpandedPoly(t)), [constM(n.$k)])\n    }\n  }\n\n  return foldLikeTerms(toExpandedPoly(node))\n}\n\nclass PolyError extends Error {\n  constructor(cause: string, operation: string) {\n    super(\n      `Found ${cause} in ${operation} node when generating polynomial upper bound`\n    )\n  }\n}\n","// Matrix convention is row-major, indexed A_{ij} = A[i][j]\ntype Pivot = { i: number; j: number }\nconst zero = 1e-8 // Small number equivalent to 0 for numerical instability\n\n/** Checks that all constraints are satisfied (Ax <= b) */\nexport function isFeasible(Ab: number[][], x: number[]): boolean {\n  const b = x.length\n  return Ab.every(\n    (row) => x.reduce((tot, xi, i) => tot + xi * row[i], 0) <= row[b] + zero\n  )\n}\n\n/**\n * Solve a Linear Program defined by:\n *              min  c^T x\n *               x\n *   Subject to:     Ax <= b\n *                    x >= 0\n *\n * Implemented according to the Simplex Method (Sec 4) of:\n *   Ferguson, https://www.math.ucla.edu/~tom/LP.pdf\n *\n * Does not implement any cycle detection, though that *shouldnt* be a problem for GO's use\n *   case. This algorithm will always return a feasible solution, though it may be suboptimal.\n *\n * @param c        Objective vector\n * @param Ab       Constraints matrix with thresholds. Inputted in block form [A, b]\n * @returns        a valid solution x, optimal if everything went well.\n */\nexport function solveLP(c: number[], Ab: number[][]) {\n  const rows = Ab.length + 1\n  const cols = Ab[0].length\n\n  const tableau = Array(rows)\n    .fill(0)\n    .map((_) => Array(cols).fill(0))\n  Ab.forEach((Ai, i) => Ai.forEach((Aij, j) => (tableau[i][j] = Aij)))\n  c.forEach((cj, j) => (tableau[rows - 1][j] = cj))\n\n  const pivotHistory: Pivot[] = [] // Keep track of all chosen pivots for backtracking later\n\n  while (tableau.some((t, i) => i < rows - 1 && t[cols - 1] < -zero)) {\n    const piv = findPiv2(tableau)\n    pivotHistory.push(piv)\n    pivotInplace(tableau, piv)\n  }\n\n  while (tableau[rows - 1].some((t, j) => j < cols - 1 && t < -zero)) {\n    const piv = findPiv1(tableau)\n    pivotHistory.push(piv)\n    pivotInplace(tableau, piv)\n  }\n\n  const xOpt = c.map((_, i) => backtrack(tableau, pivotHistory, i))\n  if (!isFeasible(Ab, xOpt)) throw Error('COMPUTED SOLUTION IS NOT FEASIBLE')\n  return xOpt\n}\n\n/** Standard `pivot` operation on LPs */\nfunction pivotInplace(A: number[][], { i, j }: Pivot) {\n  const Aij = A[i][j]\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    for (let k = 0; k < A[0].length; k++) {\n      if (k === j) continue\n      A[h][k] -= (A[i][k] * A[h][j]) / Aij\n    }\n  }\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    A[h][j] = -A[h][j] / Aij\n  }\n  for (let k = 0; k < A[0].length; k++) {\n    if (k === j) continue\n    A[i][k] = A[i][k] / Aij\n  }\n  A[i][j] = 1 / Aij\n}\n\n/** Find a pivot according to Case 1 (Ferguson p23) */\nfunction findPiv1(A: number[][]) {\n  const r = A.length,\n    c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let j = 0; j < c - 1; j++) {\n    if (A[r - 1][j] >= -zero) continue\n    for (let i = 0; i < r - 1; i++) {\n      if (A[i][j] > zero) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('UNBOUNDED FEASIBLE')\n  }\n  if (minloc.i < 0) throw Error('NO PIVOTS (done)')\n  return { i: minloc.i, j: minloc.j }\n}\n\n/** Find a pivot according to Case 2 (Ferguson p24) */\nfunction findPiv2(A: number[][]) {\n  const r = A.length,\n    c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let i = 0; i < r - 1; i++) {\n    if (A[i][c - 1] >= -zero) continue\n    for (let j = 0; j < c - 1; j++) {\n      if (A[i][j] < -zero) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('INFEASIBLE')\n    return { i: minloc.i, j: minloc.j }\n  }\n  throw Error('NO PIVOTS (done)')\n}\n\n/** Backtracking algorithm to find solution vector */\nfunction backtrack(tableau: number[][], pivotHistory: Pivot[], targ: number) {\n  let side = 1 // 0 left, 1 right\n  pivotHistory.forEach(({ i, j }) => {\n    if (side === 1 && j === targ) {\n      targ = i\n      side = 0\n    } else if (side === 0 && i === targ) {\n      targ = j\n      side = 1\n    }\n  })\n\n  const ncol = tableau[0].length\n  return side === 0 ? tableau[targ][ncol - 1] : 0\n}\n","import type { OptNode } from '../../../Formula/optimization'\nimport { assertUnreachable, cartesian } from '../../../Util/Util'\nimport type { ArtifactsBySlot, DynStat, MinMax } from '../../common'\nimport { computeFullArtRange } from '../../common'\nimport { polyUB } from './polyUB'\nimport { solveLP } from './solveLP'\n\nexport type Linear = DynStat & { $c: number }\n\nfunction weightedSum(\n  ...entries: readonly (readonly [number, Linear])[]\n): Linear {\n  const result = { $c: 0 }\n  for (const [weight, entry] of entries)\n    for (const [k, v] of Object.entries(entry))\n      result[k] = (result[k] ?? 0) + weight * v\n  return result\n}\n\nexport function linearUB(nodes: OptNode[], arts: ArtifactsBySlot): Linear[] {\n  const polys = polyUB(nodes, arts)\n  const minMax = computeFullArtRange(arts)\n\n  return polys.map((poly) =>\n    weightedSum(\n      ...poly.map((mon) => {\n        const bounds = mon.terms.map((key) => minMax[key])\n        const { w, $c } = linbound(bounds, mon.$k >= 0 ? 'upper' : 'lower')\n        const linboi: Linear = { $c }\n        mon.terms.forEach((key, i) => (linboi[key] = w[i] + (linboi[key] ?? 0)))\n        return [mon.$k, linboi] as readonly [number, Linear]\n      })\n    )\n  )\n}\n\n/**\n * Constructs a linear upper/lower bound for a monomial on a bounded domain using an LP.\n *\n * Monomial is assumed to be\n *    m(x) = x1 * x2 * ... * xn\n * on bounded domain\n *    min_1 <= x1 <= max_1\n *    min_2 <= x2 <= max_2\n *    ...\n *    min_n <= xn <= max_n\n *\n * @param bounds List of min & max bounds for each xi\n * @returns A linear function L(x) = w . x + $c\n *            satisfying      m(x) <= L(x) <= m(x) + err (resp. m(x) - err <= L(x) <= m(x))\n */\nfunction linbound(\n  bounds: MinMax[],\n  direction: 'upper' | 'lower' = 'upper'\n): { w: number[]; $c: number; err: number } {\n  if (bounds.length === 0) return { w: [], $c: 1, err: 0 } // vacuous product is 0\n  const nVar = bounds.length\n\n  // Re-scale bounds to [-1, 1] for numerical stability.\n  const boundScale = bounds.map(({ min, max }) => Math.max(-min, max))\n  if (boundScale.some((bnd) => bnd === 0)) {\n    return { w: bounds.map((_) => 0), $c: 0, err: 0 }\n  }\n  const scaleProd = boundScale.reduce((prod, v) => prod * v, 1)\n  bounds = bounds.map(({ min, max }, i) => ({\n    min: min / boundScale[i],\n    max: max / boundScale[i],\n  }))\n  // Setting up the linear program in terms of constraints.\n  //   cartesian(bounds) loops 2^nVar times\n  const cons = cartesian(...bounds.map(({ min, max }) => [min, max])).flatMap(\n    (coords) => {\n      const prod = coords.reduce((prod, v) => prod * v, 1)\n      const sum = coords.reduce((sum, v) => sum + v, 0)\n      switch (direction) {\n        case 'upper':\n          return [\n            [...coords, -1, 0, sum - prod - nVar],\n            [...coords.map((v) => -v), 1, -1, nVar + prod - sum],\n          ]\n        case 'lower':\n          return [\n            [...coords.map((v) => -v), -1, 0, prod - sum - nVar],\n            [...coords, 1, -1, nVar + sum - prod],\n          ]\n        default:\n          assertUnreachable(direction)\n      }\n    }\n  )\n\n  const objective = [...bounds.map((_) => 0), 0, 1]\n  try {\n    const soln = solveLP(objective, cons)\n    switch (direction) {\n      case 'upper':\n        return {\n          w: soln\n            .slice(0, nVar)\n            .map((wi, i) => ((1 - wi) * scaleProd) / boundScale[i]),\n          $c: scaleProd * (soln[nVar] - nVar),\n          err: scaleProd * soln[nVar + 1],\n        }\n      case 'lower':\n        return {\n          w: soln\n            .slice(0, nVar)\n            .map((wi, i) => ((1 - wi) * scaleProd) / boundScale[i]),\n          $c: scaleProd * (nVar - soln[nVar]),\n          err: scaleProd * soln[nVar + 1],\n        }\n      default:\n        assertUnreachable(direction)\n    }\n  } catch (e) {\n    console.log('ERROR on bounds', bounds)\n    console.log('Possibly numerical instability issue.')\n    console.log(e)\n    throw e\n  }\n}\n","import type { ArtifactSetKey } from '@genshin-optimizer/consts'\nimport { allArtifactSlotKeys } from '@genshin-optimizer/consts'\nimport { objKeyMap } from '@genshin-optimizer/util'\nimport { cartesian } from '../../../Util/Util'\nimport {\n  computeFullArtRange,\n  countBuilds,\n  type ArtifactBuildData,\n  type ArtifactsBySlot,\n} from '../../common'\nimport type { Linear } from './linearUB'\n\n/**\n * Heuristically picks splitting key based on minimizing the approximation error.\n *\n * Computing approximation error is difficult, so we use this scuffed guesstimate is:\n *   \\sqrt[ \\sum ((u_i - l_i) * w_i)^2 ]\n */\nexport function pickSplitKey(\n  appxs: Linear[],\n  arts: ArtifactsBySlot\n): { splitOn: string; splitVal: number } {\n  const minMax = computeFullArtRange(arts)\n\n  const allKeys = [\n    ...new Set(\n      appxs.flatMap((appx) => Object.keys(appx).filter((k) => k !== '$c'))\n    ),\n  ]\n\n  const { bestKey } = allKeys.reduce(\n    ({ bestKey, minHeur }, stat) => {\n      const { min, max } = minMax[stat]\n      const oldHeur = appxs.reduce(\n        (h, lin) => h + ((max - min) * (lin[stat] ?? 0)) ** 2,\n        0\n      )\n\n      const { lowerRange, upperRange } = allArtifactSlotKeys.reduce(\n        ({ lowerRange, upperRange }, slot) => {\n          const vals = arts.values[slot].map((art) => art.values[stat])\n          const minv = Math.min(...vals),\n            maxv = Math.max(...vals),\n            mid = (minv + maxv) / 2,\n            glb = Math.max(...vals.filter((v) => v <= mid)),\n            lub = Math.min(...vals.filter((v) => v >= mid))\n          // Heuristic could be improved by tracking lowerRange & upperRange for all stats.\n          return {\n            lowerRange: lowerRange + (glb - minv),\n            upperRange: upperRange + (maxv - lub),\n          }\n        },\n        { lowerRange: 0, upperRange: 0 }\n      )\n      const newHeur =\n        appxs.reduce(\n          (h, lin) =>\n            h +\n            (lowerRange * (lin[stat] ?? 0)) ** 2 +\n            (upperRange * (lin[stat] ?? 0)) ** 2,\n          0\n        ) / 2\n\n      const heur = newHeur - oldHeur\n      if (heur < minHeur) return { bestKey: stat, minHeur: heur }\n      return { bestKey, minHeur }\n    },\n    { bestKey: '', minHeur: Infinity }\n  )\n\n  // Pick key that gives minimum heur (maximum reduction old -> new)\n  return {\n    splitOn: bestKey,\n    splitVal: (minMax[bestKey].min + minMax[bestKey].max) / 2,\n  }\n}\n\n/** Splits a filter based on the set key into 32 chunks. */\nexport function splitOnSet(\n  setKey: ArtifactSetKey,\n  arts: ArtifactsBySlot\n): ArtifactsBySlot[] {\n  return splitArts(arts, (arts) => arts.map((art) => art.set === setKey))\n}\n\n/**\n * Splits `arts` into 32 chunks such that the total `stat` of min split is below `threshold`, and that the max\n * split is above.\n */\nexport function splitAtValue(\n  stat: string,\n  threshold: number,\n  arts: ArtifactsBySlot\n): ArtifactsBySlot[] {\n  threshold -= arts.base[stat]\n  const valsBySlot = allArtifactSlotKeys.map((slot) =>\n    arts.values[slot]\n      .map((art) => ({ art, val: art.values[stat] }))\n      .sort((a, b) => a.val - b.val)\n  )\n  const mins = valsBySlot.map(([first]) => first.val)\n  const ranges = valsBySlot.map(\n    (arts) => arts[arts.length - 1].val - arts[0].val\n  )\n  const totalRange = ranges.reduce((a, b) => a + b)\n  const cutoff =\n    (threshold - mins.reduce((a, b) => a + b)) / Math.max(totalRange, 1e-9)\n  const split = valsBySlot.map((arts, slot) => {\n    const splitVal = mins[slot] + cutoff * ranges[slot]\n    let start = 0,\n      end = arts.length\n    while (start !== end) {\n      const mid = Math.floor((start + end) / 2)\n      if (splitVal > arts[mid].val) start = mid + 1\n      else end = mid\n    }\n    return end\n  })\n\n  return splitArts(arts, (arts, si) => {\n    const upper = new Set(valsBySlot[si].slice(split[si]).map((a) => a.art))\n    return arts.map((art) => upper.has(art))\n  })\n}\n\nfunction splitArts(\n  { base, values }: ArtifactsBySlot,\n  predicate: (arts: ArtifactBuildData[], slotIndex: number) => boolean[]\n): ArtifactsBySlot[] {\n  const partition = allArtifactSlotKeys.map((slot, si) => {\n    const arts = values[slot]\n    const group = predicate(arts, si)\n    return [\n      arts.filter((_, i) => group[i]),\n      arts.filter((_, i) => !group[i]),\n    ].filter((a) => a.length)\n  })\n  return cartesian(...partition)\n    .map((partition) => ({\n      base,\n      values: objKeyMap(allArtifactSlotKeys, (_, i) => partition[i]),\n    }))\n    .sort((a, b) => countBuilds(b) - countBuilds(a))\n}\n","import type { Interim, Setup } from '../..'\nimport { optimize, type OptNode } from '../../../Formula/optimization'\nimport type { ArtifactSetKey, ArtifactSlotKey } from '@genshin-optimizer/consts'\nimport { allArtifactSetKeys } from '@genshin-optimizer/consts'\nimport { objectKeyValueMap, objectMap } from '../../../Util/Util'\nimport type {\n  ArtifactBuildData,\n  ArtifactsBySlot,\n  DynStat,\n  RequestFilter,\n} from '../../common'\nimport { countBuilds, filterArts, pruneAll } from '../../common'\nimport type { SplitWorker } from '../BackgroundWorker'\nimport type { Linear } from './linearUB'\nimport { linearUB } from './linearUB'\nimport { pickSplitKey, splitOnSet, splitAtValue } from './heuristicSplitting'\n\ntype Approximation = {\n  base: number\n  /** optimization target contribution from a given artifact (id) */\n  conts: StrictDict<string, number>\n}\ntype Filter = {\n  nodes: OptNode[]\n  lins: Linear[]\n  arts: ArtifactsBySlot\n  /**\n   * The contribution of each artifact to the optimization target. The (over)estimated\n   * optimization target value is the sum of contributions of all artifacts in the build.\n   */\n  approxs: Approximation[]\n  maxConts: Record<ArtifactSlotKey, number>[]\n  /** Total number of builds in this filter */\n  count: number\n  /** Whether or not this filter is in a valid (calculated) state */\n  calculated?: boolean\n}\nexport class BNBSplitWorker implements SplitWorker {\n  min: number[]\n  nodes: OptNode[]\n  arts: ArtifactsBySlot\n  topN: number\n\n  /**\n   * Filters are not neccessarily in a valid state, i.e., \"calculated\".\n   * We amortize the calculation to 1-per-split so that the calculation\n   * overhead doesn't lead to lag.\n   */\n  filters: Filter[] = []\n  interim: Interim | undefined\n  firstUncalculated = 0\n\n  callback: (interim: Interim) => void\n\n  constructor(\n    { arts, optTarget, constraints, topN }: Setup,\n    callback: (interim: Interim) => void\n  ) {\n    this.arts = arts\n    this.min = [-Infinity, ...constraints.map((x) => x.min)]\n    this.nodes = [optTarget, ...constraints.map((x) => x.value)]\n    this.callback = callback\n    this.topN = topN\n\n    // make sure we can approximate it\n    linearUB(this.nodes, arts)\n  }\n\n  addFilter(filter: RequestFilter): void {\n    const arts = filterArts(this.arts, filter),\n      count = countBuilds(arts)\n    if (count)\n      this.filters.push({\n        nodes: this.nodes,\n        arts,\n        maxConts: [],\n        lins: [],\n        approxs: [],\n        count,\n      })\n  }\n  setThreshold(newThreshold: number): void {\n    if (newThreshold > this.min[0]) {\n      this.min[0] = newThreshold\n      // All calculations become stale\n      this.firstUncalculated = 0\n      this.filters.forEach((filter) => delete filter.calculated)\n    }\n  }\n  *split(filter: RequestFilter, minCount: number): Generator<RequestFilter> {\n    this.addFilter(filter)\n\n    while (this.filters.length) {\n      const filter = this.getApproxFilter(),\n        { arts, count } = filter\n\n      if (count <= minCount || Object.keys(arts.base).length === 0) {\n        if (!count) continue\n        if (this.firstUncalculated < this.filters.length)\n          this.calculateFilter(this.firstUncalculated++) // Amortize the filter calculation to 1-per-split\n\n        this.reportInterim(false)\n        yield objectMap(arts.values, (arts) => ({\n          kind: 'id' as const,\n          ids: new Set(arts.map((art) => art.id)),\n        }))\n      } else this.splitOldFilter(filter)\n    }\n\n    this.reportInterim(true)\n  }\n\n  reportInterim(forced = false) {\n    if (this.interim && (this.interim.skipped > 1000000 || forced === true)) {\n      this.callback(this.interim)\n      this.interim = undefined\n    }\n  }\n\n  splitOldFilter(filter: Filter) {\n    const { nodes, arts, lins } = filter\n    if (countBuilds(arts) === 0) return\n\n    const { splitOn, splitVal } = pickSplitKey(lins, arts)\n    const newFilters = allArtifactSetKeys.includes(splitOn as any)\n      ? splitOnSet(splitOn as ArtifactSetKey, arts)\n      : splitAtValue(splitOn, splitVal, arts)\n\n    for (const arts of newFilters) {\n      const count = countBuilds(arts)\n      this.filters.push({\n        nodes,\n        arts,\n        maxConts: [],\n        lins: [],\n        approxs: [],\n        count,\n      })\n    }\n  }\n\n  /** *Precondition*: `this.filters` must not be empty */\n  getApproxFilter(): Filter {\n    this.calculateFilter(this.filters.length - 1)\n    if (this.firstUncalculated > this.filters.length)\n      this.firstUncalculated = this.filters.length\n    return this.filters.pop()!\n  }\n  /** Update calculate on filter at index `i` if not done so already */\n  calculateFilter(i: number): void {\n    let { nodes, arts, maxConts, lins, approxs } = this.filters[i]\n    const { count: oldCount, calculated } = this.filters[i]\n    if (calculated) return\n    ;({ nodes, arts } = pruneAll(\n      nodes,\n      this.min,\n      arts,\n      this.topN,\n      {},\n      { pruneNodeRange: true }\n    ))\n    nodes = optimize(nodes, {}, (_) => false)\n    if (Object.values(arts.values).every((x) => x.length)) {\n      ;({ lins, approxs } = approximation(nodes, arts))\n      maxConts = approxs.map((approx) =>\n        objectMap(arts.values, (val) => maxContribution(val, approx))\n      )\n    }\n    // Removing artifacts that doesn't meet the required opt target contributions.\n    //\n    // We could actually loop `newValues` computation if the removed artifacts have\n    // the highest contribution in one of the target node as the removal will raise\n    // the required contribution even further. However, once is generally enough.\n    const leadingConts = maxConts.map((cont, i) =>\n      Object.values(cont).reduce(\n        (accu, val) => accu + val,\n        approxs[i].base - this.min[i]\n      )\n    )\n    const newValues = objectMap(arts.values, (arts, slot) => {\n      const requiredConts = leadingConts.map((lc, i) => maxConts[i][slot] - lc)\n      return arts.filter(({ id }) =>\n        approxs.every(({ conts }, i) => conts[id] >= requiredConts[i])\n      )\n    })\n    arts = { base: arts.base, values: newValues }\n    const newCount = countBuilds(arts)\n    if (newCount !== oldCount)\n      if (this.interim) this.interim.skipped += oldCount - newCount\n      else\n        this.interim = {\n          resultType: 'interim',\n          buildValues: undefined,\n          tested: 0,\n          failed: 0,\n          skipped: oldCount - newCount,\n        }\n    this.filters[i] = {\n      nodes,\n      arts,\n      maxConts,\n      lins,\n      approxs,\n      count: newCount,\n      calculated: true,\n    }\n  }\n}\n\nfunction maxContribution(\n  arts: ArtifactBuildData[],\n  approximation: Approximation\n): number {\n  return Math.max(...arts.map(({ id }) => approximation.conts[id]!))\n}\nfunction approximation(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot\n): { lins: Linear[]; approxs: Approximation[] } {\n  const lins = linearUB(nodes, arts)\n  return {\n    lins,\n    approxs: lins.map((weight) => ({\n      base: dot(arts.base, weight, weight.$c),\n      conts: objectKeyValueMap(Object.values(arts.values).flat(), (data) => [\n        data.id,\n        dot(data.values, weight, 0),\n      ]),\n    })),\n  }\n}\nfunction dot(values: DynStat, lin: DynStat, c: number): number {\n  return Object.entries(values).reduce(\n    (accu, [k, v]) => accu + (lin[k] ?? 0) * v,\n    c\n  )\n}\n","import type { Interim, Setup } from '..'\nimport type { OptNode } from '../../Formula/optimization'\nimport { optimize, precompute } from '../../Formula/optimization'\nimport type {\n  ArtifactBuildData,\n  ArtifactsBySlot,\n  Build,\n  PlotData,\n  RequestFilter,\n} from '../common'\nimport { countBuilds, filterArts, mergePlot, pruneAll } from '../common'\n\nexport class ComputeWorker {\n  builds: Build[] = []\n  buildValues: number[] | undefined = undefined\n  plotData: PlotData | undefined\n  threshold = -Infinity\n  topN: number\n  min: number[]\n\n  arts: ArtifactsBySlot\n  nodes: OptNode[]\n\n  callback: (interim: Interim) => void\n\n  constructor(\n    { arts, optTarget, constraints, plotBase, topN }: Setup,\n    callback: (interim: Interim) => void\n  ) {\n    this.arts = arts\n    this.min = constraints.map((x) => x.min)\n    this.topN = topN\n    this.callback = callback\n    this.nodes = constraints.map((x) => x.value)\n    this.nodes.push(optTarget)\n    if (plotBase) {\n      this.plotData = {}\n      this.nodes.push(plotBase)\n    }\n    this.nodes = optimize(this.nodes, {}, (_) => false)\n  }\n\n  setThreshold(newThreshold: number) {\n    if (this.threshold > newThreshold) this.threshold = newThreshold\n  }\n  compute(filter: RequestFilter) {\n    const { min } = this\n    let preArts = filterArts(this.arts, filter)\n    const totalCount = countBuilds(preArts),\n      oldMaxBuildCount = this.builds.length\n\n    let nodes = this.nodes\n    ;({ nodes, arts: preArts } = pruneAll(\n      nodes,\n      min,\n      preArts,\n      this.topN,\n      {},\n      {\n        pruneArtRange: true,\n        pruneNodeRange: true,\n      }\n    ))\n    const arts = Object.values(preArts.values).sort(\n      (a, b) => a.length - b.length\n    )\n    const compute = precompute(\n      nodes,\n      preArts.base,\n      (f) => f.path[1],\n      arts.length\n    )\n\n    const buffer = Array<ArtifactBuildData>(arts.length)\n    const count = {\n      tested: 0,\n      failed: 0,\n      skipped: totalCount - countBuilds(preArts),\n    }\n\n    const permute = (i: number) => {\n      if (i < 0) {\n        const result = compute(buffer)\n        if (min.every((m, i) => m <= result[i])) {\n          const value = result[min.length],\n            { builds, plotData } = this\n          let build: Build | undefined\n          if (value >= this.threshold) {\n            build = {\n              value,\n              artifactIds: buffer.map((x) => x.id).filter((id) => id),\n            }\n            builds.push(build)\n          }\n          if (plotData) {\n            const x = result[min.length + 1]\n            if (!plotData[x] || plotData[x]!.value < value) {\n              if (!build)\n                build = {\n                  value,\n                  artifactIds: buffer.map((x) => x.id).filter((id) => id),\n                }\n              build.plot = x\n              plotData[x] = build\n            }\n          }\n        } else count.failed += 1\n        return\n      }\n      arts[i].forEach((art) => {\n        buffer[i] = art\n        permute(i - 1)\n      })\n      if (i === 0) {\n        count.tested += arts[0].length\n        if (count.tested > 1 << 16) this.interimReport(count)\n      }\n    }\n\n    permute(arts.length - 1)\n    this.interimReport(count, this.builds.length > oldMaxBuildCount)\n  }\n\n  refresh(force: boolean): void {\n    const { topN } = this\n    if (Object.keys(this.plotData ?? {}).length >= 100000)\n      this.plotData = mergePlot([this.plotData!])\n\n    if (this.builds.length >= 1000 || force) {\n      this.builds = this.builds.sort((a, b) => b.value - a.value).slice(0, topN)\n      this.buildValues = this.builds.map((x) => x.value)\n      this.threshold = Math.max(\n        this.threshold,\n        this.buildValues[topN - 1] ?? -Infinity\n      )\n    }\n  }\n  interimReport(\n    count: { tested: number; failed: number; skipped: number },\n    forced = false\n  ) {\n    this.refresh(forced)\n    this.callback({\n      resultType: 'interim',\n      buildValues: this.buildValues,\n      ...count,\n    })\n    this.buildValues = undefined\n    count.tested = 0\n    count.failed = 0\n    count.skipped = 0\n  }\n}\n","import { allArtifactSlotKeys } from '@genshin-optimizer/consts'\nimport type { Interim, Setup } from '..'\nimport { assertUnreachable } from '../../Util/Util'\nimport type { ArtifactsBySlot, RequestFilter } from '../common'\nimport { countBuilds, filterArts } from '../common'\nimport type { SplitWorker } from './BackgroundWorker'\n\nexport class DefaultSplitWorker implements SplitWorker {\n  arts: ArtifactsBySlot\n  stack: { filter: RequestFilter; count: number; splittedBy: 'id' | 'set' }[] =\n    []\n\n  constructor({ arts }: Setup, _callback: (interim: Interim) => void) {\n    this.arts = arts\n  }\n\n  setThreshold(_newThreshold: number): void {}\n  add(\n    filter: RequestFilter,\n    splittedBy: (typeof this.stack)[number]['splittedBy']\n  ) {\n    this.stack.push({\n      filter,\n      count: countBuilds(filterArts(this.arts, filter)),\n      splittedBy,\n    })\n  }\n  *split(filter: RequestFilter, minCount: number): Generator<RequestFilter> {\n    this.add(filter, 'set')\n    for (let current = this.stack.pop(); current; current = this.stack.pop()) {\n      const { filter, count, splittedBy } = current\n      if (count <= minCount) {\n        yield filter\n        continue\n      }\n\n      switch (splittedBy) {\n        case 'set':\n          this.splitBySet(filter)\n          break\n        case 'id':\n          this.splitByID(filter, count, minCount)\n          break\n        default:\n          assertUnreachable(splittedBy)\n      }\n    }\n  }\n\n  splitBySet(filter: RequestFilter): void {\n    const arts = filterArts(this.arts, filter)\n    const candidates = allArtifactSlotKeys\n      .map((slot) => ({\n        slot,\n        sets: new Set(arts.values[slot].map((x) => x.set)),\n      }))\n      .filter(({ sets }) => sets.size > 1)\n\n    if (!candidates.length) return this.add(filter, 'id')\n\n    const { sets, slot } = candidates.reduce((a, b) =>\n      a.sets.size < b.sets.size ? a : b\n    )\n    sets.forEach((set) =>\n      this.add(\n        { ...filter, [slot]: { kind: 'required', sets: new Set([set]) } },\n        'set'\n      )\n    )\n  }\n  splitByID(filter: RequestFilter, count: number, minCount: number): void {\n    const arts = filterArts(this.arts, filter)\n    const { slot, length } = allArtifactSlotKeys\n      .map((slot) => ({ slot, length: arts.values[slot].length }))\n      .filter((x) => x.length > 1)\n      // We always have entries because `count > 1`\n      .reduce((a, b) => (a.length < b.length ? a : b))\n\n    const numChunks = Math.ceil(count / minCount)\n    const boundedNumChunks = Math.min(numChunks, length)\n    const chunk = Array(boundedNumChunks)\n      .fill(0)\n      .map((_) => new Set<string>())\n    arts.values[slot].forEach(({ id }, i) =>\n      chunk[i % boundedNumChunks].add(id)\n    )\n    chunk.forEach((ids) =>\n      this.add({ ...filter, [slot]: { kind: 'id', ids } }, 'id')\n    )\n  }\n}\n","import type { WorkerCommand, WorkerResult } from '..'\nimport { assertUnreachable } from '../../Util/Util'\nimport type { RequestFilter } from '../common'\nimport {\n  artSetPerm,\n  countBuilds,\n  filterArts,\n  filterFeasiblePerm,\n} from '../common'\nimport { BNBSplitWorker } from './BNBSplitWorker'\nimport { ComputeWorker } from './ComputeWorker'\nimport { DefaultSplitWorker } from './DefaultSplitWorker'\n\ndeclare function postMessage(command: WorkerCommand | WorkerResult): void\n\nlet splitWorker: SplitWorker, computeWorker: ComputeWorker\n\nasync function handleEvent(e: MessageEvent<WorkerCommand>): Promise<void> {\n  const { data } = e,\n    { command } = data\n  switch (command) {\n    case 'split':\n      for (const filter of splitWorker.split(\n        data.filter,\n        data.maxIterateSize\n      )) {\n        postMessage({ command: 'iterate', filter })\n        // Suspend here in case a `threshold` is sent over\n        //\n        // Make sure to use task-based mechanisms such as `setTimeout` so that\n        // this function suspends until the next event loop. If we instead use\n        // microtask-based ones such as `Promise.resolved`, the suspension will\n        // not be long enough.\n        await new Promise((r) => setTimeout(r))\n      }\n      break\n    case 'iterate':\n      computeWorker.compute(data.filter)\n      break\n    case 'threshold': {\n      splitWorker.setThreshold(data.threshold)\n      computeWorker.setThreshold(data.threshold)\n      return // This is a fire-and-forget command\n    }\n    case 'finalize': {\n      computeWorker.refresh(true)\n      const { builds, plotData } = computeWorker\n      postMessage({ resultType: 'finalize', builds, plotData })\n      break\n    }\n    case 'count': {\n      const { exclusion, maxIterateSize } = data,\n        arts = computeWorker.arts\n      const perms = filterFeasiblePerm(\n        artSetPerm(exclusion, [\n          ...new Set(\n            Object.values(arts.values).flatMap((x) => x.map((x) => x.set!))\n          ),\n        ]),\n        arts\n      )\n      let count = 0\n      for (const filter of perms) {\n        postMessage({ command: 'split', filter, maxIterateSize })\n        count += countBuilds(filterArts(arts, filter))\n      }\n      postMessage({ resultType: 'count', count })\n      break\n    }\n    case 'setup':\n      try {\n        splitWorker = new BNBSplitWorker(data, (x) => postMessage(x))\n      } catch {\n        splitWorker = new DefaultSplitWorker(data, (x) => postMessage(x))\n      }\n      computeWorker = new ComputeWorker(data, (x) => postMessage(x))\n      break\n    default:\n      assertUnreachable(command)\n  }\n  postMessage({ resultType: 'done' })\n}\nonmessage = async (e: MessageEvent<WorkerCommand>) => {\n  try {\n    await handleEvent(e)\n  } catch (e) {\n    postMessage({ resultType: 'err', message: (e as any).message })\n  }\n}\n\nexport interface SplitWorker {\n  split(filter: RequestFilter, minCount: number): Iterable<RequestFilter>\n  setThreshold(newThreshold: number): void\n}\n"],"names":["objPathValue","obj","keys","Array","isArray","console","error","reduce","a","k","objectKeyValueMap","items","map","Object","fromEntries","t","i","objectMap","fn","entries","v","assertUnreachable","value","Error","cartesian","q","b","flatMap","d","e","flat","nonTravelerCharacterKeys","allTravelerKeys","allArtifactSetKeys","allArtifactSlotKeys","objMap","f","objKeyMap","rangeGen","from","to","range","constant","NaN","name","percent","info","operation","operands","type","Number","MAX_VALUE","Infinity","unit","sum","values","intoOps","dynRead","accu","path","intoV","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","forEach","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","arrayEqual","set","result","customMapFormula","context","contextMapping","internalMap","current","mapping","old","newFormula","undefined","length","every","allCommutativeMonoidOperations","min","x","Math","max","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","optimize","topLevelData","shouldFold","_formula","opts","constantFold","flatten","deduplicate","flattened","dep","arrayCompare","cmp","cc","nodeHeightMap","layers","cmpNode","n1","n2","h1","h2","op1","op2","localeCompare","s1","s2","op","nodeSortMap","sort","_","n","push","h","ix","sortedNodes","layer","origin","data","processed","nextContextMap","fold","c","foldStr","numericOperands","formulaOperands","filter","folded","numericValue","isFinite","index","selected","table","first","find","smallest","operand","v1","v2","match","unmatch","list","reset","nextMap","nextContext","pruneAll","nodes","minimum","arts","numTop","exclusion","forced","should","deps","pruneNodeRange","reaffine","pruneOrder","pruneArtRange","count","some","newArts","newNodes","forceRename","affineNodes","topLevelAffine","visit","node","isAffine","dynKeys","affineOps","nonAffineOps","affine","nonConst","base","size","nextDynKey","affineMap","reaffineArt","stat","dyn","slot","id","offsets","key","baseValue","progress","allowRainbow","rainbow","noSwitchIn","noSwitchOut","includes","newList","art","other","otherBetterEqual","otherMaybeBetter","otherBetter","canSwitch","baseRange","wrap","artRanges","computeArtRange","otherArtRanges","addArtRange","read","newRange","computeNodeRange","nodeRange","operandRanges","newOperands","ranges","computeFullArtRange","reads","computeMinMax","minMaxes","filterArts","filters","kind","ids","sets","countBuilds","_count","exclusionToAllowed","artSetPerm","_artSets","artSets","allowedRainbows","shapes","indexOfShape","shape","replacing","populateShapes","rainbows","j","required","slice","remaining","noFilter","counts","allowedCounts","used","groupped","usableRainbows","check_free","isolated","missing","rejected","allowedSet","requiredRainbows","l","constP","lin","$c","sumP","terms","poly","prodP","minMax","min1","max1","min2","max2","$k","slopePoint","slope","x0","y0","interpolate","x1","y1","upper","abs","polyUB","statMinMax","nodeRanges","lower","exact","_map","oppositeContext","minmax","minf","maxf","zeroCrossing","signf","polys","ctx","p","PolyError","xs","xOp","cOp","loc","sqrt","vOp","tOp","pOp","fOp","threshOp","ge","le","mulOp","prod","thresh","isFirstHalf","toExpandedPoly","constM","weightedReadM","monomials","sumM","monos","ret","nxt","prodM","mon","m","termsA","termsB","splice","ai","foldLikeTerms","expandPoly","constructor","cause","super","zero","solveLP","Ab","rows","cols","tableau","fill","Ai","Aij","cj","pivotHistory","piv","findPiv2","pivotInplace","findPiv1","xOpt","targ","side","ncol","backtrack","row","tot","xi","isFeasible","A","r","minloc","linearUB","weight","entry","weightedSum","bounds","w","direction","err","nVar","boundScale","bnd","scaleProd","cons","coords","objective","soln","wi","log","linbound","linboi","splitArts","predicate","si","group","partition","BNBSplitWorker","optTarget","constraints","topN","callback","interim","firstUncalculated","this","addFilter","maxConts","lins","approxs","setThreshold","newThreshold","calculated","minCount","getApproxFilter","calculateFilter","reportInterim","splitOldFilter","skipped","splitOn","splitVal","appxs","allKeys","appx","bestKey","minHeur","oldHeur","lowerRange","upperRange","vals","minv","maxv","mid","heur","pickSplitKey","newFilters","setKey","splitOnSet","valsBySlot","val","mins","totalRange","cutoff","split","start","end","floor","splitAtValue","pop","oldCount","dot","conts","approximation","approx","maxContribution","leadingConts","cont","newValues","requiredConts","lc","newCount","resultType","buildValues","tested","failed","ComputeWorker","plotBase","builds","plotData","compute","preArts","totalCount","oldMaxBuildCount","initial","binding","slotCount","body","names","operandNames","arr","toString","join","Function","precompute","buffer","permute","build","artifactIds","plot","interimReport","refresh","force","plots","scale","round","mergePlot","DefaultSplitWorker","_callback","stack","_newThreshold","splittedBy","splitBySet","splitByID","candidates","numChunks","ceil","boundedNumChunks","chunk","splitWorker","computeWorker","async","handleEvent","command","maxIterateSize","postMessage","Promise","setTimeout","perms","filter_loop","available","s","filterFeasiblePerm","onmessage","message"],"sourceRoot":""}