{"version":3,"file":"156.9392d67e56d4812e.js","mappings":"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AQxF,IAAIX,EAAQ0E,MACjC0B,IACHA,EAAc,CACZ1B,KAAM,IAAI1D,EAAQ0D,KAAM1E,EAAQ0E,MAChCC,UAAW,IAAInE,KAEjBoE,EAAe/D,IAAIuF,EAAa,IAAI5F,KACpC2F,EAAQtF,IAAIb,EAAQ0E,KAAM0B,IAE5BtF,EAASnE,EAAIqD,EAAQtB,SAAS,GAAI0H,GAClC,KACF,CACA,QACE1I,EAAkBe,GAOtB,OAJIqC,EAAOtC,OACTsC,EAAS,OAAH,UAAQA,UACPA,EAAOtC,MAETsC,CAAM,GAGnB,CAEO,MCndMuF,EAA2B,CACtC,SACA,YACA,OACA,QACA,cACA,UACA,SACA,UACA,UACA,WACA,SACA,OACA,QACA,QACA,QACA,OACA,OACA,UACA,SACA,QACA,QACA,QACA,OACA,kBACA,QACA,gBACA,gBACA,SACA,OACA,YACA,cACA,QACA,OACA,OACA,OACA,SACA,QACA,YACA,SACA,OACA,eACA,QACA,UACA,oBACA,OACA,SACA,kBACA,SACA,UACA,YACA,QACA,WACA,QACA,WACA,YACA,OACA,UACA,SACA,UACA,SACA,SACA,QACA,UACA,SACA,WAGWC,EAAkB,CAC7B,gBACA,cACA,kBACA,kBChHK,MAiDMC,EAAsB,CACjC,SACA,QACA,QACA,SACA,WC7CWC,EAAqB,CAChC,kBACA,gBACA,sBACA,kBACA,YACA,oBACA,gBACA,YACA,gBACA,kBACA,cACA,eACA,oBACA,kBACA,YACA,iBACA,wBACA,YACA,uBACA,uBACA,mBACA,iBACA,mBACA,eACA,cACA,gBACA,eACA,eACA,oBACA,gBACA,gBACA,WACA,kBACA,sBACA,mBAIWC,EAAwB,CACnC,YACA,qBACA,oBACA,yBACA,aACA,qBACA,gBACA,gBACA,wBACA,cACA,mBACA,eACA,qBACA,cACA,mBACA,cACA,uBACA,kBACA,wBACA,eACA,qBACA,eACA,uBACA,oBACA,UACA,cACA,mBACA,aACA,sBACA,mBAIWC,EAAuB,CAClC,qBACA,iBACA,cACA,kBACA,eACA,aACA,cACA,mBACA,qBACA,gBACA,UACA,YACA,mBACA,cACA,mBACA,cACA,4BACA,uBACA,aACA,eACA,cACA,yBACA,WACA,mBACA,kBACA,eAIWC,EAAmB,CAC9B,cACA,UACA,gBACA,mBACA,cACA,iBACA,eACA,iBACA,iBACA,WACA,aACA,cACA,cACA,YACA,oBACA,aACA,YACA,WACA,oBACA,WACA,aACA,WACA,OACA,iBACA,qBACA,oBACA,cACA,YACA,gBACA,qBACA,kBACA,gBAIWC,EAAwB,CACnC,mBACA,0BACA,kBACA,cACA,aACA,sBACA,kBACA,gBACA,cACA,qBACA,eACA,gBACA,6BACA,aACA,YACA,eACA,eACA,oBACA,iBACA,iBACA,kBACA,gBACA,uBACA,eACA,aACA,aACA,gCACA,0BACA,eACA,oBACA,eC3JWC,EAAc,CACzB,SACA,QACA,QACA,SACA,WA0EWC,EAAe,CAC1B,gBACA,cACA,kBACA,kBC9FK,SAASC,EACdC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIC,EAASD,EAEb,MAAME,EACQ,CAAEC,gBAAgB,GAD1BD,EAEW,CAAEC,gBAAgB,GAF7BD,EAGY,CAAEE,UAAU,GAHxBF,EAIM,CAAEG,YAAY,EAAMC,eAAe,EAAMH,gBAAgB,GAErE,IAAII,EAAQ,EACZ,KAAOhL,OAAOqC,OAAOqI,GAAQO,MAAMjG,GAAMA,KAAMgG,IAAU,IAAI,CAC3D,GAAIN,EAAOI,WAAY,QACdJ,EAAOI,WACd,MAAMI,EAAUJ,EAAWR,EAAMC,EAAQC,GACrCF,IAASY,IACXZ,EAAOY,EACPR,EAAS,OAAH,UAAQA,EAAWC,GAE7B,CACA,GAAID,EAAOK,cAAe,QACjBL,EAAOK,cACd,MAAMG,EAAUH,EAAcX,EAAOE,EAAMD,GACvCC,IAASY,IACXZ,EAAOY,EACPR,EAAS,OAAH,UAAQA,EAAWC,GAE7B,CACA,GAAID,EAAOE,eAAgB,QAClBF,EAAOE,eACd,MAAMO,EAAWP,EAAeR,EAAOE,GACnCF,IAAUe,IACZf,EAAQe,EACRT,EAAS,OAAH,UAAQA,EAAWC,GAE7B,CACA,GAAID,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","sources":["webpack:///./src/app/Util/Util.ts","webpack:///./src/app/Formula/utils.ts","webpack:///./src/app/Formula/internal.ts","webpack:///./src/app/Formula/optimization.ts","webpack:///../../libs/consts/src/character.ts","webpack:///../../libs/consts/src/artifact.ts","webpack:///../../libs/consts/src/weapon.ts","webpack:///./src/app/Types/consts.ts","webpack:///./src/app/Solver/common.ts","webpack:///./src/app/Solver/GOSolver/polyUB.ts","webpack:///./src/app/Solver/GOSolver/solveLP.ts","webpack:///./src/app/Solver/GOSolver/linearUB.ts","webpack:///./src/app/Solver/GOSolver/BNBSplitWorker.ts","webpack:///./src/app/Solver/GOSolver/ComputeWorker.ts","webpack:///./src/app/Solver/GOSolver/DefaultSplitWorker.ts","webpack:///./src/app/Solver/GOSolver/BackgroundWorker.ts"],"sourcesContent":["export const getRandomElementFromArray = <T>(array: readonly T[]): T =>\n  array[Math.floor(Math.random() * array.length)]\nexport function getRandomInt(min, max) {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  return Math.floor(Math.random() * (max - min) + min) //The maximum is exclusive and the minimum is inclusive\n}\nexport function getRandomIntInclusive(min, max) {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  return Math.floor(Math.random() * (max - min + 1) + min) //The maximum is inclusive and the minimum is inclusive\n}\nexport function getRandomArbitrary(min, max) {\n  return Math.random() * (max - min) + min\n}\n\n/**\n * Assumes that the object entries are all primitives + objects\n * shallow copy the object,\n * deep copy the\n * @param obj\n * @returns\n */\nexport function deepClone<T>(obj: T): T {\n  if (!obj) return obj\n  if (!Object.keys(obj).length) return {} as T\n  const ret = { ...obj }\n  Object.entries(obj).forEach(([k, v]: any) => {\n    if (typeof v !== 'object') return\n    ret[k] = JSON.parse(JSON.stringify(v))\n  })\n  return ret\n}\n\nexport const clamp = (val, low, high) => {\n  if (val < low) return low\n  if (val > high) return high\n  return val\n}\nexport const getArrLastElement = (arr) =>\n  arr.length ? arr[arr.length - 1] : null\n\nexport const clamp01 = (val) => clamp(val, 0, 1)\nexport const clampPercent = (val) => clamp(val, 0, 100)\n\n//use to pretty print timestamps, or anything really.\nexport function strPadLeft(string, pad, length) {\n  return (new Array(length + 1).join(pad) + string).slice(-length)\n}\n\n//fuzzy compare strings. longer the distance, the higher the mismatch.\nexport function hammingDistance(str1, str2) {\n  let dist = 0\n  str1 = str1.toLowerCase()\n  str2 = str2.toLowerCase()\n  for (let i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\n    let match = true\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i]) match = false\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i]) match = true\n    if (!match) dist++\n  }\n  return dist\n}\n\n//multiplies every numerical value in the obj by a multiplier.\nexport function objMultiplication(obj, multi) {\n  if (multi === 1) return obj\n  Object.keys(obj).forEach((prop: any) => {\n    if (typeof obj[prop] === 'object') objMultiplication(obj[prop], multi)\n    if (typeof obj[prop] === 'number') obj[prop] = obj[prop] * multi\n  })\n  return obj\n}\n\n//assign obj.[keys...] = value\nexport function layeredAssignment(obj, keys: readonly string[], value) {\n  keys.reduce((accu, key, i, arr) => {\n    if (i === arr.length - 1) return (accu[key] = value)\n    if (!accu[key]) accu[key] = {}\n    return accu[key]\n  }, obj)\n  return obj\n}\n//get the value in a nested object, giving array of path\nexport function objPathValue(\n  obj: object | undefined,\n  keys: readonly string[]\n): any {\n  if (!obj || !keys) return undefined\n  !Array.isArray(keys) && console.error(keys)\n  return keys.reduce((a, k) => a?.[k], obj)\n}\n//delete the value denoted by the path. Will also delete empty objects as well.\nexport function deletePropPath(obj, path) {\n  const tempPath = [...path]\n  const lastKey = tempPath.pop()\n  const objPathed = objPathValue(obj, tempPath)\n  delete objPathed?.[lastKey]\n}\n\nexport function objClearEmpties(o) {\n  for (const k in o) {\n    if (typeof o[k] !== 'object') continue\n    objClearEmpties(o[k])\n    if (!Object.keys(o[k]).length) delete o[k]\n  }\n}\nexport function crawlObject(\n  obj: any,\n  keys: string[] = [],\n  validate: (o: any, keys: string[]) => boolean,\n  cb: (o: any, keys: string[]) => void\n) {\n  if (validate(obj, keys)) cb(obj, keys)\n  else\n    obj &&\n      typeof obj === 'object' &&\n      Object.entries(obj).forEach(([key, val]) =>\n        crawlObject(val, [...keys, key], validate, cb)\n      )\n}\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\nexport const getObjectKeysRecursive = (obj) =>\n  typeof obj === 'object'\n    ? Object.values(obj)\n        .flatMap(getObjectKeysRecursive)\n        .concat(Object.keys(obj))\n    : typeof obj === 'string'\n    ? [obj]\n    : []\n\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\n  return typeof value === 'function' ? (value as any)(arg) : value\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyMap<K extends string | number, V>(\n  keys: readonly K[],\n  map: (key: K, i: number) => V\n): StrictDict<`${K}`, V> {\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyValueMap<T, K extends string | number, V>(\n  items: readonly T[],\n  map: (item: T, i: number) => [K, V]\n): StrictDict<`${K}`, V> {\n  return Object.fromEntries(items.map((t, i) => map(t, i))) as any\n}\n\nexport function objectMap<K extends string, V, T>(\n  obj: Record<K, Exclude<V, undefined>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Record<K, T>\nexport function objectMap<K extends string, V, T>(\n  obj: Partial<Record<K, V>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Partial<Record<K, T>>\nexport function objectMap<K extends string, V, T>(\n  obj: Partial<Record<K, V>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Partial<Record<K, T>> {\n  return Object.fromEntries(\n    Object.entries(obj).map(([k, v], i) => [k, fn(v, k, i)])\n  ) as any\n}\n\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\n  for (let i = from; i <= to; i++) yield i\n}\n\n/** range of [from, to], inclusive */\nexport function range(from: number, to: number): number[] {\n  return [...rangeGen(from, to)]\n}\n\nexport function assertUnreachable(value: never): never {\n  throw new Error(`Should not reach this with value ${value}`)\n}\n\n// cartesian product of list of arrays\nexport function cartesian<T>(...q: T[][]): T[][] {\n  return q.reduce((a, b) => a.flatMap((d) => b.map((e) => [d, [e]].flat())), [\n    [],\n  ] as T[][])\n}\n\n/** Will change `arr` in-place */\nexport function toggleInArr<T>(arr: T[], value: T) {\n  const ind = arr.indexOf(value)\n  if (ind < 0) arr.push(value)\n  else arr.splice(ind, 1)\n  return arr\n}\n\nexport function toggleArr<T>(arr: T[], value: T) {\n  return arr.includes(value) ? arr.filter((a) => a !== value) : [...arr, value]\n}\n\nexport function deepFreeze<T>(obj: T, layers = 5): T {\n  if (layers === 0) return obj\n  if (typeof obj === 'object')\n    Object.values(Object.freeze(obj)).forEach((o) => deepFreeze(o, layers--))\n  return obj\n}\n\nexport function arrayMove<T>(arr: T[], oldIndex: number, newIndex: number) {\n  if (newIndex < 0 || newIndex >= arr.length) return arr\n  if (oldIndex < 0 || oldIndex >= arr.length) return arr\n  arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0])\n  return arr\n}\n","import { objectKeyMap } from '../Util/Util'\nimport type { OptNode } from './optimization'\nimport type {\n  ComputeNode,\n  ConstantNode,\n  Data,\n  DataNode,\n  Info,\n  LookupNode,\n  MatchNode,\n  NumNode,\n  ReadNode,\n  StrNode,\n  StrPrioNode,\n  SubscriptNode,\n  ThresholdNode,\n} from './type'\n\ntype Opt = number | OptNode\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype N_S = Num | Str\ntype AnyNode = NumNode | StrNode\n\nexport const todo: OptNode = constant(NaN, { name: 'TODO' })\nexport const one = percent(1),\n  naught = percent(0)\nexport const none = constant('none')\n\nexport function constant(value: number, info?: Info): ConstantNode<number>\nexport function constant(\n  value: string | undefined,\n  info?: Info\n): ConstantNode<string | undefined>\nexport function constant(\n  value: number | string | undefined,\n  info?: Info\n): ConstantNode<number> | ConstantNode<string | undefined>\nexport function constant(\n  value: number | string | undefined,\n  info?: Info\n): ConstantNode<number | string | undefined> {\n  return typeof value === 'number'\n    ? { operation: 'const', operands: [], type: 'number', value, info }\n    : { operation: 'const', operands: [], type: 'string', value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): ConstantNode<number> {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { unit: '%', ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: OptNode, info: Info): OptNode\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: AnyNode, info: Info): AnyNode\nexport function infoMut(node: AnyNode, info: Info): AnyNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, NumNode>,\n  defaultV: Num | 'none',\n  info?: Info\n): LookupNode<NumNode>\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, StrNode>,\n  defaultV: Str | 'none',\n  info?: Info\n): LookupNode<StrNode>\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, AnyNode>,\n  defaultV: N_S | 'none',\n  info?: Info\n): LookupNode<AnyNode> {\n  return {\n    operation: 'lookup',\n    operands:\n      defaultV !== 'none' ? [intoV(index), intoV(defaultV)] : [intoV(index)],\n    table,\n    info,\n  }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function min(...values: Num[]): ComputeNode\nexport function min(...values: Num[]): ComputeNode {\n  return { operation: 'min', operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function max(...values: Num[]): ComputeNode\nexport function max(...values: Num[]): ComputeNode {\n  return { operation: 'max', operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function sum(...values: Num[]): ComputeNode\nexport function sum(...values: Num[]): ComputeNode {\n  return { operation: 'add', operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function prod(...values: Num[]): ComputeNode\nexport function prod(...values: Num[]): ComputeNode {\n  return { operation: 'mul', operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Opt, c: Opt): ComputeNode<OptNode, OptNode>\nexport function frac(x: Num, c: Num): ComputeNode\nexport function frac(x: Num, c: Num): ComputeNode {\n  return { operation: 'sum_frac', operands: intoOps([x, c]) }\n}\nexport function res(base: Opt): ComputeNode<OptNode, OptNode>\nexport function res(base: Num): ComputeNode\nexport function res(base: Num): ComputeNode {\n  return { operation: 'res', operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? eq : neq */\nexport function compareEq(\n  v1: Num,\n  v2: Num,\n  eq: Num,\n  neq: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function compareEq(\n  v1: Num,\n  v2: Num,\n  eq: Str,\n  neq: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function compareEq(\n  v1: Str,\n  v2: Str,\n  eq: Num,\n  neq: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function compareEq(\n  v1: Str,\n  v2: Str,\n  eq: Str,\n  neq: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function compareEq(\n  v1: N_S,\n  v2: N_S,\n  eq: N_S,\n  neq: N_S,\n  info?: Info\n): MatchNode<AnyNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(eq), intoV(neq)],\n    info,\n  }\n}\n/** v1 == v2 ? pass : 0 */\nexport function equal(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function equal(\n  v1: Str,\n  v2: Str,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function equal(\n  v1: N_S,\n  v2: N_S,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(0)],\n    emptyOn: 'unmatch',\n  }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function equalStr(\n  v1: Str,\n  v2: Str,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function equalStr(\n  v1: N_S,\n  v2: N_S,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(undefined)],\n    emptyOn: 'unmatch',\n  }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function unequal(\n  v1: Str,\n  v2: Str,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function unequal(\n  v1: N_S,\n  v2: N_S,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(0), intoVInfo(pass, info)],\n    emptyOn: 'match',\n  }\n}\n/** v1 != v2 ? pass : `undefined` */\nexport function unequalStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function unequalStr(\n  v1: Str,\n  v2: Str,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function unequalStr(\n  v1: N_S,\n  v2: N_S,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(undefined), intoVInfo(pass, info)],\n    emptyOn: 'match',\n  }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(\n  v1: Opt,\n  v2: Opt,\n  pass: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function greaterEq(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function greaterEq(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(0)],\n    emptyOn: 'l',\n  }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): ThresholdNode<StrNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(undefined)],\n    emptyOn: 'l',\n  }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(\n  v1: Opt,\n  v2: Opt,\n  pass: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function lessThan(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function lessThan(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoV(0), intoVInfo(pass, info)],\n    emptyOn: 'ge',\n  }\n}\n/** v1 >= v2 ? ge : le */\nexport function threshold(\n  v1: Opt,\n  v2: Opt,\n  ge: Opt,\n  le: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function threshold(\n  v1: Num,\n  v2: Num,\n  ge: Num,\n  le: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function threshold(\n  v1: Num,\n  v2: Num,\n  ge: Num,\n  le: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoV(ge), intoV(le)],\n    info,\n  }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(\n  nodeList: T,\n  prefix: string[] = []\n): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== 'read')\n      throw new Error(\n        `Found ${(nodeList as any).operation} node while making reader`\n      )\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), (key) =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])\n    ) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(\n  base: AnyNode,\n  data: Data\n): DataNode<NumNode> | DataNode<StrNode>\nexport function data(\n  base: AnyNode,\n  data: Data\n): DataNode<NumNode> | DataNode<StrNode> {\n  return { operation: 'data', operands: [base as any], data }\n}\nexport function resetData(\n  base: NumNode,\n  data: Data,\n  info?: Info\n): DataNode<NumNode>\nexport function resetData(\n  base: StrNode,\n  data: Data,\n  info?: Info\n): DataNode<StrNode>\nexport function resetData(\n  base: AnyNode,\n  data: Data,\n  info?: Info\n): DataNode<AnyNode>\nexport function resetData(\n  base: AnyNode,\n  data: Data,\n  info?: Info\n): DataNode<AnyNode> {\n  return { operation: 'data', operands: [base], data, reset: true, info }\n}\n\nexport function dynRead(\n  name: string,\n  accu: ReadNode<number>['accu'] = 'add',\n  info?: Info\n): ReadNode<number> {\n  return {\n    operation: 'read',\n    operands: [],\n    path: ['dyn', name],\n    accu,\n    type: 'number',\n    info,\n  }\n}\nexport function customRead(\n  path: readonly string[],\n  info?: Info\n): ReadNode<number> {\n  return { operation: 'read', operands: [], path, info, type: 'number' }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: 'read', operands: [], path, type: 'string' }\n}\nexport function read(\n  accu?: ReadNode<number>['accu'],\n  info?: Info\n): ReadNode<number> {\n  return {\n    operation: 'read',\n    operands: [],\n    path: [],\n    accu,\n    info,\n    type: 'number',\n  }\n}\n/**\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\n */\nexport function stringRead(\n  accu?: ReadNode<string | undefined>['accu']\n): ReadNode<string | undefined> {\n  return { operation: 'read', operands: [], path: [], accu, type: 'string' }\n}\nexport function stringPrio(...operands: Str[]): StrPrioNode {\n  return { operation: 'prio', operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(\n  index: NumNode,\n  list: V[],\n  info?: Info\n): SubscriptNode<V> {\n  return { operation: 'subscript', operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: N_S[]): AnyNode[] {\n  return values.map((value) =>\n    typeof value === 'object' ? value : constant(value)\n  )\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: N_S): AnyNode\nfunction intoV(value: N_S): AnyNode {\n  return typeof value !== 'object' ? constant(value) : value\n}\nfunction intoVInfo(value: Num, info: Info | undefined): NumNode\nfunction intoVInfo(value: Str, info: Info | undefined): StrNode\nfunction intoVInfo(value: N_S, info: Info | undefined): AnyNode\nfunction intoVInfo(value: N_S, info: Info | undefined): AnyNode {\n  if (!info) return intoV(value)\n  return typeof value !== 'object'\n    ? constant(value, info)\n    : infoMut({ ...value }, info)\n}\n\ntype _NodeList = { [key: string]: NodeList } & { operation?: never }\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n","import type { AnyNode, Base, NodeData, NumNode, StrNode } from './type'\nimport { constant } from './utils'\n\nexport function deepNodeClone<\n  T extends NodeData<NumNode | StrNode | undefined>\n>(data: T): T {\n  const map = new Map()\n  function internal(orig: any) {\n    if (typeof orig !== 'object') return orig\n    const old = map.get(orig)\n    if (old) return old\n\n    const cache: any = Array.isArray(orig)\n      ? orig.map((val) => internal(val))\n      : Object.fromEntries(\n          Object.entries(orig).map(([key, val]) => [\n            key,\n            key === 'info' ? val : internal(val),\n          ])\n        )\n    map.set(orig, cache)\n    return cache\n  }\n  return internal(data)\n}\n\nexport function forEachNodes<T extends Base<T> = AnyNode>(\n  formulas: T[],\n  topDown: (formula: T) => void,\n  bottomUp: (formula: T) => void\n): void {\n  const visiting = new Set<T>(),\n    visited = new Set<T>()\n\n  function traverse(formula: T) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error('Found cyclical dependency during formula traversal')\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas<\n  Input extends Base<Input> = AnyNode,\n  Interim extends Base<Interim> = Input,\n  Output extends Base<Output> = Interim\n>(\n  formulas: Input[],\n  topDownMap: (formula: Input | Interim) => Interim,\n  bottomUpMap: (current: Interim | Output, orig: Input | Interim) => Output\n): Output[] {\n  const visiting = new Set<Input | Interim>()\n  const topDownMapped = new Map<Input | Interim, Output>()\n  const bottomUpMapped = new Map<Interim, Output>()\n\n  function check(formula: Input | Interim): Output {\n    let topDown: Interim | Output | undefined = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error('Found cyclical dependency during formula mapping')\n      return constant(NaN) as any\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: Interim): Interim | Output {\n    const operands = formula.operands.map(check)\n    return arrayEqual<Interim | Output>(operands, formula.operands)\n      ? formula\n      : { ...formula, operands }\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual<Input | Output>(result, formulas)\n    ? (formulas as any)\n    : result\n}\n\nexport function customMapFormula<Context, Output, Input extends Base<Input>>(\n  formulas: Input[],\n  context: Context,\n  map: (\n    formula: Input,\n    context: Context,\n    map: (node: Input, context: Context) => Output\n  ) => Output\n): Output[] {\n  const contextMapping = new Map<Context, [Set<Input>, Map<Input, Output>]>()\n  function internalMap(formula: Input, context: Context): Output {\n    let current = contextMapping.get(context)\n    if (!current)\n      contextMapping.set(context, (current = [new Set(), new Map()]))\n    const [visiting, mapping] = current\n\n    const old = mapping.get(formula)\n    if (old) return old\n\n    if (visiting.has(formula))\n      throw new Error('Found cyclical dependency during formula mapping')\n\n    visiting.add(formula)\n    const newFormula = map(formula, context, internalMap)\n    mapping.set(formula, newFormula)\n    visiting.delete(formula)\n\n    return newFormula\n  }\n  return formulas.map((formula) => internalMap(formula, context))\n}\n\nfunction arrayEqual<T>(\n  a: readonly T[] | undefined,\n  b: readonly T[] | undefined\n): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import type { ArtifactBuildData } from '../Solver/common'\nimport { assertUnreachable, objPathValue } from '../Util/Util'\nimport { customMapFormula, forEachNodes, mapFormulas } from './internal'\nimport type {\n  AnyNode,\n  CommutativeMonoidOperation,\n  ComputeNode,\n  ConstantNode,\n  Data,\n  NumNode,\n  Operation,\n  ReadNode,\n  StrNode,\n  StrPrioNode,\n  ThresholdNode,\n} from './type'\nimport { constant } from './utils'\n\nexport type OptNode =\n  | ComputeNode<OptNode, OptNode>\n  | ThresholdNode<OptNode, OptNode, OptNode>\n  | ReadNode<number>\n  | ConstantNode<number>\n\nconst allCommutativeMonoidOperations: StrictDict<\n  CommutativeMonoidOperation,\n  (_: number[]) => number\n> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<\n  Operation | 'threshold',\n  (_: number[]) => number\n> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number =>\n    value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(\n  Object.keys(allCommutativeMonoidOperations) as NumNode['operation'][]\n)\n\nexport function optimize(\n  formulas: NumNode[],\n  topLevelData: Data,\n  shouldFold = (_formula: ReadNode<number | string | undefined>) => false\n): OptNode[] {\n  let opts = constantFold(formulas, topLevelData, shouldFold)\n  opts = flatten(opts)\n  opts = constantFold(opts, {})\n  return deduplicate(opts)\n}\nexport function precompute(\n  formulas: OptNode[],\n  initial: ArtifactBuildData['values'],\n  binding: (\n    readNode: ReadNode<number> | ReadNode<string | undefined>\n  ) => string,\n  slotCount: number\n): (_: ArtifactBuildData[]) => number[] {\n  let body = `\n\"use strict\";\n// copied from the code above\nfunction res(res) {\n  if (res < 0) return 1 - res / 2\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\n  return 1 - res\n}\nconst x0=0` // making sure `const` has at least one entry\n\n  let i = 1\n  const names = new Map<NumNode | StrNode, string>()\n  forEachNodes(\n    formulas,\n    (_) => {},\n    (f) => {\n      const { operation, operands } = f,\n        name = `x${i++}`,\n        operandNames = operands.map((x: OptNode) => names.get(x)!)\n      names.set(f, name)\n      switch (operation) {\n        case 'read': {\n          const key = binding(f)\n          let arr = new Array(slotCount)\n            .fill(null)\n            .map((x, i) => `(b[${i}].values[\"${key}\"] ?? 0)`)\n          if (initial[key] && initial[key] !== 0) {\n            arr = [initial[key].toString(), ...arr]\n          }\n          body += `,${name}=${arr.join('+')}`\n          break\n        }\n        case 'const':\n          names.set(f, `(${f.value})`)\n          break\n        case 'add':\n        case 'mul':\n          body += `,${name}=${operandNames.join(\n            operation === 'add' ? '+' : '*'\n          )}`\n          break\n        case 'min':\n        case 'max':\n          body += `,${name}=Math.${operation}(${operandNames})`\n          break\n        case 'threshold': {\n          const [value, threshold, pass, fail] = operandNames\n          body += `,${name}=(${value}>=${threshold})?${pass}:${fail}`\n          break\n        }\n        case 'res':\n          body += `,${name}=res(${operandNames[0]})`\n          break\n        case 'sum_frac':\n          body += `,${name}=${operandNames[0]}/(${operandNames[0]}+${operandNames[1]})`\n          break\n\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n  body += `;\\nreturn [${formulas.map((f) => names.get(f)!)}]`\n  return new (Function as any)(`b`, body)\n}\n\nfunction flatten(formulas: OptNode[]): OptNode[] {\n  return mapFormulas(\n    formulas,\n    (f) => f,\n    (_formula) => {\n      let result = _formula\n      if (commutativeMonoidOperationSet.has(_formula.operation as Operation)) {\n        const formula = _formula as ComputeNode<OptNode>\n        const { operation } = formula\n\n        let flattened = false\n        const operands = formula.operands.flatMap((dep) =>\n          dep.operation === operation\n            ? ((flattened = true), dep.operands)\n            : [dep]\n        )\n        result = flattened ? { ...formula, operands } : formula\n      }\n\n      return result\n    }\n  )\n}\n\nfunction arrayCompare<T>(\n  a: readonly T[],\n  b: readonly T[],\n  cmp: (a: T, b: T) => number\n): number {\n  if (a.length !== b.length) return a.length - b.length\n  for (let i = 0; i < a.length; i++) {\n    const cc = cmp(a[i], b[i])\n    if (cc !== 0) return cc\n  }\n  return 0\n}\n/**\n * Converts `formulas` to a unique normal form via sorting. Commutative operations are\n * also sorted to enforce unique operand ordering. As a consequence, duplicated nodes\n * become easy to find, so we combine identical nodes into the same reference. The\n * sort follows the below fields sequentially:\n *  ```\n *    node height  - height of subtree; distance to furthest leaf.\n *    node type    - Ordering is [const, read, add, mul, min, max, sum_frac, threshold, res]\n *    When types are same:\n *      const:             n.value\n *      read:              alphabetical on path\n *      add/mul/min/max:   sort the operands, then compare sequentially\n *      frac/thresh/res:   compare operands sequentially\n *  ```\n *\n * Sorting is efficient because sorting by ascending height first lets us memoize the\n * ordering of all the children and find a bijection with the natual numbers.\n */\nfunction deduplicate(formulas: OptNode[]): OptNode[] {\n  const nodeHeightMap = new Map<OptNode, number>()\n  const layers = [[]] as OptNode[][]\n  forEachNodes(\n    formulas,\n    (_) => {},\n    (n) => {\n      switch (n.operation) {\n        case 'const':\n        case 'read':\n          layers[0].push(n)\n          nodeHeightMap.set(n, 0)\n          break\n        default: {\n          const h =\n            Math.max(...n.operands.map((op) => nodeHeightMap.get(op)!)) + 1\n          if (layers.length <= h) layers.push([])\n          layers[h].push(n)\n          nodeHeightMap.set(n, h)\n          break\n        }\n      }\n    }\n  )\n\n  function cmpNode(n1: OptNode, n2: OptNode): number {\n    const h1 = nodeHeightMap.get(n1)!,\n      h2 = nodeHeightMap.get(n2)!\n    if (h1 !== h2) return h1 - h2\n    const op1 = n1.operation,\n      op2 = n2.operation\n    if (op1 !== op2) return op1.localeCompare(op2)\n\n    switch (op1) {\n      case 'const':\n        if (op1 !== op2) throw Error('ily jslint')\n        return n1.value - n2.value\n      case 'read':\n        if (op1 !== op2) throw Error('ily jslint')\n        return arrayCompare(n1.path, n2.path, (s1, s2) => s1.localeCompare(s2))\n      case 'res':\n      case 'threshold':\n      case 'sum_frac': {\n        if (op1 !== op2) throw Error('ily jslint')\n        const s1 = n1.operands.map((op) => nodeSortMap.get(op)!),\n          s2 = n2.operands.map((op) => nodeSortMap.get(op)!)\n        return arrayCompare(s1, s2, (n1, n2) => n1 - n2)\n      }\n      case 'add':\n      case 'mul':\n      case 'min':\n      case 'max': {\n        if (op1 !== op2) throw Error('ily jslint')\n        const s1 = n1.operands.map((op) => nodeSortMap.get(op)!),\n          s2 = n2.operands.map((op) => nodeSortMap.get(op)!)\n        s1.sort((a, b) => a - b)\n        s2.sort((a, b) => a - b)\n        return arrayCompare(s1, s2, (n1, n2) => n1 - n2)\n      }\n    }\n  }\n\n  let ix = 0\n  const nodeSortMap = new Map<OptNode, number>()\n  const sortedNodes = [] as OptNode[]\n  layers.forEach((layer) => {\n    layer.sort(cmpNode)\n    sortedNodes.push(layer[0])\n    nodeSortMap.set(layer[0], ix++)\n    for (let i = 1; i < layer.length; i++) {\n      if (cmpNode(layer[i - 1], layer[i]) === 0)\n        nodeSortMap.set(layer[i], nodeSortMap.get(layer[i - 1])!)\n      else {\n        sortedNodes.push(layer[i])\n        nodeSortMap.set(layer[i], ix++)\n      }\n    }\n  })\n\n  sortedNodes.forEach((n, i) => {\n    switch (n.operation) {\n      case 'add':\n      case 'mul':\n      case 'min':\n      case 'max':\n        sortedNodes[i] = {\n          ...n,\n          operands: [...n.operands].sort(\n            (a, b) => nodeSortMap.get(a)! - nodeSortMap.get(b)!\n          ),\n        }\n    }\n  })\n\n  return mapFormulas(\n    formulas,\n    (f) => sortedNodes[nodeSortMap.get(f)!],\n    (_) => _\n  )\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(\n  formulas: NumNode[],\n  topLevelData: Data,\n  shouldFold = (_formula: ReadNode<number | string | undefined>) => false\n): OptNode[] {\n  type Context = {\n    data: Data[]\n    processed: Map<NumNode | StrNode, OptNode | StrNode>\n  }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return customMapFormula<typeof context, OptNode | StrNode, AnyNode>(\n    formulas,\n    context,\n    (formula, context, map) => {\n      const { operation } = formula,\n        fold = (x: NumNode, c: typeof context) => map(x, c) as OptNode\n      const foldStr = (x: StrNode, c: typeof context) => map(x, c) as StrNode\n      let result: OptNode | StrNode\n      switch (operation) {\n        case 'const':\n          result = formula\n          break\n        case 'add':\n        case 'mul':\n        case 'max':\n        case 'min': {\n          const f = allOperations[operation]\n          const numericOperands: number[] = []\n          const formulaOperands: OptNode[] = formula.operands\n            .filter((formula) => {\n              const folded = fold(formula, context)\n              return folded.operation === 'const'\n                ? (numericOperands.push(folded.value), false)\n                : true\n            })\n            .map((x) => fold(x, context))\n          const numericValue = f(numericOperands)\n\n          // Fold degenerate cases. This may incorrectly compute NaN\n          // results, which shouldn't appear under expected usage.\n          // - zero\n          //   - 0 * ... = 0\n          // - infinity\n          //   - max(infinity, ...) = infinity\n          //   - infinity + ... = infinity\n          // - (-infinity)\n          //   - min(-infinity, ...) - infinity\n          //   - (-infinity) + ... = -infinity\n          // - NaN\n          //   - operation(NaN, ...) = NaN\n          if (!isFinite(numericValue)) {\n            if (\n              operation !== 'mul' &&\n              (operation !== 'max' || numericValue > 0) &&\n              (operation !== 'min' || numericValue < 0)\n            ) {\n              result = constant(numericValue)\n              break\n            }\n          } else if (operation === 'mul' && numericValue === 0) {\n            result = constant(numericValue)\n            break\n          }\n\n          if (numericValue !== f([]))\n            // Skip vacuous values\n            formulaOperands.push(constant(numericValue))\n          if (formulaOperands.length <= 1)\n            result = formulaOperands[0] ?? constant(f([]))\n          else result = { operation, operands: formulaOperands }\n          break\n        }\n        case 'res':\n        case 'sum_frac': {\n          const operands = formula.operands.map((x) => fold(x, context))\n          const f = allOperations[operation]\n          if (operands.every((x) => x.operation === 'const'))\n            result = constant(\n              f(operands.map((x) => (x as ConstantNode<number>).value))\n            )\n          else result = { ...formula, operands }\n          break\n        }\n        case 'lookup': {\n          const index = foldStr(formula.operands[0], context)\n          if (index.operation === 'const') {\n            const selected = formula.table[index.value!] ?? formula.operands[1]\n            if (selected) {\n              result = map(selected, context)\n              break\n            }\n          }\n          throw new Error(`Unsupported ${operation} node while folding`)\n        }\n        case 'prio': {\n          const first = formula.operands.find((op) => {\n            const folded = foldStr(op, context)\n            if (folded.operation !== 'const')\n              throw new Error(`Unsupported ${operation} node while folding`)\n            return folded.value !== undefined\n          })\n          result = first ? foldStr(first, context) : constant(undefined)\n          break\n        }\n        case 'small': {\n          let smallest = undefined as\n            | ConstantNode<string | undefined>\n            | undefined\n          for (const operand of formula.operands) {\n            const folded = foldStr(operand, context)\n            if (folded.operation !== 'const')\n              throw new Error(`Unsupported ${operation} node while folding`)\n            if (\n              smallest?.value === undefined ||\n              (folded.value !== undefined && folded.value < smallest.value)\n            )\n              smallest = folded\n          }\n          result = smallest ?? constant(undefined)\n          break\n        }\n        case 'match': {\n          const [v1, v2, match, unmatch] = formula.operands.map(\n            (x: NumNode | StrNode) => map(x, context)\n          )\n          if (v1.operation !== 'const' || v2.operation !== 'const')\n            throw new Error(`Unsupported ${operation} node while folding`)\n          result = v1.value === v2.value ? match : unmatch\n          break\n        }\n        case 'threshold': {\n          const [value, threshold, pass, fail] = formula.operands.map(\n            (x) => map(x, context) as OptNode\n          )\n          if (\n            pass.operation === 'const' &&\n            fail.operation === 'const' &&\n            pass.value === fail.value\n          )\n            result = pass\n          else if (\n            value.operation === 'const' &&\n            threshold.operation === 'const'\n          )\n            result = value.value >= threshold.value ? pass : fail\n          else result = { ...formula, operands: [value, threshold, pass, fail] }\n          break\n        }\n        case 'subscript': {\n          const index = fold(formula.operands[0], context)\n          if (index.operation !== 'const')\n            throw new Error('Found non-constant subscript node while folding')\n          result = constant(formula.list[index.value])\n          break\n        }\n        case 'read': {\n          const operands = context.data\n            .map((x) => objPathValue(x, formula.path) as NumNode | StrNode)\n            .filter((x) => x)\n\n          if (operands.length === 0) {\n            if (shouldFold(formula)) {\n              const { accu } = formula\n              if (accu === undefined || accu === 'small')\n                result =\n                  formula.type === 'string'\n                    ? constant(undefined)\n                    : constant(NaN)\n              else result = constant(allOperations[accu]([]))\n            } else result = formula\n          } else if (formula.accu === undefined || operands.length === 1)\n            result = map(operands[operands.length - 1], context)\n          else\n            result = map(\n              { operation: formula.accu, operands } as\n                | ComputeNode\n                | StrPrioNode,\n              context\n            )\n          break\n        }\n        case 'data': {\n          if (formula.reset) context = origin\n          const nextMap = nextContextMap.get(context)!\n          let nextContext = nextMap.get(formula.data)\n          if (!nextContext) {\n            nextContext = {\n              data: [...context.data, formula.data],\n              processed: new Map(),\n            }\n            nextContextMap.set(nextContext, new Map())\n            nextMap.set(formula.data, nextContext)\n          }\n          result = map(formula.operands[0], nextContext)\n          break\n        }\n        default:\n          assertUnreachable(operation)\n      }\n\n      if (result.info) {\n        result = { ...result }\n        delete result.info\n      }\n      return result\n    }\n  ) as OptNode[]\n}\n\nexport const testing = {\n  constantFold,\n  flatten,\n  deduplicate,\n}\n","export const allGenderKeys = ['F', 'M'] as const\nexport type GenderKey = (typeof allGenderKeys)[number]\n\nexport const allElementKeys = [\n  'anemo',\n  'geo',\n  'electro',\n  'hydro',\n  'pyro',\n  'cryo',\n  'dendro',\n] as const\nexport type ElementKey = (typeof allElementKeys)[number]\n\nexport const allElementWithPhyKeys = ['physical', ...allElementKeys] as const\nexport type ElementWithPhyKey = (typeof allElementWithPhyKeys)[number]\n\nexport const allRegionKeys = [\n  'mondstadt',\n  'liyue',\n  'inazuma',\n  'sumeru',\n  'fontaine',\n  'natlan',\n  'snezhnaya',\n  'khaenriah',\n] as const\nexport type RegionKey = (typeof allRegionKeys)[number]\n\nexport const allAscensionKeys = [0, 1, 2, 3, 4, 5, 6] as const\nexport type AscensionKey = (typeof allAscensionKeys)[number]\n\nexport const allMoveKeys = [\n  'normal',\n  'charged',\n  'plunging',\n  'skill',\n  'burst',\n  'elemental',\n] as const\nexport type MoveKey = (typeof allMoveKeys)[number]\n\nexport const nonTravelerCharacterKeys = [\n  'Albedo',\n  'Alhaitham',\n  'Aloy',\n  'Amber',\n  'AratakiItto',\n  'Barbara',\n  'Beidou',\n  'Bennett',\n  'Candace',\n  'Chongyun',\n  'Collei',\n  'Cyno',\n  'Dehya',\n  'Diluc',\n  'Diona',\n  'Dori',\n  'Eula',\n  'Faruzan',\n  'Fischl',\n  'Ganyu',\n  'Gorou',\n  'HuTao',\n  'Jean',\n  'KaedeharaKazuha',\n  'Kaeya',\n  'KamisatoAyaka',\n  'KamisatoAyato',\n  'Keqing',\n  'Klee',\n  'KujouSara',\n  'KukiShinobu',\n  'Layla',\n  'Lisa',\n  'Mika',\n  'Mona',\n  'Nahida',\n  'Nilou',\n  'Ningguang',\n  'Noelle',\n  'Qiqi',\n  'RaidenShogun',\n  'Razor',\n  'Rosaria',\n  'SangonomiyaKokomi',\n  'Sayu',\n  'Shenhe',\n  'ShikanoinHeizou',\n  'Somnia',\n  'Sucrose',\n  'Tartaglia',\n  'Thoma',\n  'Tighnari',\n  'Venti',\n  'Wanderer',\n  'Xiangling',\n  'Xiao',\n  'Xingqiu',\n  'Xinyan',\n  'YaeMiko',\n  'Yanfei',\n  'Yaoyao',\n  'Yelan',\n  'Yoimiya',\n  'YunJin',\n  'Zhongli',\n] as const\n\nexport const allTravelerKeys = [\n  'TravelerAnemo',\n  'TravelerGeo',\n  'TravelerElectro',\n  'TravelerDendro',\n] as const\nexport type TravelerKey = (typeof allTravelerKeys)[number]\n\nexport const locationGenderedCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  'TravelerF',\n  'TravelerM',\n] as const\nexport type LocationGenderedCharacterKey =\n  (typeof locationGenderedCharacterKeys)[number]\n\nexport const allCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  ...allTravelerKeys,\n] as const\nexport type CharacterKey = (typeof allCharacterKeys)[number]\n\nexport const allLocationCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  'Traveler',\n] as const\nexport type LocationCharacterKey = (typeof allLocationCharacterKeys)[number]\n\nexport type LocationKey = LocationCharacterKey | ''\n\nexport function charKeyToLocGenderedCharKey(\n  charKey: CharacterKey,\n  gender: GenderKey\n): LocationGenderedCharacterKey {\n  if (allTravelerKeys.includes(charKey as TravelerKey))\n    return `Traveler${gender}`\n  return charKey as LocationGenderedCharacterKey\n}\n\nexport function charKeyToLocCharKey(\n  charKey: CharacterKey\n): LocationCharacterKey {\n  if (allTravelerKeys.includes(charKey as TravelerKey)) return 'Traveler'\n  return charKey as LocationCharacterKey\n}\n","import type { RarityKey } from './common'\n\nexport const allArtifactSetKeys = [\n  'Adventurer',\n  'ArchaicPetra',\n  'Berserker',\n  'BlizzardStrayer',\n  'BloodstainedChivalry',\n  'BraveHeart',\n  'CrimsonWitchOfFlames',\n  'DeepwoodMemories',\n  'DefendersWill',\n  'DesertPavilionChronicle',\n  'EchoesOfAnOffering',\n  'EmblemOfSeveredFate',\n  'FlowerOfParadiseLost',\n  'Gambler',\n  'GildedDreams',\n  'GladiatorsFinale',\n  'HeartOfDepth',\n  'HuskOfOpulentDreams',\n  'Instructor',\n  'Lavawalker',\n  'LuckyDog',\n  'MaidenBeloved',\n  'MartialArtist',\n  'NoblesseOblige',\n  'NymphsDream',\n  'OceanHuedClam',\n  'PaleFlame',\n  'PrayersForDestiny',\n  'PrayersForIllumination',\n  'PrayersForWisdom',\n  'PrayersToSpringtime',\n  'ResolutionOfSojourner',\n  'RetracingBolide',\n  'Scholar',\n  'ShimenawasReminiscence',\n  'TenacityOfTheMillelith',\n  'TheExile',\n  'ThunderingFury',\n  'Thundersoother',\n  'TinyMiracle',\n  'TravelingDoctor',\n  'VermillionHereafter',\n  'ViridescentVenerer',\n  'VourukashasGlow',\n  'WanderersTroupe',\n] as const\nexport type ArtifactSetKey = (typeof allArtifactSetKeys)[number]\n\nexport const allArtifactSlotKeys = [\n  'flower',\n  'plume',\n  'sands',\n  'goblet',\n  'circlet',\n] as const\nexport type ArtifactSlotKey = (typeof allArtifactSlotKeys)[number]\n\nexport const artMaxLevel: Record<RarityKey, number> = {\n  1: 4,\n  2: 4,\n  3: 12,\n  4: 16,\n  5: 20,\n} as const\n","import type { RarityKey } from './common'\n\nexport const allWeaponTypeKeys = [\n  'sword',\n  'claymore',\n  'polearm',\n  'bow',\n  'catalyst',\n] as const\nexport type WeaponTypeKey = (typeof allWeaponTypeKeys)[number]\n\nexport const allWeaponSwordKeys = [\n  'AmenomaKageuchi',\n  'AquilaFavonia',\n  'BlackcliffLongsword',\n  'CinnabarSpindle',\n  'CoolSteel',\n  'KagotsurubeIsshin',\n  'DarkIronSword',\n  'DullBlade',\n  'FavoniusSword',\n  'FesteringDesire',\n  'FilletBlade',\n  'FreedomSworn',\n  'HaranGeppakuFutsu',\n  'HarbingerOfDawn',\n  'IronSting',\n  'KeyOfKhajNisut',\n  'LightOfFoliarIncision',\n  'LionsRoar',\n  'MistsplitterReforged',\n  'PrimordialJadeCutter',\n  'PrototypeRancour',\n  'RoyalLongsword',\n  'SacrificialSword',\n  'SapwoodBlade',\n  'SilverSword',\n  'SkyriderSword',\n  'SkywardBlade',\n  'SummitShaper',\n  'SwordOfDescension',\n  'TheAlleyFlash',\n  'TheBlackSword',\n  'TheFlute',\n  'ToukabouShigure',\n  'TravelersHandySword',\n  'XiphosMoonlight',\n] as const\nexport type WeaponSwordKey = (typeof allWeaponSwordKeys)[number]\n\nexport const allWeaponClaymoreKeys = [\n  'Akuoumaru',\n  'BeaconOfTheReedSea',\n  'BlackcliffSlasher',\n  'BloodtaintedGreatsword',\n  'DebateClub',\n  'FavoniusGreatsword',\n  'FerrousShadow',\n  'ForestRegalia',\n  'KatsuragikiriNagamasa',\n  'LithicBlade',\n  'LuxuriousSeaLord',\n  'MailedFlower',\n  'MakhairaAquamarine',\n  'OldMercsPal',\n  'PrototypeArchaic',\n  'Rainslasher',\n  'RedhornStonethresher',\n  'RoyalGreatsword',\n  'SacrificialGreatsword',\n  'SerpentSpine',\n  'SkyriderGreatsword',\n  'SkywardPride',\n  'SnowTombedStarsilver',\n  'SongOfBrokenPines',\n  'TheBell',\n  'TheUnforged',\n  'WasterGreatsword',\n  'Whiteblind',\n  'WhiteIronGreatsword',\n  'WolfsGravestone',\n] as const\nexport type WeaponClaymoreKey = (typeof allWeaponClaymoreKeys)[number]\n\nexport const allWeaponPolearmKeys = [\n  'BeginnersProtector',\n  'BlackcliffPole',\n  'BlackTassel',\n  'CalamityQueller',\n  'CrescentPike',\n  'Deathmatch',\n  'DragonsBane',\n  'DragonspineSpear',\n  'EngulfingLightning',\n  'FavoniusLance',\n  'Halberd',\n  'IronPoint',\n  'KitainCrossSpear',\n  'LithicSpear',\n  'MissiveWindspear',\n  'Moonpiercer',\n  'PrimordialJadeWingedSpear',\n  'PrototypeStarglitter',\n  'RoyalSpear',\n  'SkywardSpine',\n  'StaffOfHoma',\n  'StaffOfTheScarletSands',\n  'TheCatch',\n  'VortexVanquisher',\n  'WavebreakersFin',\n  'WhiteTassel',\n] as const\nexport type WeaponPoleArmKey = (typeof allWeaponPolearmKeys)[number]\n\nexport const allWeaponBowKeys = [\n  'AlleyHunter',\n  'AmosBow',\n  'AquaSimulacra',\n  'BlackcliffWarbow',\n  'CompoundBow',\n  'ElegyForTheEnd',\n  'EndOfTheLine',\n  'FadingTwilight',\n  'FavoniusWarbow',\n  'Hamayumi',\n  'HuntersBow',\n  'HuntersPath',\n  'KingsSquire',\n  'Messenger',\n  'MitternachtsWaltz',\n  'MouunsMoon',\n  'PolarStar',\n  'Predator',\n  'PrototypeCrescent',\n  'RavenBow',\n  'RecurveBow',\n  'RoyalBow',\n  'Rust',\n  'SacrificialBow',\n  'SeasonedHuntersBow',\n  'SharpshootersOath',\n  'SkywardHarp',\n  'Slingshot',\n  'TheStringless',\n  'TheViridescentHunt',\n  'ThunderingPulse',\n  'WindblumeOde',\n] as const\nexport type WeaponBowKey = (typeof allWeaponBowKeys)[number]\n\nexport const allWeaponCatalystKeys = [\n  'ApprenticesNotes',\n  'AThousandFloatingDreams',\n  'BlackcliffAgate',\n  'DodocoTales',\n  'EmeraldOrb',\n  'EverlastingMoonglow',\n  'EyeOfPerception',\n  'FavoniusCodex',\n  'Frostbearer',\n  'FruitOfFulfillment',\n  'HakushinRing',\n  'KagurasVerity',\n  'LostPrayerToTheSacredWinds',\n  'MagicGuide',\n  'MappaMare',\n  'MemoryOfDust',\n  'OathswornEye',\n  'OtherworldlyStory',\n  'PocketGrimoire',\n  'PrototypeAmber',\n  'QuantumCatalyst',\n  'RoyalGrimoire',\n  'SacrificialFragments',\n  'SkywardAtlas',\n  'SolarPearl',\n  'TheWidsith',\n  'ThrillingTalesOfDragonSlayers',\n  'TulaytullahsRemembrance',\n  'TwinNephrite',\n  'WanderingEvenstar',\n  'WineAndSong',\n] as const\nexport type WeaponCatalystKey = (typeof allWeaponCatalystKeys)[number]\n\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\nexport type WeaponKey =\n  | WeaponSwordKey\n  | WeaponClaymoreKey\n  | WeaponPoleArmKey\n  | WeaponBowKey\n  | WeaponCatalystKey\n\nexport const weaponMaxLevel: Record<RarityKey, number> = {\n  1: 70,\n  2: 70,\n  3: 90,\n  4: 90,\n  5: 90,\n} as const\n","import type {\n  allArtifactSetKeys,\n  WeaponBowKey,\n  WeaponCatalystKey,\n  WeaponClaymoreKey,\n  WeaponPoleArmKey,\n  WeaponSwordKey,\n} from '@genshin-optimizer/consts'\nimport {\n  allWeaponBowKeys,\n  allWeaponCatalystKeys,\n  allWeaponClaymoreKeys,\n  allWeaponPolearmKeys,\n  allWeaponSwordKeys,\n  nonTravelerCharacterKeys,\n} from '@genshin-optimizer/consts'\n\nexport const allHitModes = ['hit', 'avgHit', 'critHit'] as const\nexport const allAmpReactions = ['vaporize', 'melt'] as const\nexport const allAdditiveReactions = ['spread', 'aggravate'] as const\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\n\nexport const allArtifactRarities = [5, 4, 3] as const\n/**\n * @deprecated\n */\nexport const allSlotKeys = [\n  'flower',\n  'plume',\n  'sands',\n  'goblet',\n  'circlet',\n] as const\n/**\n * @deprecated\n */\nexport const allElements = [\n  'anemo',\n  'geo',\n  'electro',\n  'hydro',\n  'pyro',\n  'cryo',\n  'dendro',\n] as const\n/**\n * @deprecated\n */\nexport const allElementsWithPhy = ['physical', ...allElements] as const\nexport const allInfusionAuraElements = [\n  'pyro',\n  'cryo',\n  'hydro',\n  'electro',\n] as const\n/**\n * @deprecated\n */\nexport const allWeaponTypeKeys = [\n  'sword',\n  'claymore',\n  'polearm',\n  'bow',\n  'catalyst',\n] as const\nexport const allRollColorKeys = [\n  'roll1',\n  'roll2',\n  'roll3',\n  'roll4',\n  'roll5',\n  'roll6',\n] as const\n/**\n * @deprecated\n */\nexport const allAscension = [0, 1, 2, 3, 4, 5, 6] as const\nexport const allRefinement = [1, 2, 3, 4, 5] as const\nexport const substatType = ['max', 'mid', 'min'] as const\nexport const genderKeys = ['F', 'M'] as const\nexport type Gender = (typeof genderKeys)[number]\n\n/**\n * @deprecated\n */\nexport const allLocationCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  'Traveler',\n] as const\nexport const travelerElements = ['anemo', 'geo', 'electro', 'dendro'] as const\nexport const travelerFKeys = [\n  'TravelerAnemoF',\n  'TravelerGeoF',\n  'TravelerElectroF',\n  'TravelerDendroF',\n] as const\nexport const travelerMKeys = [\n  'TravelerAnemoM',\n  'TravelerGeoM',\n  'TravelerElectroM',\n  'TravelerDendroM',\n] as const\n/**\n * @deprecated\n */\nexport const travelerKeys = [\n  'TravelerAnemo',\n  'TravelerGeo',\n  'TravelerElectro',\n  'TravelerDendro',\n] as const\n/**\n * @deprecated\n */\nexport const allCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  ...travelerKeys,\n] as const\n\nexport const allCharacterSheetKeys = [\n  ...nonTravelerCharacterKeys,\n  ...travelerFKeys,\n  ...travelerMKeys,\n]\n\n/**\n * @deprecated\n */\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\n/**\n * @deprecated\n */\nexport type WeaponKey =\n  | WeaponSwordKey\n  | WeaponClaymoreKey\n  | WeaponPoleArmKey\n  | WeaponBowKey\n  | WeaponCatalystKey\n\nexport const characterSpecializedStatKeys = [\n  'hp_',\n  'atk_',\n  'def_',\n  'eleMas',\n  'enerRech_',\n  'heal_',\n  'critRate_',\n  'critDMG_',\n  'physical_dmg_',\n  'anemo_dmg_',\n  'geo_dmg_',\n  'electro_dmg_',\n  'hydro_dmg_',\n  'pyro_dmg_',\n  'cryo_dmg_',\n  'dendro_dmg_',\n] as const\n\nexport type HitModeKey = (typeof allHitModes)[number]\nexport type AmpReactionKey = (typeof allAmpReactions)[number]\nexport type AdditiveReactionKey = (typeof allAdditiveReactions)[number]\nexport type SetNum = (typeof allArtifactSetCount)[number]\nexport type ArtifactRarity = (typeof allArtifactRarities)[number]\n/**\n * @deprecated\n */\nexport type SlotKey = (typeof allSlotKeys)[number]\n/**\n * @deprecated\n */\nexport type ElementKey = (typeof allElements)[number]\n/**\n * @deprecated\n */\nexport type ElementKeyWithPhy = (typeof allElementsWithPhy)[number]\nexport type InfusionAuraElements = (typeof allInfusionAuraElements)[number]\n/**\n * @deprecated\n */\nexport type ArtifactSetKey = (typeof allArtifactSetKeys)[number]\n/**\n * @deprecated\n */\nexport type CharacterKey = (typeof allCharacterKeys)[number]\nexport type CharacterSheetKey = (typeof allCharacterSheetKeys)[number]\n/**\n * @deprecated\n */\nexport type LocationCharacterKey = (typeof allLocationCharacterKeys)[number]\n/**\n * @deprecated\n */\nexport type TravelerKey = (typeof travelerKeys)[number]\nexport type TravelerElementKey = (typeof travelerElements)[number]\n/**\n * @deprecated\n */\nexport type WeaponTypeKey = (typeof allWeaponTypeKeys)[number]\nexport type RollColorKey = (typeof allRollColorKeys)[number]\n/**\n * @deprecated\n */\nexport type Ascension = (typeof allAscension)[number]\nexport type Refinement = (typeof allRefinement)[number]\nexport type CharacterSpecializedStatKey =\n  (typeof characterSpecializedStatKeys)[number]\nexport const absorbableEle = [\n  'hydro',\n  'pyro',\n  'cryo',\n  'electro',\n] as ElementKey[]\nexport const allowedAmpReactions: Dict<ElementKey, AmpReactionKey[]> = {\n  pyro: ['vaporize', 'melt'],\n  hydro: ['vaporize'],\n  cryo: ['melt'],\n  anemo: ['vaporize', 'melt'],\n}\nexport const allowedAdditiveReactions: Dict<ElementKey, AdditiveReactionKey[]> =\n  {\n    dendro: ['spread'],\n    electro: ['aggravate'],\n    anemo: ['aggravate'],\n  }\n\nexport type SubstatType = (typeof substatType)[number]\n\n/**\n * @deprecated\n */\nexport function charKeyToLocCharKey(\n  charKey: CharacterKey\n): LocationCharacterKey {\n  if (travelerKeys.includes(charKey as TravelerKey)) return 'Traveler'\n  return charKey as LocationCharacterKey\n}\n\nexport function TravelerToElement(\n  key: TravelerKey,\n  element: TravelerElementKey\n): TravelerKey {\n  return ('Traveler' +\n    element.toUpperCase().slice(0, 1) +\n    element.slice(1)) as TravelerKey\n}\n\n/**\n * @deprecated\n */\nexport type LocationKey = LocationCharacterKey | ''\n\nexport function charKeyToCharName(ck: CharacterKey, gender: Gender): string {\n  return ck.startsWith('Traveler') ? 'Traveler' + gender : ck\n}\n","import type { ArtSetExclusion } from '../Database/DataManagers/BuildSettingData'\nimport { forEachNodes, mapFormulas } from '../Formula/internal'\nimport type { OptNode } from '../Formula/optimization'\nimport { allOperations, constantFold } from '../Formula/optimization'\nimport type { ConstantNode } from '../Formula/type'\nimport { constant, dynRead, max, min, sum, threshold } from '../Formula/utils'\nimport type { ArtifactSetKey, SlotKey } from '../Types/consts'\nimport { allSlotKeys } from '../Types/consts'\nimport { assertUnreachable, objectKeyMap, objectMap, range } from '../Util/Util'\n\ntype MicropassOperation =\n  | 'reaffine'\n  | 'pruneArtRange'\n  | 'pruneNodeRange'\n  | 'pruneOrder'\nexport function pruneAll(\n  nodes: OptNode[],\n  minimum: number[],\n  arts: ArtifactsBySlot,\n  numTop: number,\n  exclusion: ArtSetExclusion,\n  forced: Dict<MicropassOperation, boolean>\n): { nodes: OptNode[]; arts: ArtifactsBySlot } {\n  let should = forced\n  /** If `key` makes progress, all operations in `value` should be performed */\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\n    pruneOrder: { pruneNodeRange: true },\n    pruneArtRange: { pruneNodeRange: true },\n    pruneNodeRange: { reaffine: true },\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true },\n  }\n  let count = 0\n  while (Object.values(should).some((x) => x) && count++ < 20) {\n    if (should.pruneOrder) {\n      delete should.pruneOrder\n      const newArts = pruneOrder(arts, numTop, exclusion)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneOrder }\n      }\n    }\n    if (should.pruneArtRange) {\n      delete should.pruneArtRange\n      const newArts = pruneArtRange(nodes, arts, minimum)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneArtRange }\n      }\n    }\n    if (should.pruneNodeRange) {\n      delete should.pruneNodeRange\n      const newNodes = pruneNodeRange(nodes, arts)\n      if (nodes !== newNodes) {\n        nodes = newNodes\n        should = { ...should, ...deps.pruneNodeRange }\n      }\n    }\n    if (should.reaffine) {\n      delete should.reaffine\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\n      if (nodes !== newNodes || arts !== newArts) {\n        nodes = newNodes\n        arts = newArts\n        should = { ...should, ...deps.reaffine }\n      }\n    }\n  }\n  return { nodes, arts }\n}\n\nexport function pruneExclusion(\n  nodes: OptNode[],\n  exclusion: ArtSetExclusion\n): OptNode[] {\n  const maxValues: Dict<keyof typeof exclusion, number> = {}\n  for (const [key, e] of Object.entries(exclusion)) {\n    if (!e.includes(4)) continue\n    maxValues[key] = e.includes(2) ? 1 : 3\n  }\n  return mapFormulas(\n    nodes,\n    (f) => f,\n    (f) => {\n      if (f.operation !== 'threshold') return f\n\n      const [v, t, pass, fail] = f.operands\n      if (v.operation === 'read' && t.operation === 'const') {\n        const key = v.path[v.path.length - 1],\n          thres = t.value\n        if (key in maxValues) {\n          const max: number = maxValues[key]\n          if (max < thres) return fail\n          if (thres === 2 && exclusion[key]!.includes(2))\n            return threshold(v, 4, pass, fail)\n        }\n      }\n      return f\n    }\n  )\n}\n\nfunction reaffine(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot,\n  forceRename = false\n): { nodes: OptNode[]; arts: ArtifactsBySlot } {\n  const affineNodes = new Set<OptNode>(),\n    topLevelAffine = new Set<OptNode>()\n\n  function visit(node: OptNode, isAffine: boolean): OptNode {\n    if (isAffine) affineNodes.add(node)\n    else\n      node.operands.forEach(\n        (op) => affineNodes.has(op) && topLevelAffine.add(op)\n      )\n    return node\n  }\n\n  const dynKeys = new Set<string>()\n\n  nodes = mapFormulas(\n    nodes,\n    (_) => _,\n    (f) => {\n      const { operation } = f\n      switch (operation) {\n        case 'read':\n          dynKeys.add(f.path[1])\n          return visit(f, true)\n        case 'add': {\n          const affineOps = f.operands.filter((op) => affineNodes.has(op))\n          const nonAffineOps = f.operands.filter((op) => !affineNodes.has(op))\n          if (nonAffineOps.length === 0) return visit(f, true)\n          if (affineOps.length <= 1) return visit(f, false)\n          const affine = visit(sum(...affineOps), true)\n          return visit(sum(affine, ...nonAffineOps), false)\n        }\n        case 'mul': {\n          const nonConst = f.operands.filter((op) => op.operation !== 'const')\n          return visit(\n            f,\n            nonConst.length === 0 ||\n              (nonConst.length === 1 && affineNodes.has(nonConst[0]))\n          )\n        }\n        case 'const':\n          return visit(f, true)\n        case 'res':\n        case 'threshold':\n        case 'sum_frac':\n        case 'max':\n        case 'min':\n          return visit(f, false)\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n\n  nodes\n    .filter((node) => affineNodes.has(node))\n    .forEach((node) => topLevelAffine.add(node))\n  if (\n    [...topLevelAffine].every(\n      ({ operation }) => operation === 'read' || operation === 'const'\n    ) &&\n    Object.keys(arts.base).length === dynKeys.size\n  )\n    return { nodes, arts }\n\n  let current = -1\n  function nextDynKey(): string {\n    while (dynKeys.has(`${++current}`));\n    return `${current}`\n  }\n\n  const affine = [...topLevelAffine].filter((f) => f.operation !== 'const')\n  const affineMap = new Map(\n    affine.map((node) => [\n      node,\n      !forceRename && node.operation === 'read' && node.path[0] === 'dyn'\n        ? node\n        : dynRead(nextDynKey()),\n    ])\n  )\n  nodes = mapFormulas(\n    nodes,\n    (f) => affineMap.get(f) ?? f,\n    (f) => f\n  )\n\n  function reaffineArt(stat: DynStat): DynStat {\n    const values = constantFold(\n      [...affineMap.keys()],\n      {\n        dyn: objectMap(stat, (value) => constant(value)),\n      } as any,\n      (_) => true\n    )\n    return Object.fromEntries(\n      [...affineMap.values()].map((v, i) => [\n        v.path[1],\n        (values[i] as ConstantNode<number>).value,\n      ])\n    )\n  }\n  const result = {\n    nodes,\n    arts: {\n      base: reaffineArt(arts.base),\n      values: objectKeyMap(allSlotKeys, (slot) =>\n        arts.values[slot].map(({ id, set, values }) => ({\n          id,\n          set,\n          values: reaffineArt(values),\n        }))\n      ),\n    },\n  }\n  const offsets = Object.entries(reaffineArt({}))\n  for (const arts of Object.values(result.arts.values))\n    for (const { values } of arts)\n      for (const [key, baseValue] of offsets) values[key] -= baseValue\n  return result\n}\n/** Remove artifacts that cannot be in top `numTop` builds */\nfunction pruneOrder(\n  arts: ArtifactsBySlot,\n  numTop: number,\n  exclusion: ArtSetExclusion\n): ArtifactsBySlot {\n  let progress = false\n  /**\n   * Note:\n   * This function assumes that every base (reaffined) stats are monotonically increasing. That is, artifacts\n   * with higher stats are better. This remains true as long as the main and substats are in increasing. Set\n   * effects that decrease enemy resistance (which is monotonically decreasing) does not violate this assumption\n   * as set effects are not handled here.\n   */\n  const allowRainbow = !exclusion.rainbow?.length,\n    keys = Object.keys(arts.base)\n  const noSwitchIn = new Set(\n    Object.entries(exclusion)\n      .filter(([_, v]) => v.length)\n      .map(([k]) => k) as ArtifactSetKey[]\n  )\n  const noSwitchOut = new Set(\n    Object.entries(exclusion)\n      .filter(([_, v]) => v.includes(2) && !v.includes(4))\n      .map(([k]) => k) as ArtifactSetKey[]\n  )\n  const values = objectKeyMap(allSlotKeys, (slot) => {\n    const list = arts.values[slot]\n    const newList = list.filter((art) => {\n      let count = 0\n      return list.every((other) => {\n        const otherBetterEqual = keys.every(\n          (k) => (other.values[k] ?? 0) >= (art.values[k] ?? 0)\n        )\n        const otherMaybeBetter = keys.some(\n          (k) => (other.values[k] ?? 0) > (art.values[k] ?? 0)\n        )\n        const otherBetter =\n          otherBetterEqual && (otherMaybeBetter || other.id > art.id)\n        const canSwitch =\n          (allowRainbow &&\n            !noSwitchIn.has(other.set!) &&\n            !noSwitchOut.has(art.set!)) ||\n          art.set === other.set\n        if (otherBetter && canSwitch) count++\n        return count < numTop\n      })\n    })\n    if (newList.length !== list.length) progress = true\n    return newList\n  })\n  return progress ? { base: arts.base, values } : arts\n}\n/** Remove artifacts that cannot reach `minimum` in any build */\nfunction pruneArtRange(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot,\n  minimum: number[]\n): ArtifactsBySlot {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  const wrap = { arts }\n  while (true) {\n    const artRanges = objectKeyMap(allSlotKeys, (slot) =>\n      computeArtRange(wrap.arts.values[slot])\n    )\n    const otherArtRanges = objectKeyMap(allSlotKeys, (key) =>\n      addArtRange(\n        Object.entries(artRanges)\n          .map((a) => (a[0] === key ? baseRange : a[1]))\n          .filter((x) => x)\n      )\n    )\n\n    let progress = false\n    const values = objectKeyMap(allSlotKeys, (slot) => {\n      const result = wrap.arts.values[slot].filter((art) => {\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\n        const newRange = computeNodeRange(nodes, read)\n        return nodes.every(\n          (node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity)\n        )\n      })\n      if (result.length !== wrap.arts.values[slot].length) progress = true\n      return result\n    })\n    if (!progress) break\n    wrap.arts = { base: wrap.arts.base, values }\n  }\n  return wrap.arts\n}\nfunction pruneNodeRange(nodes: OptNode[], arts: ArtifactsBySlot): OptNode[] {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  const reads = addArtRange([\n    baseRange,\n    ...Object.values(arts.values).map((values) => computeArtRange(values)),\n  ])\n  const nodeRange = computeNodeRange(nodes, reads)\n\n  return mapFormulas(\n    nodes,\n    (f) => {\n      {\n        const { min, max } = nodeRange.get(f)!\n        if (min === max) return constant(min)\n      }\n      const { operation } = f\n      const operandRanges = f.operands.map((x) => nodeRange.get(x)!)\n      switch (operation) {\n        case 'threshold': {\n          const [value, threshold, pass, fail] = operandRanges\n          if (value.min >= threshold.max) return f.operands[2]\n          else if (value.max < threshold.min) return f.operands[3]\n          if (\n            pass.max === pass.min &&\n            fail.max === fail.min &&\n            pass.min === fail.min &&\n            isFinite(pass.min)\n          )\n            return constant(pass.max)\n          break\n        }\n        case 'min': {\n          const newOperands = f.operands.filter((_, i) => {\n            const op1 = operandRanges[i]\n            return operandRanges.every((op2) => op1.min <= op2.max)\n          })\n          if (newOperands.length < operandRanges.length)\n            return min(...newOperands)\n          break\n        }\n        case 'max': {\n          const newOperands = f.operands.filter((_, i) => {\n            const op1 = operandRanges[i]\n            return operandRanges.every((op2) => op1.max >= op2.min)\n          })\n          if (newOperands.length < operandRanges.length)\n            return max(...newOperands)\n          break\n        }\n      }\n      return f\n    },\n    (f) => f\n  )\n}\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\n  const result: DynMinMax = {}\n  ranges.forEach((range) => {\n    Object.entries(range).forEach(([key, value]) => {\n      if (result[key]) {\n        result[key].min += value.min\n        result[key].max += value.max\n      } else result[key] = { ...value }\n    })\n  })\n  return result\n}\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\n  const result: DynMinMax = {}\n  if (arts.length) {\n    Object.keys(arts[0].values)\n      .filter((key) => arts.every((art) => art.values[key]))\n      .forEach(\n        (key) =>\n          (result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\n      )\n    arts.forEach(({ values }) => {\n      for (const [key, value] of Object.entries(values)) {\n        if (!result[key]) result[key] = { min: 0, max: value }\n        else {\n          if (result[key].max < value) result[key].max = value\n          if (result[key].min > value) result[key].min = value\n        }\n      }\n    })\n  }\n  return result\n}\nexport function computeFullArtRange(arts: ArtifactsBySlot): DynMinMax {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  return addArtRange([\n    baseRange,\n    ...Object.values(arts.values).map((values) => computeArtRange(values)),\n  ])\n}\nexport function computeNodeRange(\n  nodes: OptNode[],\n  reads: DynMinMax\n): Map<OptNode, MinMax> {\n  const range = new Map<OptNode, MinMax>()\n\n  forEachNodes(\n    nodes,\n    (_) => {},\n    (f) => {\n      const { operation } = f\n      const operands = f.operands.map((op) => range.get(op)!)\n      let current: MinMax\n      switch (operation) {\n        case 'read':\n          if (f.path[0] !== 'dyn')\n            throw new Error(\n              `Found non-dyn path ${f.path} while computing range`\n            )\n          current = reads[f.path[1]] ?? { min: 0, max: 0 }\n          break\n        case 'const':\n          current = computeMinMax([f.value])\n          break\n        case 'add':\n        case 'min':\n        case 'max':\n          current = {\n            min: allOperations[operation](operands.map((x) => x.min)),\n            max: allOperations[operation](operands.map((x) => x.max)),\n          }\n          break\n        case 'res':\n          current = {\n            min: allOperations[operation]([operands[0].max]),\n            max: allOperations[operation]([operands[0].min]),\n          }\n          break\n        case 'mul':\n          current = operands.reduce((accu, current) =>\n            computeMinMax([\n              accu.min * current.min,\n              accu.min * current.max,\n              accu.max * current.min,\n              accu.max * current.max,\n            ])\n          )\n          break\n        case 'threshold':\n          if (operands[0].min >= operands[1].max) current = operands[2]\n          else if (operands[0].max < operands[1].min) current = operands[3]\n          else current = computeMinMax([], [operands[2], operands[3]])\n          break\n        case 'sum_frac': {\n          const [x, c] = operands,\n            sum = { min: x.min + c.min, max: x.max + c.max }\n          if (sum.min <= 0 && sum.max >= 0)\n            current =\n              x.min <= 0 && x.max >= 0\n                ? { min: NaN, max: NaN }\n                : { min: -Infinity, max: Infinity }\n          // TODO: Check this\n          else\n            current = computeMinMax([\n              x.min / sum.min,\n              x.min / sum.max,\n              x.max / sum.min,\n              x.max / sum.max,\n            ])\n          break\n        }\n        default:\n          assertUnreachable(operation)\n      }\n      range.set(f, current)\n    }\n  )\n  return range\n}\nfunction computeMinMax(\n  values: readonly number[],\n  minMaxes: readonly MinMax[] = []\n): MinMax {\n  const max = Math.max(...values, ...minMaxes.map((x) => x.max))\n  const min = Math.min(...values, ...minMaxes.map((x) => x.min))\n  return { min, max }\n}\n\nexport function filterArts(\n  arts: ArtifactsBySlot,\n  filters: RequestFilter\n): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objectKeyMap(allSlotKeys, (slot) => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case 'id':\n          return arts.values[slot].filter((art) => filter.ids.has(art.id))\n        case 'exclude':\n          return arts.values[slot].filter((art) => !filter.sets.has(art.set!))\n        case 'required':\n          return arts.values[slot].filter((art) => filter.sets.has(art.set!))\n      }\n    }),\n  }\n}\n\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\n  return builds\n    .flatMap((x) => x)\n    .sort((a, b) => b.value - a.value)\n    .slice(0, maxNum)\n}\nexport function mergePlot(plots: PlotData[]): PlotData {\n  let scale = 0.01\n  const reductionScaling = 2,\n    maxCount = 1500\n  let keys = new Set(\n    plots.flatMap((x) =>\n      Object.values(x).map((v) => Math.round(v.plot! / scale))\n    )\n  )\n  while (keys.size > maxCount) {\n    scale *= reductionScaling\n    keys = new Set([...keys].map((key) => Math.round(key / reductionScaling)))\n  }\n  const result: PlotData = {}\n  for (const plot of plots)\n    for (const build of Object.values(plot)) {\n      const x = Math.round(build.plot! / scale) * scale\n      if (!result[x] || result[x]!.value < build.value) result[x] = build\n    }\n  return result\n}\n\nexport function countBuilds(arts: ArtifactsBySlot): number {\n  return allSlotKeys.reduce(\n    (_count, slot) => _count * arts.values[slot].length,\n    1\n  )\n}\n\nexport function* filterFeasiblePerm(\n  filters: Iterable<RequestFilter>,\n  _artSets: ArtifactsBySlot\n): Iterable<RequestFilter> {\n  const artSets = objectMap(\n    _artSets.values,\n    (values) => new Set(values.map((v) => v.set))\n  )\n  filter_loop: for (const filter of filters) {\n    for (const [slot, f] of Object.entries(filter)) {\n      const available = artSets[slot]!\n      switch (f.kind) {\n        case 'required':\n          if ([...f.sets].every((s) => !available.has(s))) continue filter_loop\n          break\n        case 'exclude':\n          if ([...available].every((s) => f.sets.has(s!))) continue filter_loop\n          break\n        case 'id':\n          break\n      }\n    }\n    yield filter\n  }\n}\nexport function exclusionToAllowed(\n  exclusion: number[] | undefined\n): Set<number> {\n  return new Set(\n    exclusion?.includes(2)\n      ? exclusion.includes(4)\n        ? [0, 1]\n        : [0, 1, 4, 5]\n      : exclusion?.includes(4)\n      ? [0, 1, 2, 3]\n      : [0, 1, 2, 3, 4, 5]\n  )\n}\n/** A *disjoint* set of `RequestFilter` satisfying the exclusion rules */\nexport function* artSetPerm(\n  exclusion: ArtSetExclusion,\n  _artSets: ArtifactSetKey[]\n): Iterable<RequestFilter> {\n  /**\n   * This generation algorithm is separated into two parts:\n   * - \"Shape\" generation\n   *   - It first generates all build \"shapes\", e.g., AABBC, ABBCD\n   *   - It then filters the generated shapes according to the rainbow exclusion, e.g., removes ABBCD if excluding 3 rainbows\n   *   - It then merges the remaining shapes into wildcards, e.g. AABAA + AABAB + AABAC => AABA*\n   * - Shape filling\n   *   - From the given shapes, it tries to fill in all non-rainbow slots, e.g., slots A and B of AABBC, with actual artifacts\n   *   - It then fills the rainbow slots, e.g., slot C of AABBC while ensuring the exclusion rule of each sets\n   */\n  const artSets = [...new Set(_artSets)],\n    allowedRainbows = exclusionToAllowed(exclusion.rainbow)\n  let shapes: number[][] = []\n  function populateShapes(\n    current: number[],\n    list: Set<number>,\n    rainbows: number[]\n  ) {\n    if (current.length === 5) {\n      if (allowedRainbows.has(rainbows.length)) shapes.push(current)\n      return\n    }\n    for (const i of list)\n      populateShapes(\n        [...current, i],\n        list,\n        rainbows.filter((j) => j !== i)\n      )\n    populateShapes(\n      [...current, current.length],\n      new Set([...list, current.length]),\n      [...rainbows, current.length]\n    )\n  }\n  populateShapes([0], new Set([0]), [0])\n  function indexOfShape(shape: number[], replacing: number) {\n    if (range(replacing + 1, 4).some((i) => shape[i] !== 5)) return undefined\n    shape = [...shape]\n    shape[replacing] = 5\n    return shape.reduce((a, b) => a * 6 + b, 0)\n  }\n  for (let replacing = 4; replacing >= 0; replacing--) {\n    const required: Map<number, number> = new Map()\n    for (const shape of shapes) {\n      const id = indexOfShape(shape, replacing)\n      if (id === undefined) continue\n      required.set(\n        id,\n        (required.get(id) ?? new Set(shape.slice(0, replacing)).size + 1) - 1\n      )\n    }\n    for (const [id, remaining] of required.entries()) {\n      if (remaining === 0) {\n        const shape = [\n          ...shapes.find((shape) => indexOfShape(shape, replacing) === id)!,\n        ]\n        shape[replacing] = 5\n        shapes = shapes.filter((shape) => indexOfShape(shape, replacing) !== id)\n        shapes.push(shape)\n      }\n    }\n  }\n\n  // Shapes are now calculated and merged, proceed to fill in the sets\n\n  const noFilter = { kind: 'exclude' as const, sets: new Set<ArtifactSetKey>() }\n  const result: RequestFilter = objectKeyMap(allSlotKeys, (_) => noFilter)\n\n  const counts = {\n    ...objectMap(exclusion, (_) => 0),\n    ...objectKeyMap(artSets, (_) => 0),\n  }\n  const allowedCounts = objectMap(exclusion, exclusionToAllowed)\n\n  function* check(shape: number[]) {\n    const used: Set<ArtifactSetKey> = new Set(),\n      rainbows: number[] = []\n    let groupped: number[][] = []\n    for (const i of shape) {\n      groupped.push([])\n      if (i === 5) rainbows.push(groupped.length - 1)\n      else groupped[i].push(groupped.length - 1)\n    }\n    groupped = groupped\n      .filter((v) => v.length)\n      .sort((a, b) => b.length - a.length)\n    let usableRainbows = rainbows.length\n\n    // Inception.. because js doesn't like functions inside a for-loop\n    function* check(i: number) {\n      if (i === groupped.length) return yield* check_free(0)\n\n      for (const set of artSets) {\n        if (used.has(set)) continue\n        const length = groupped[i].length,\n          allowedSet = allowedCounts[set]\n        let requiredRainbows = 0\n\n        if (allowedSet && !allowedSet.has(length)) {\n          // Look ahead and see if we have enough rainbows to fill to the next `allowedSet` if we use the current set\n          requiredRainbows =\n            (range(length + 1, 5).find((l) => allowedSet.has(l)) ?? 6) - length\n          if (requiredRainbows > usableRainbows) continue // Not enough rainbows. Next..\n        }\n\n        used.add(set)\n        counts[set] = groupped[i].length\n        groupped[i].forEach(\n          (j) =>\n            (result[allSlotKeys[j]] = {\n              kind: 'required',\n              sets: new Set([set]),\n            })\n        )\n        usableRainbows -= requiredRainbows\n\n        yield* check(i + 1)\n\n        usableRainbows += requiredRainbows\n        counts[set] = 0\n        used.delete(set)\n      }\n    }\n    // We separate filling rainbow slots from groupped slots because it has an entirely\n    // different set of rules regarding what can be filled and what states to be kept.\n    function* check_free(i: number) {\n      const remaining = rainbows.length - i,\n        isolated: ArtifactSetKey[] = [],\n        missing: ArtifactSetKey[] = [],\n        rejected: ArtifactSetKey[] = []\n      let required = 0\n      for (const set of artSets) {\n        const allowedSet = allowedCounts[set],\n          count = counts[set]\n        if (!allowedSet) continue\n        if (range(1, remaining).every((j) => !allowedSet.has(count + j)))\n          rejected.push(set)\n        else if (!allowedSet.has(count)) {\n          required += [...allowedSet].find((x) => x > count)! - count\n          missing.push(set)\n        } else if (range(0, remaining).some((j) => !allowedSet.has(count + j)))\n          isolated.push(set)\n      }\n      if (required > remaining) return\n      if (i === rainbows.length) {\n        yield { ...result }\n        return\n      }\n      if (required === remaining) {\n        for (const set of missing) {\n          counts[set]++\n          result[allSlotKeys[rainbows[i]]] = {\n            kind: 'required',\n            sets: new Set([set]),\n          }\n          yield* check_free(i + 1)\n          counts[set]--\n        }\n        return\n      }\n      for (const set of [...isolated, ...missing]) {\n        counts[set]++\n        result[allSlotKeys[rainbows[i]]] = {\n          kind: 'required',\n          sets: new Set([set]),\n        }\n        yield* check_free(i + 1)\n        counts[set]--\n      }\n      result[allSlotKeys[rainbows[i]]] = {\n        kind: 'exclude',\n        sets: new Set([...missing, ...rejected, ...isolated]),\n      }\n      yield* check_free(i + 1)\n    }\n    yield* check(0)\n  }\n  for (const shape of shapes) yield* check(shape)\n}\n\nexport type RequestFilter = StrictDict<\n  SlotKey,\n  | { kind: 'required'; sets: Set<ArtifactSetKey> }\n  | { kind: 'exclude'; sets: Set<ArtifactSetKey> }\n  | { kind: 'id'; ids: Set<string> }\n>\n\nexport type DynStat = { [key in string]: number }\nexport type ArtifactBuildData = {\n  id: string\n  set?: ArtifactSetKey\n  values: DynStat\n}\nexport type ArtifactsBySlot = {\n  base: DynStat\n  values: StrictDict<SlotKey, ArtifactBuildData[]>\n}\n\nexport type PlotData = Dict<number, Build>\nexport interface Build {\n  value: number\n  plot?: number\n  artifactIds: string[]\n}\n\nexport type DynMinMax = { [key in string]: MinMax }\nexport type MinMax = { min: number; max: number }\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { customMapFormula, forEachNodes } from '../../Formula/internal'\nimport type { OptNode } from '../../Formula/optimization'\nimport { allOperations } from '../../Formula/optimization'\nimport type { ConstantNode } from '../../Formula/type'\nimport { prod, threshold } from '../../Formula/utils'\nimport { assertUnreachable, cartesian } from '../../Util/Util'\nimport type { ArtifactsBySlot, MinMax } from '../common'\nimport { computeFullArtRange, computeNodeRange } from '../common'\nimport type { Linear } from './linearUB'\n\n/**\n * With xi being the variables and pi(x1, x2, ...) being polynomials on xi\n *    LinTerm  = $c + w1*x1 + w2*x2 + ...\n *    PolyProd = $k * p1 * p2 * ...\n *    PolySum  = $c + p1 + p2 + ...\n *\n * $c is used as additive constant, $k is used as multiplicative constant.\n */\nexport type PolynomialWithBounds = PolyProd | PolySum | LinTerm\ntype LinTerm = { type: 'lin'; lin: Linear; min: number; max: number }\ntype PolyProd = {\n  type: 'prod'\n  terms: PolynomialWithBounds[]\n  $k: number\n  min: number\n  max: number\n}\ntype PolySum = {\n  type: 'sum'\n  terms: PolynomialWithBounds[]\n  $c: number\n  min: number\n  max: number\n}\n\nfunction constP(n: number): LinTerm {\n  return { type: 'lin', lin: { $c: n }, min: n, max: n }\n}\nfunction readP(k: string, minmax: MinMax): LinTerm {\n  return { type: 'lin', lin: { [k]: 1, $c: 0 }, ...minmax }\n}\nfunction sumP(...terms: (PolynomialWithBounds | number)[]): PolySum {\n  const c = (terms.filter((v) => typeof v === 'number') as number[]).reduce(\n    (a, b) => a + b,\n    0\n  )\n  const poly = terms.filter(\n    (v) => typeof v !== 'number'\n  ) as PolynomialWithBounds[]\n  return {\n    type: 'sum',\n    terms: poly,\n    $c: c,\n    min: poly.reduce((a, { min }) => a + min, c),\n    max: poly.reduce((a, { max }) => a + max, c),\n  }\n}\nfunction prodP(...terms: (PolynomialWithBounds | number)[]): PolyProd {\n  const k = (terms.filter((v) => typeof v === 'number') as number[]).reduce(\n    (a, b) => a * b,\n    1\n  )\n  const poly = terms.filter(\n    (v) => typeof v !== 'number'\n  ) as PolynomialWithBounds[]\n  const minMax = poly.reduce(\n    ({ min: min1, max: max1 }, { min: min2, max: max2 }) => {\n      return {\n        min: Math.min(min1 * min2, min1 * max2, max1 * min2, max1 * max2),\n        max: Math.max(min1 * min2, min1 * max2, max1 * min2, max1 * max2),\n      }\n    },\n    { min: k, max: k }\n  )\n  return { type: 'prod', terms: poly, $k: k, ...minMax }\n}\n\nfunction slopePoint(\n  slope: number,\n  x0: number,\n  y0: number,\n  poly: PolynomialWithBounds\n): PolynomialWithBounds {\n  return sumP(y0 - slope * x0, prodP(slope, poly))\n}\nfunction interpolate(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  poly: PolynomialWithBounds,\n  upper: boolean\n): PolynomialWithBounds {\n  if (Math.abs(x0 - x1) < 1e-10)\n    return constP(upper ? Math.max(y0, y1) : Math.min(y0, y1))\n  return slopePoint((y1 - y0) / (x1 - x0), x0, y0, poly)\n}\n\nexport function polyUB(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot\n): SumOfMonomials[] {\n  const minMaxes = new Map<OptNode, MinMax>()\n  forEachNodes(\n    nodes,\n    (f) => {\n      const { operation } = f\n      if (operation === 'mul') minMaxes.set(f, { min: NaN, max: NaN })\n      switch (operation) {\n        case 'mul':\n        case 'min':\n        case 'max':\n        case 'threshold':\n        case 'res':\n        case 'sum_frac':\n          f.operands.forEach((op) => minMaxes.set(op, { min: NaN, max: NaN }))\n      }\n    },\n    (_) => _\n  )\n  const statMinMax = computeFullArtRange(arts)\n  const nodeRanges = computeNodeRange([...minMaxes.keys()], statMinMax)\n  for (const [node, minMax] of nodeRanges.entries()) minMaxes.set(node, minMax)\n\n  const upper = 'u',\n    lower = 'l',\n    exact = 'e'\n  type Context = typeof upper | typeof lower | typeof exact\n  const poly = customMapFormula<Context, PolynomialWithBounds, OptNode>(\n    nodes,\n    upper,\n    (f, context, _map) => {\n      const { operation } = f\n      const map: (op: OptNode, c?: Context) => PolynomialWithBounds = (\n        op,\n        c = context\n      ) => _map(op, c)\n      const oppositeContext = context === upper ? lower : upper\n\n      switch (operation) {\n        case 'const':\n          return constP(f.value)\n        case 'read':\n          return readP(f.path[1], minMaxes.get(f)!)\n        case 'add':\n          return sumP(...f.operands.map((op) => map(op)))\n        case 'mul': {\n          if (context === exact)\n            return prodP(...f.operands.map((op) => map(op)))\n          const { min: minf, max: maxf } = minMaxes.get(f)!\n          if (minf === maxf) return constP(minf) // Handles zero coeff\n          const zeroCrossing =\n            minf * maxf < 0 ||\n            f.operands.some((op) => {\n              const { min, max } = minMaxes.get(op)!\n              return min * max < 0\n            })\n          if (zeroCrossing) return map(f, exact)\n\n          const signf = minf === 0 ? maxf : minf\n          const op = allOperations[operation]\n          const k = op(\n            f.operands\n              .filter((op) => op.operation === 'const')\n              .map((c) => (c as ConstantNode<number>).value)\n          )\n          const polys = f.operands\n            .filter((op) => op.operation !== 'const')\n            .map((op) => {\n              const { min, max } = minMaxes.get(op)!\n              const sign = min === 0 ? max : min\n              const ctx = signf * sign > 0 ? context : oppositeContext\n              const p = map(op, ctx)\n\n              if (\n                (ctx === lower && max > 0 && p.min < -min) ||\n                (ctx === upper && min < 0 && p.max > -max)\n              )\n                throw new PolyError(\n                  'Unallowed large crossing post approximation',\n                  operation\n                )\n\n              return p\n            })\n          return prodP(k, ...polys)\n        }\n        case 'min':\n        case 'max': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          const op = allOperations[operation]\n          const xs = f.operands.filter((op) => op.operation !== 'const'),\n            [xOp] = xs\n          if (xs.length !== 1) throw new PolyError('Multivariate', operation)\n\n          const x = map(xOp),\n            c = op(\n              f.operands\n                .filter((op) => op.operation === 'const')\n                .map((c) => (c as ConstantNode<number>).value)\n            )\n          if (\n            (operation === 'max' && context === lower) ||\n            (operation === 'min' && context === upper)\n          )\n            return x\n          const { min, max } = minMaxes.get(xOp)!,\n            yMin = op([min, c]),\n            yMax = op([max, c])\n          return interpolate(min, yMin, max, yMax, x, context === upper)\n        }\n        case 'res': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          if (context === lower)\n            throw new PolyError('Unsupported direction', operation)\n          const op = allOperations[operation]\n          const [xOp] = f.operands,\n            { min, max } = minMaxes.get(xOp)!\n          const x = map(xOp, oppositeContext)\n          // Linear region 1 - base/2 or concave region with peak at base = 0\n          if (min < 0 && max < 1.75) return sumP(1, prodP(-0.5, x))\n          // Clamp `min` to guarantee upper bound\n          else\n            return interpolate(\n              min,\n              op([min]),\n              max,\n              op([max]),\n              x,\n              context === upper\n            )\n        }\n        case 'sum_frac': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          if (context === lower)\n            throw new PolyError('Unsupported direction', operation)\n          const [xOp, cOp] = f.operands\n          if (cOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          const x = map(xOp),\n            c = cOp.value,\n            { min, max } = minMaxes.get(xOp)!\n          if (min <= -c)\n            throw new PolyError('Unallowed negative argument', operation)\n          const loc = Math.sqrt((min + c) * (max + c))\n          return slopePoint(c / (loc + c) / (loc + c), loc, loc / (loc + c), x)\n        }\n        case 'threshold': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          const [vOp, tOp, pOp, fOp] = f.operands\n          if (tOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          const { min, max } = minMaxes.get(vOp)!\n          if (min >= tOp.value) return map(pOp)\n          if (max < tOp.value) return map(fOp)\n\n          if (fOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          if (pOp.operation !== 'const') {\n            if (fOp.value !== 0)\n              throw new PolyError('Unsupported pattern', operation)\n\n            const threshOp = threshold(vOp, tOp, 1, fOp),\n              mulOp = prod(threshOp, pOp)\n            // Populate `minMaxes` to ensure consistency\n            const { min, max } = minMaxes.get(pOp)!\n            minMaxes.set(threshOp, { min: 0, max: 1 })\n            minMaxes.set(mulOp, {\n              min: Math.min(min, 0),\n              max: Math.max(max, 0),\n            })\n            return map(mulOp)\n          }\n          const thresh = tOp.value,\n            pass = pOp.value,\n            fail = fOp.value\n          const isFirstHalf = pass > fail === (context === upper)\n\n          const v = map(vOp, isFirstHalf ? upper : lower)\n          if (isFirstHalf) {\n            const slope = (pass - fail) / (thresh - min)\n            return slopePoint(slope, thresh, pass, v)\n          }\n          // not first half -> return const(fail)\n          // Can also interpolate slopePoint on 2nd half, but I choose not to\n          return constP(fail)\n        }\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n\n  return poly.map((p) => expandPoly(p))\n}\n\nexport type SumOfMonomials = Monomial[]\ntype Monomial = {\n  $k: number\n  terms: string[]\n}\nfunction constM(v: number): Monomial {\n  return { $k: v, terms: [] }\n}\nfunction weightedReadM(key: string, v: number): Monomial {\n  return { $k: v, terms: [key] }\n}\nfunction sumM(...monomials: Monomial[][]): Monomial[] {\n  return monomials.flat()\n}\nfunction prodM(...monomials: Monomial[][]): Monomial[] {\n  return cartesian(...monomials).map((monos) =>\n    monos.reduce(\n      (ret, nxt) => {\n        ret.$k *= nxt.$k\n        ret.terms.push(...nxt.terms)\n        return ret\n      },\n      { $k: 1, terms: [] }\n    )\n  )\n}\nfunction foldLikeTerms(mon: Monomial[]): Monomial[] {\n  mon.forEach((m) => m.terms.sort())\n  mon.sort(({ terms: termsA }, { terms: termsB }) => {\n    if (termsA.length !== termsB.length) return termsA.length - termsB.length\n    for (let i = 0; i < termsA.length; i++) {\n      if (termsA[i] !== termsB[i]) return termsA[i] < termsB[i] ? -1 : +1\n    }\n    return 0\n  })\n\n  for (let i = mon.length - 2; i >= 0; i--) {\n    if (mon[i].$k === 0) {\n      mon.splice(i, 1)\n      continue\n    }\n    const a = mon[i].terms\n    const b = mon[i + 1].terms\n    if (a.length !== b.length) continue\n    if (a.every((ai, i) => ai === b[i])) {\n      mon[i].$k = mon[i].$k + mon[i + 1].$k\n      mon.splice(i + 1, 1)\n    }\n  }\n  return mon\n}\nfunction expandPoly(node: PolynomialWithBounds): SumOfMonomials {\n  function toExpandedPoly(n: PolynomialWithBounds): Monomial[] {\n    switch (n.type) {\n      case 'lin':\n        return Object.entries(n.lin)\n          .filter(([_, v]) => v !== 0)\n          .map(([k, v]) => {\n            if (k === '$c') return constM(v)\n            return weightedReadM(k, v)\n          })\n      case 'sum':\n        return sumM(...n.terms.map((t) => toExpandedPoly(t)), [constM(n.$c)])\n      case 'prod':\n        return prodM(...n.terms.map((t) => toExpandedPoly(t)), [constM(n.$k)])\n    }\n  }\n\n  return foldLikeTerms(toExpandedPoly(node))\n}\n\nclass PolyError extends Error {\n  constructor(cause: string, operation: string) {\n    super(\n      `Found ${cause} in ${operation} node when generating polynomial upper bound`\n    )\n  }\n}\n","// Matrix convention is row-major, indexed A_{ij} = A[i][j]\ntype Pivot = { i: number; j: number }\nconst zero = 1e-8 // Small number equivalent to 0 for numerical instability\n\n/** Checks that all constraints are satisfied (Ax <= b) */\nexport function isFeasible(Ab: number[][], x: number[]): boolean {\n  const b = x.length\n  return Ab.every(\n    (row) => x.reduce((tot, xi, i) => tot + xi * row[i], 0) <= row[b] + zero\n  )\n}\n\n/**\n * Solve a Linear Program defined by:\n *              min  c^T x\n *               x\n *   Subject to:     Ax <= b\n *                    x >= 0\n *\n * Implemented according to the Simplex Method (Sec 4) of:\n *   Ferguson, https://www.math.ucla.edu/~tom/LP.pdf\n *\n * Does not implement any cycle detection, though that *shouldnt* be a problem for GO's use\n *   case. This algorithm will always return a feasible solution, though it may be suboptimal.\n *\n * @param c        Objective vector\n * @param Ab       Constraints matrix with thresholds. Inputted in block form [A, b]\n * @returns        a valid solution x, optimal if everything went well.\n */\nexport function solveLP(c: number[], Ab: number[][]) {\n  const rows = Ab.length + 1\n  const cols = Ab[0].length\n\n  const tableau = Array(rows)\n    .fill(0)\n    .map((_) => Array(cols).fill(0))\n  Ab.forEach((Ai, i) => Ai.forEach((Aij, j) => (tableau[i][j] = Aij)))\n  c.forEach((cj, j) => (tableau[rows - 1][j] = cj))\n\n  const pivotHistory: Pivot[] = [] // Keep track of all chosen pivots for backtracking later\n\n  while (tableau.some((t, i) => i < rows - 1 && t[cols - 1] < -zero)) {\n    const piv = findPiv2(tableau)\n    pivotHistory.push(piv)\n    pivotInplace(tableau, piv)\n  }\n\n  while (tableau[rows - 1].some((t, j) => j < cols - 1 && t < -zero)) {\n    const piv = findPiv1(tableau)\n    pivotHistory.push(piv)\n    pivotInplace(tableau, piv)\n  }\n\n  const xOpt = c.map((_, i) => backtrack(tableau, pivotHistory, i))\n  if (!isFeasible(Ab, xOpt)) throw Error('COMPUTED SOLUTION IS NOT FEASIBLE')\n  return xOpt\n}\n\n/** Standard `pivot` operation on LPs */\nfunction pivotInplace(A: number[][], { i, j }: Pivot) {\n  const Aij = A[i][j]\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    for (let k = 0; k < A[0].length; k++) {\n      if (k === j) continue\n      A[h][k] -= (A[i][k] * A[h][j]) / Aij\n    }\n  }\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    A[h][j] = -A[h][j] / Aij\n  }\n  for (let k = 0; k < A[0].length; k++) {\n    if (k === j) continue\n    A[i][k] = A[i][k] / Aij\n  }\n  A[i][j] = 1 / Aij\n}\n\n/** Find a pivot according to Case 1 (Ferguson p23) */\nfunction findPiv1(A: number[][]) {\n  const r = A.length,\n    c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let j = 0; j < c - 1; j++) {\n    if (A[r - 1][j] >= -zero) continue\n    for (let i = 0; i < r - 1; i++) {\n      if (A[i][j] > zero) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('UNBOUNDED FEASIBLE')\n  }\n  if (minloc.i < 0) throw Error('NO PIVOTS (done)')\n  return { i: minloc.i, j: minloc.j }\n}\n\n/** Find a pivot according to Case 2 (Ferguson p24) */\nfunction findPiv2(A: number[][]) {\n  const r = A.length,\n    c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let i = 0; i < r - 1; i++) {\n    if (A[i][c - 1] >= -zero) continue\n    for (let j = 0; j < c - 1; j++) {\n      if (A[i][j] < -zero) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('INFEASIBLE')\n    return { i: minloc.i, j: minloc.j }\n  }\n  throw Error('NO PIVOTS (done)')\n}\n\n/** Backtracking algorithm to find solution vector */\nfunction backtrack(tableau: number[][], pivotHistory: Pivot[], targ: number) {\n  let side = 1 // 0 left, 1 right\n  pivotHistory.forEach(({ i, j }) => {\n    if (side === 1 && j === targ) {\n      targ = i\n      side = 0\n    } else if (side === 0 && i === targ) {\n      targ = j\n      side = 1\n    }\n  })\n\n  const ncol = tableau[0].length\n  return side === 0 ? tableau[targ][ncol - 1] : 0\n}\n","import type { OptNode } from '../../Formula/optimization'\nimport { assertUnreachable, cartesian } from '../../Util/Util'\nimport type { ArtifactsBySlot, DynStat, MinMax } from '../common'\nimport { computeFullArtRange } from '../common'\nimport { polyUB } from './polyUB'\nimport { solveLP } from './solveLP'\n\nexport type Linear = DynStat & { $c: number }\n\nfunction weightedSum(\n  ...entries: readonly (readonly [number, Linear])[]\n): Linear {\n  const result = { $c: 0 }\n  for (const [weight, entry] of entries)\n    for (const [k, v] of Object.entries(entry))\n      result[k] = (result[k] ?? 0) + weight * v\n  return result\n}\n\nexport function linearUB(nodes: OptNode[], arts: ArtifactsBySlot): Linear[] {\n  const polys = polyUB(nodes, arts)\n  const minMax = computeFullArtRange(arts)\n\n  return polys.map((poly) =>\n    weightedSum(\n      ...poly.map((mon) => {\n        const bounds = mon.terms.map((key) => minMax[key])\n        const { w, $c } = linbound(bounds, mon.$k >= 0 ? 'upper' : 'lower')\n        const linboi: Linear = { $c }\n        mon.terms.forEach((key, i) => (linboi[key] = w[i] + (linboi[key] ?? 0)))\n        return [mon.$k, linboi] as readonly [number, Linear]\n      })\n    )\n  )\n}\n\n/**\n * Constructs a linear upper/lower bound for a monomial on a bounded domain using an LP.\n *\n * Monomial is assumed to be\n *    m(x) = x1 * x2 * ... * xn\n * on bounded domain\n *    min_1 <= x1 <= max_1\n *    min_2 <= x2 <= max_2\n *    ...\n *    min_n <= xn <= max_n\n *\n * @param bounds List of min & max bounds for each xi\n * @returns A linear function L(x) = w . x + $c\n *            satisfying      m(x) <= L(x) <= m(x) + err (resp. m(x) - err <= L(x) <= m(x))\n */\nfunction linbound(\n  bounds: MinMax[],\n  direction: 'upper' | 'lower' = 'upper'\n): { w: number[]; $c: number; err: number } {\n  if (bounds.length === 0) return { w: [], $c: 1, err: 0 } // vacuous product is 0\n  const nVar = bounds.length\n\n  // Re-scale bounds to [0, 1] for numerical stability.\n  const boundScale = bounds.map(({ min, max }) => Math.max(-min, max))\n  const scaleProd = boundScale.reduce((prod, v) => prod * v, 1)\n  bounds = bounds.map(({ min, max }, i) => ({\n    min: min / boundScale[i],\n    max: max / boundScale[i],\n  }))\n  // Setting up the linear program in terms of constraints.\n  //   cartesian(bounds) loops 2^nVar times\n  const cons = cartesian(...bounds.map(({ min, max }) => [min, max])).flatMap(\n    (coords) => {\n      const prod = coords.reduce((prod, v) => prod * v, 1)\n      const sum = coords.reduce((sum, v) => sum + v, 0)\n      switch (direction) {\n        case 'upper':\n          return [\n            [...coords, -1, 0, sum - prod - nVar],\n            [...coords.map((v) => -v), 1, -1, nVar + prod - sum],\n          ]\n        case 'lower':\n          return [\n            [...coords.map((v) => -v), -1, 0, prod - sum - nVar],\n            [...coords, 1, -1, nVar + sum - prod],\n          ]\n        default:\n          assertUnreachable(direction)\n      }\n    }\n  )\n\n  const objective = [...bounds.map((_) => 0), 0, 1]\n  try {\n    const soln = solveLP(objective, cons)\n    switch (direction) {\n      case 'upper':\n        return {\n          w: soln\n            .slice(0, nVar)\n            .map((wi, i) => ((1 - wi) * scaleProd) / boundScale[i]),\n          $c: scaleProd * (soln[nVar] - nVar),\n          err: scaleProd * soln[nVar + 1],\n        }\n      case 'lower':\n        return {\n          w: soln\n            .slice(0, nVar)\n            .map((wi, i) => ((1 - wi) * scaleProd) / boundScale[i]),\n          $c: scaleProd * (nVar - soln[nVar]),\n          err: scaleProd * soln[nVar + 1],\n        }\n      default:\n        assertUnreachable(direction)\n    }\n  } catch (e) {\n    console.log('ERROR on bounds', bounds)\n    console.log('Possibly numerical instability issue.')\n    console.log(e)\n    throw e\n  }\n}\n","import type { Interim, Setup } from '..'\nimport type { OptNode } from '../../Formula/optimization'\nimport type { ArtifactSlotKey } from '@genshin-optimizer/consts'\nimport { objectKeyValueMap, objectMap } from '../../Util/Util'\nimport type {\n  ArtifactBuildData,\n  ArtifactsBySlot,\n  DynStat,\n  RequestFilter,\n} from '../common'\nimport { countBuilds, filterArts, pruneAll } from '../common'\nimport type { SplitWorker } from './BackgroundWorker'\nimport { linearUB } from './linearUB'\n\ntype Approximation = {\n  base: number\n  /** optimization target contribution from a given artifact (id) */\n  conts: StrictDict<string, number>\n}\ntype Filter = {\n  nodes: OptNode[]\n  arts: ArtifactsBySlot\n  /**\n   * The contribution of each artifact to the optimization target. The (over)estimated\n   * optimization target value is the sum of contributions of all artifacts in the build.\n   */\n  approxs: Approximation[]\n  maxConts: Record<ArtifactSlotKey, number>[]\n  /** How many times has this filter been splitted */\n  age: number\n  /** Total number of builds in this filter */\n  count: number\n  /** Whether or not this filter is in a valid (calculated) state */\n  calculated?: boolean\n}\nexport class BNBSplitWorker implements SplitWorker {\n  min: number[]\n  nodes: OptNode[]\n  arts: ArtifactsBySlot\n  topN: number\n\n  /**\n   * Filters are not neccessarily in a valid state, i.e., \"calculated\".\n   * We amortize the calculation to 1-per-split so that the calculation\n   * overhead doesn't lead to lag.\n   */\n  filters: Filter[] = []\n  interim: Interim | undefined\n  firstUncalculated = 0\n\n  callback: (interim: Interim) => void\n\n  constructor(\n    { arts, optTarget, constraints, topN }: Setup,\n    callback: (interim: Interim) => void\n  ) {\n    this.arts = arts\n    this.min = [-Infinity, ...constraints.map((x) => x.min)]\n    this.nodes = [optTarget, ...constraints.map((x) => x.value)]\n    this.callback = callback\n    this.topN = topN\n\n    // make sure we can approximate it\n    linearUB(this.nodes, arts)\n  }\n\n  addFilter(filter: RequestFilter): void {\n    const arts = filterArts(this.arts, filter),\n      count = countBuilds(arts)\n    if (count)\n      this.filters.push({\n        nodes: this.nodes,\n        arts,\n        maxConts: [],\n        approxs: [],\n        age: 0,\n        count,\n      })\n  }\n  setThreshold(newThreshold: number): void {\n    if (newThreshold > this.min[0]) {\n      this.min[0] = newThreshold\n      // All calculations become stale\n      this.firstUncalculated = 0\n      this.filters.forEach((filter) => delete filter.calculated)\n    }\n  }\n  *split(filter: RequestFilter, minCount: number): Generator<RequestFilter> {\n    this.addFilter(filter)\n\n    while (this.filters.length) {\n      const filter = this.getApproxFilter(),\n        { arts, count } = filter\n\n      if (count <= minCount) {\n        if (!count) continue\n        if (this.firstUncalculated < this.filters.length)\n          this.calculateFilter(this.firstUncalculated++) // Amortize the filter calculation to 1-per-split\n\n        this.reportInterim(false)\n        yield objectMap(arts.values, (arts) => ({\n          kind: 'id' as const,\n          ids: new Set(arts.map((art) => art.id)),\n        }))\n      } else this.splitOldFilter(filter)\n    }\n\n    this.reportInterim(true)\n  }\n\n  reportInterim(forced = false) {\n    if (this.interim && (this.interim.skipped > 1000000 || forced === true)) {\n      this.callback(this.interim)\n      this.interim = undefined\n    }\n  }\n\n  splitOldFilter({ nodes, arts, approxs, age }: Filter) {\n    /**\n     * Split the artifacts in each slot into high/low main (index 0) contribution along 1/3 of the\n     * contribution range. If the main contribution of a slot is in range 500-2000, the the high-\n     * contibution artifact has contribution of at least 1500, and the rest are low-contribution.\n     */\n    const splitted = objectMap(arts.values, (arts) => {\n      const remaining = arts\n        .map((art) => ({ art, cont: approxs[0].conts[art.id] }))\n        .sort(({ cont: c1 }, { cont: c2 }) => c2 - c1)\n      const minCont = remaining[remaining.length - 1]?.cont ?? 0\n      let contCutoff =\n        remaining.reduce(\n          (accu, { cont }) => accu + cont,\n          -minCont * remaining.length\n        ) / 3\n\n      const index = Math.max(\n        1,\n        remaining.findIndex(({ cont }) => (contCutoff -= cont - minCont) <= 0)\n      )\n      const lowArts = remaining.splice(index).map(({ art }) => art),\n        highArts = remaining.map(({ art }) => art)\n      return {\n        high: {\n          arts: highArts,\n          maxConts: approxs.map((approx) => maxContribution(highArts, approx)),\n        },\n        low: {\n          arts: lowArts,\n          maxConts: approxs.map((approx) => maxContribution(lowArts, approx)),\n        },\n      }\n    })\n    const remaining = Object.keys(splitted),\n      { filters } = this\n    const current: StrictDict<ArtifactSlotKey, ArtifactBuildData[]> = {} as any\n    const currentCont: StrictDict<ArtifactSlotKey, number[]> = {} as any\n    function partialSplit(count: number) {\n      if (!remaining.length) {\n        const maxConts = approxs.map((_, i) =>\n          objectMap(currentCont, (val) => val[i])\n        )\n        const currentArts = { base: arts.base, values: { ...current } }\n        filters.push({\n          nodes,\n          arts: currentArts,\n          maxConts,\n          approxs,\n          age: age + 1,\n          count,\n        })\n        return\n      }\n      const slot = remaining.pop()!,\n        { high, low } = splitted[slot]\n      if (low.arts.length) {\n        current[slot] = low.arts\n        currentCont[slot] = low.maxConts\n        partialSplit(count * low.arts.length)\n      }\n      if (high.arts.length) {\n        current[slot] = high.arts\n        currentCont[slot] = high.maxConts\n        partialSplit(count * high.arts.length)\n      }\n      remaining.push(slot)\n    }\n    partialSplit(1)\n  }\n\n  /** *Precondition*: `this.filters` must not be empty */\n  getApproxFilter(): Filter {\n    this.calculateFilter(this.filters.length - 1)\n    if (this.firstUncalculated > this.filters.length)\n      this.firstUncalculated = this.filters.length\n    return this.filters.pop()!\n  }\n  /** Update calculate on filter at index `i` if not done so already */\n  calculateFilter(i: number): void {\n    let { nodes, arts, maxConts, approxs } = this.filters[i]\n    const { age, count: oldCount, calculated } = this.filters[i]\n    if (calculated) return\n    if (age < 3 || age % 5 === 2) {\n      // Make sure the condition includes initial filter `age === 0`\n      // Either the filter is so early that we can get a good cutoff, or the problem has\n      // gotten small enough that the old approximation becomes inaccurate\n      ;({ nodes, arts } = pruneAll(\n        nodes,\n        this.min,\n        arts,\n        this.topN,\n        {},\n        { pruneNodeRange: true }\n      ))\n      if (Object.values(arts.values).every((x) => x.length)) {\n        approxs = approximation(nodes, arts)\n        maxConts = approxs.map((approx) =>\n          objectMap(arts.values, (val) => maxContribution(val, approx))\n        )\n      }\n    }\n    // Removing artifacts that doesn't meet the required opt target contributions.\n    //\n    // We could actually loop `newValues` computation if the removed artifacts have\n    // the highest contribution in one of the target node as the removal will raise\n    // the required contribution even further. However, once is generally enough.\n    const leadingConts = maxConts.map((cont, i) =>\n      Object.values(cont).reduce(\n        (accu, val) => accu + val,\n        approxs[i].base - this.min[i]\n      )\n    )\n    const newValues = objectMap(arts.values, (arts, slot) => {\n      const requiredConts = leadingConts.map((lc, i) => maxConts[i][slot] - lc)\n      return arts.filter(({ id }) =>\n        approxs.every(({ conts }, i) => conts[id] >= requiredConts[i])\n      )\n    })\n    arts = { base: arts.base, values: newValues }\n    const newCount = countBuilds(arts)\n    if (newCount !== oldCount)\n      if (this.interim) this.interim.skipped += oldCount - newCount\n      else\n        this.interim = {\n          resultType: 'interim',\n          buildValues: undefined,\n          tested: 0,\n          failed: 0,\n          skipped: oldCount - newCount,\n        }\n    this.filters[i] = {\n      nodes,\n      arts,\n      maxConts,\n      approxs,\n      age,\n      count: newCount,\n      calculated: true,\n    }\n  }\n}\n\nfunction maxContribution(\n  arts: ArtifactBuildData[],\n  approximation: Approximation\n): number {\n  return Math.max(...arts.map(({ id }) => approximation.conts[id]!))\n}\nfunction approximation(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot\n): Approximation[] {\n  return linearUB(nodes, arts).map((weight) => ({\n    base: dot(arts.base, weight, weight.$c),\n    conts: objectKeyValueMap(Object.values(arts.values).flat(), (data) => [\n      data.id,\n      dot(data.values, weight, 0),\n    ]),\n  }))\n}\nfunction dot(values: DynStat, lin: DynStat, c: number): number {\n  return Object.entries(values).reduce(\n    (accu, [k, v]) => accu + (lin[k] ?? 0) * v,\n    c\n  )\n}\n","import type { Interim, Setup } from '..'\nimport type { OptNode } from '../../Formula/optimization'\nimport { optimize, precompute } from '../../Formula/optimization'\nimport type {\n  ArtifactBuildData,\n  ArtifactsBySlot,\n  Build,\n  PlotData,\n  RequestFilter,\n} from '../common'\nimport { countBuilds, filterArts, mergePlot, pruneAll } from '../common'\n\nexport class ComputeWorker {\n  builds: Build[] = []\n  buildValues: number[] | undefined = undefined\n  plotData: PlotData | undefined\n  threshold = -Infinity\n  topN: number\n  min: number[]\n\n  arts: ArtifactsBySlot\n  nodes: OptNode[]\n\n  callback: (interim: Interim) => void\n\n  constructor(\n    { arts, optTarget, constraints, plotBase, topN }: Setup,\n    callback: (interim: Interim) => void\n  ) {\n    this.arts = arts\n    this.min = constraints.map((x) => x.min)\n    this.topN = topN\n    this.callback = callback\n    this.nodes = constraints.map((x) => x.value)\n    this.nodes.push(optTarget)\n    if (plotBase) {\n      this.plotData = {}\n      this.nodes.push(plotBase)\n    }\n    this.nodes = optimize(this.nodes, {}, (_) => false)\n  }\n\n  setThreshold(newThreshold: number) {\n    if (this.threshold > newThreshold) this.threshold = newThreshold\n  }\n  compute(filter: RequestFilter) {\n    const { min } = this\n    let preArts = filterArts(this.arts, filter)\n    const totalCount = countBuilds(preArts),\n      oldMaxBuildCount = this.builds.length\n\n    let nodes = this.nodes\n    ;({ nodes, arts: preArts } = pruneAll(\n      nodes,\n      min,\n      preArts,\n      this.topN,\n      {},\n      {\n        pruneArtRange: true,\n        pruneNodeRange: true,\n      }\n    ))\n    const arts = Object.values(preArts.values).sort(\n      (a, b) => a.length - b.length\n    )\n    const compute = precompute(\n      nodes,\n      preArts.base,\n      (f) => f.path[1],\n      arts.length\n    )\n\n    const buffer = Array<ArtifactBuildData>(arts.length)\n    const count = {\n      tested: 0,\n      failed: 0,\n      skipped: totalCount - countBuilds(preArts),\n    }\n\n    const permute = (i: number) => {\n      if (i < 0) {\n        const result = compute(buffer)\n        if (min.every((m, i) => m <= result[i])) {\n          const value = result[min.length],\n            { builds, plotData } = this\n          let build: Build | undefined\n          if (value >= this.threshold) {\n            build = {\n              value,\n              artifactIds: buffer.map((x) => x.id).filter((id) => id),\n            }\n            builds.push(build)\n          }\n          if (plotData) {\n            const x = result[min.length + 1]\n            if (!plotData[x] || plotData[x]!.value < value) {\n              if (!build)\n                build = {\n                  value,\n                  artifactIds: buffer.map((x) => x.id).filter((id) => id),\n                }\n              build.plot = x\n              plotData[x] = build\n            }\n          }\n        } else count.failed += 1\n        return\n      }\n      arts[i].forEach((art) => {\n        buffer[i] = art\n        permute(i - 1)\n      })\n      if (i === 0) {\n        count.tested += arts[0].length\n        if (count.tested > 1 << 16) this.interimReport(count)\n      }\n    }\n\n    permute(arts.length - 1)\n    this.interimReport(count, this.builds.length > oldMaxBuildCount)\n  }\n\n  refresh(force: boolean): void {\n    const { topN } = this\n    if (Object.keys(this.plotData ?? {}).length >= 100000)\n      this.plotData = mergePlot([this.plotData!])\n\n    if (this.builds.length >= 1000 || force) {\n      this.builds = this.builds.sort((a, b) => b.value - a.value).slice(0, topN)\n      this.buildValues = this.builds.map((x) => x.value)\n      this.threshold = Math.max(\n        this.threshold,\n        this.buildValues[topN - 1] ?? -Infinity\n      )\n    }\n  }\n  interimReport(\n    count: { tested: number; failed: number; skipped: number },\n    forced = false\n  ) {\n    this.refresh(forced)\n    this.callback({\n      resultType: 'interim',\n      buildValues: this.buildValues,\n      ...count,\n    })\n    this.buildValues = undefined\n    count.tested = 0\n    count.failed = 0\n    count.skipped = 0\n  }\n}\n","import { allArtifactSlotKeys } from '@genshin-optimizer/consts'\nimport type { Interim, Setup } from '..'\nimport { assertUnreachable } from '../../Util/Util'\nimport type { ArtifactsBySlot, RequestFilter } from '../common'\nimport { countBuilds, filterArts } from '../common'\nimport type { SplitWorker } from './BackgroundWorker'\n\nexport class DefaultSplitWorker implements SplitWorker {\n  arts: ArtifactsBySlot\n  stack: { filter: RequestFilter; count: number; splittedBy: 'id' | 'set' }[] =\n    []\n\n  constructor({ arts }: Setup, _callback: (interim: Interim) => void) {\n    this.arts = arts\n  }\n\n  setThreshold(_newThreshold: number): void {}\n  add(\n    filter: RequestFilter,\n    splittedBy: (typeof this.stack)[number]['splittedBy']\n  ) {\n    this.stack.push({\n      filter,\n      count: countBuilds(filterArts(this.arts, filter)),\n      splittedBy,\n    })\n  }\n  *split(filter: RequestFilter, minCount: number): Generator<RequestFilter> {\n    this.add(filter, 'set')\n    for (let current = this.stack.pop(); current; current = this.stack.pop()) {\n      const { filter, count, splittedBy } = current\n      if (count <= minCount) {\n        yield filter\n        continue\n      }\n\n      switch (splittedBy) {\n        case 'set':\n          this.splitBySet(filter)\n          break\n        case 'id':\n          this.splitByID(filter, count, minCount)\n          break\n        default:\n          assertUnreachable(splittedBy)\n      }\n    }\n  }\n\n  splitBySet(filter: RequestFilter): void {\n    const arts = filterArts(this.arts, filter)\n    const candidates = allArtifactSlotKeys\n      .map((slot) => ({\n        slot,\n        sets: new Set(arts.values[slot].map((x) => x.set)),\n      }))\n      .filter(({ sets }) => sets.size > 1)\n\n    if (!candidates.length) return this.add(filter, 'id')\n\n    const { sets, slot } = candidates.reduce((a, b) =>\n      a.sets.size < b.sets.size ? a : b\n    )\n    sets.forEach((set) =>\n      this.add(\n        { ...filter, [slot]: { kind: 'required', sets: new Set([set]) } },\n        'set'\n      )\n    )\n  }\n  splitByID(filter: RequestFilter, count: number, minCount: number): void {\n    const arts = filterArts(this.arts, filter)\n    const { slot, length } = allArtifactSlotKeys\n      .map((slot) => ({ slot, length: arts.values[slot].length }))\n      .filter((x) => x.length > 1)\n      // We always have entries because `count > 1`\n      .reduce((a, b) => (a.length < b.length ? a : b))\n\n    const numChunks = Math.ceil(count / minCount)\n    const boundedNumChunks = Math.min(numChunks, length)\n    const chunk = Array(boundedNumChunks)\n      .fill(0)\n      .map((_) => new Set<string>())\n    arts.values[slot].forEach(({ id }, i) =>\n      chunk[i % boundedNumChunks].add(id)\n    )\n    chunk.forEach((ids) =>\n      this.add({ ...filter, [slot]: { kind: 'id', ids } }, 'id')\n    )\n  }\n}\n","import type { WorkerCommand, WorkerResult } from '..'\nimport { assertUnreachable } from '../../Util/Util'\nimport type { RequestFilter } from '../common'\nimport {\n  artSetPerm,\n  countBuilds,\n  filterArts,\n  filterFeasiblePerm,\n} from '../common'\nimport { BNBSplitWorker } from './BNBSplitWorker'\nimport { ComputeWorker } from './ComputeWorker'\nimport { DefaultSplitWorker } from './DefaultSplitWorker'\n\ndeclare function postMessage(command: WorkerCommand | WorkerResult): void\n\nlet splitWorker: SplitWorker, computeWorker: ComputeWorker\n\nasync function handleEvent(e: MessageEvent<WorkerCommand>): Promise<void> {\n  const { data } = e,\n    { command } = data\n  switch (command) {\n    case 'split':\n      for (const filter of splitWorker.split(\n        data.filter,\n        data.maxIterateSize\n      )) {\n        postMessage({ command: 'iterate', filter })\n        // Suspend here in case a `threshold` is sent over\n        //\n        // Make sure to use task-based mechanisms such as `setTimeout` so that\n        // this function suspends until the next event loop. If we instead use\n        // microtask-based ones such as `Promise.resolved`, the suspension will\n        // not be long enough.\n        await new Promise((r) => setTimeout(r))\n      }\n      break\n    case 'iterate':\n      computeWorker.compute(data.filter)\n      break\n    case 'threshold': {\n      splitWorker.setThreshold(data.threshold)\n      computeWorker.setThreshold(data.threshold)\n      return // This is a fire-and-forget command\n    }\n    case 'finalize': {\n      computeWorker.refresh(true)\n      const { builds, plotData } = computeWorker\n      postMessage({ resultType: 'finalize', builds, plotData })\n      break\n    }\n    case 'count': {\n      const { exclusion, maxIterateSize } = data,\n        arts = computeWorker.arts\n      const perms = filterFeasiblePerm(\n        artSetPerm(exclusion, [\n          ...new Set(\n            Object.values(arts.values).flatMap((x) => x.map((x) => x.set!))\n          ),\n        ]),\n        arts\n      )\n      let count = 0\n      for (const filter of perms) {\n        postMessage({ command: 'split', filter, maxIterateSize })\n        count += countBuilds(filterArts(arts, filter))\n      }\n      postMessage({ resultType: 'count', count })\n      break\n    }\n    case 'setup':\n      try {\n        splitWorker = new BNBSplitWorker(data, (x) => postMessage(x))\n      } catch {\n        splitWorker = new DefaultSplitWorker(data, (x) => postMessage(x))\n      }\n      computeWorker = new ComputeWorker(data, (x) => postMessage(x))\n      break\n    default:\n      assertUnreachable(command)\n  }\n  postMessage({ resultType: 'done' })\n}\nonmessage = async (e: MessageEvent<WorkerCommand>) => {\n  try {\n    await handleEvent(e)\n  } catch (e) {\n    postMessage({ resultType: 'err', message: (e as any).message })\n  }\n}\n\nexport interface SplitWorker {\n  split(filter: RequestFilter, minCount: number): Iterable<RequestFilter>\n  setThreshold(newThreshold: number): void\n}\n"],"names":["objPathValue","obj","keys","Array","isArray","console","error","reduce","a","k","objectKeyMap","map","Object","fromEntries","i","objectKeyValueMap","items","t","objectMap","fn","entries","v","rangeGen","from","to","range","assertUnreachable","value","Error","cartesian","q","b","flatMap","d","e","flat","constant","NaN","name","percent","info","operation","operands","type","Number","MAX_VALUE","Infinity","unit","sum","values","intoOps","dynRead","accu","path","intoV","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","forEach","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","arrayEqual","set","result","customMapFormula","context","contextMapping","internalMap","current","mapping","old","newFormula","undefined","length","every","allCommutativeMonoidOperations","min","x","Math","max","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","flatten","f","_formula","flattened","dep","arrayCompare","cmp","cc","deduplicate","nodeHeightMap","layers","cmpNode","n1","n2","h1","h2","op1","op2","localeCompare","s1","s2","op","nodeSortMap","sort","_","n","push","h","ix","sortedNodes","layer","constantFold","topLevelData","shouldFold","origin","data","processed","nextContextMap","fold","c","foldStr","numericOperands","formulaOperands","filter","folded","numericValue","isFinite","index","selected","table","first","find","smallest","operand","v1","v2","match","unmatch","list","reset","nextMap","nextContext","nonTravelerCharacterKeys","allTravelerKeys","allArtifactSlotKeys","allWeaponSwordKeys","allWeaponClaymoreKeys","allWeaponPolearmKeys","allWeaponBowKeys","allWeaponCatalystKeys","allSlotKeys","travelerKeys","pruneAll","nodes","minimum","arts","numTop","exclusion","forced","should","deps","pruneNodeRange","reaffine","pruneOrder","pruneArtRange","count","some","newArts","newNodes","forceRename","affineNodes","topLevelAffine","visit","node","isAffine","dynKeys","affineOps","nonAffineOps","affine","nonConst","base","size","nextDynKey","affineMap","reaffineArt","stat","dyn","slot","id","offsets","key","baseValue","progress","allowRainbow","rainbow","noSwitchIn","noSwitchOut","includes","newList","art","other","otherBetterEqual","otherMaybeBetter","otherBetter","canSwitch","baseRange","wrap","artRanges","computeArtRange","otherArtRanges","addArtRange","read","newRange","computeNodeRange","nodeRange","operandRanges","newOperands","ranges","computeFullArtRange","reads","computeMinMax","minMaxes","filterArts","filters","kind","ids","sets","countBuilds","_count","exclusionToAllowed","artSetPerm","_artSets","artSets","allowedRainbows","shapes","indexOfShape","shape","replacing","populateShapes","rainbows","j","required","slice","remaining","noFilter","counts","allowedCounts","used","groupped","usableRainbows","check_free","isolated","missing","rejected","allowedSet","requiredRainbows","l","constP","lin","$c","sumP","terms","poly","prodP","minMax","min1","max1","min2","max2","$k","slopePoint","slope","x0","y0","interpolate","x1","y1","upper","abs","polyUB","statMinMax","nodeRanges","lower","exact","_map","oppositeContext","minmax","minf","maxf","zeroCrossing","signf","polys","ctx","p","PolyError","xs","xOp","cOp","loc","sqrt","vOp","tOp","pOp","fOp","threshOp","ge","le","mulOp","prod","thresh","isFirstHalf","toExpandedPoly","constM","weightedReadM","monomials","sumM","monos","ret","nxt","prodM","mon","m","termsA","termsB","splice","ai","foldLikeTerms","expandPoly","constructor","cause","super","zero","solveLP","Ab","rows","cols","tableau","fill","Ai","Aij","cj","pivotHistory","piv","findPiv2","pivotInplace","findPiv1","xOpt","targ","side","ncol","backtrack","row","tot","xi","isFeasible","A","r","minloc","linearUB","weight","entry","weightedSum","bounds","w","direction","err","nVar","boundScale","scaleProd","cons","coords","objective","soln","wi","log","linbound","linboi","BNBSplitWorker","optTarget","constraints","topN","callback","interim","firstUncalculated","this","addFilter","maxConts","approxs","age","setThreshold","newThreshold","calculated","minCount","getApproxFilter","calculateFilter","reportInterim","splitOldFilter","skipped","splitted","cont","conts","c1","c2","minCont","contCutoff","findIndex","lowArts","highArts","high","approx","maxContribution","low","currentCont","partialSplit","val","currentArts","pop","oldCount","dot","approximation","leadingConts","newValues","requiredConts","lc","newCount","resultType","buildValues","tested","failed","ComputeWorker","plotBase","builds","plotData","opts","optimize","compute","preArts","totalCount","oldMaxBuildCount","initial","binding","slotCount","body","names","operandNames","arr","toString","join","Function","precompute","buffer","permute","build","artifactIds","plot","interimReport","refresh","force","plots","scale","round","mergePlot","DefaultSplitWorker","_callback","stack","_newThreshold","splittedBy","splitBySet","splitByID","candidates","numChunks","ceil","boundedNumChunks","chunk","splitWorker","computeWorker","async","handleEvent","command","split","maxIterateSize","postMessage","Promise","setTimeout","perms","filter_loop","available","s","filterFeasiblePerm","onmessage","message"],"sourceRoot":""}