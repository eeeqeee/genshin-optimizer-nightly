{"version":3,"file":"156.c7996e0f05b34351.js","mappings":"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CA,UACA,WACA,SACA,OACA,QACA,QACA,QACA,OACA,OACA,UACA,SACA,QACA,QACA,QACA,OACA,kBACA,QACA,gBACA,gBACA,SACA,OACA,YACA,cACA,QACA,OACA,OACA,OACA,SACA,QACA,YACA,SACA,OACA,eACA,QACA,UACA,oBACA,OACA,SACA,kBACA,SACA,UACA,YACA,QACA,WACA,QACA,WACA,YACA,OACA,UACA,SACA,UACA,SACA,SACA,QACA,UACA,SACA,WAGWC,EAAkB,CAC7B,gBACA,cACA,kBACA,kBChHK,MAiDMC,EAAsB,CACjC,SACA,QACA,QACA,SACA,WC7CWC,EAAqB,CAChC,kBACA,gBACA,sBACA,kBACA,YACA,oBACA,gBACA,YACA,gBACA,kBACA,cACA,eACA,oBACA,kBACA,YACA,iBACA,wBACA,YACA,uBACA,uBACA,mBACA,iBACA,mBACA,eACA,cACA,gBACA,eACA,eACA,oBACA,gBACA,gBACA,WACA,kBACA,sBACA,mBAIWC,EAAwB,CACnC,YACA,qBACA,oBACA,yBACA,aACA,qBACA,gBACA,gBACA,wBACA,cACA,mBACA,eACA,qBACA,cACA,mBACA,cACA,uBACA,kBACA,wBACA,eACA,qBACA,eACA,uBACA,oBACA,UACA,cACA,mBACA,aACA,sBACA,mBAIWC,EAAuB,CAClC,qBACA,iBACA,cACA,kBACA,eACA,aACA,cACA,mBACA,qBACA,gBACA,UACA,YACA,mBACA,cACA,mBACA,cACA,4BACA,uBACA,aACA,eACA,cACA,yBACA,WACA,mBACA,kBACA,eAIWC,EAAmB,CAC9B,cACA,UACA,gBACA,mBACA,cACA,iBACA,eACA,iBACA,iBACA,WACA,aACA,cACA,cACA,YACA,oBACA,aACA,YACA,WACA,oBACA,WACA,aACA,WACA,OACA,iBACA,qBACA,oBACA,cACA,YACA,gBACA,qBACA,kBACA,gBAIWC,EAAwB,CACnC,mBACA,0BACA,kBACA,cACA,aACA,sBACA,kBACA,gBACA,cACA,qBACA,eACA,gBACA,6BACA,a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","sources":["webpack:///./src/app/Util/Util.ts","webpack:///./src/app/Formula/utils.ts","webpack:///./src/app/Formula/internal.ts","webpack:///./src/app/Formula/optimization.ts","webpack:///../../libs/consts/src/character.ts","webpack:///../../libs/consts/src/artifact.ts","webpack:///../../libs/consts/src/weapon.ts","webpack:///./src/app/Types/consts.ts","webpack:///./src/app/Solver/common.ts","webpack:///./src/app/Solver/GOSolver/polyUB.ts","webpack:///./src/app/Solver/GOSolver/solveLP.ts","webpack:///./src/app/Solver/GOSolver/linearUB.ts","webpack:///./src/app/Solver/GOSolver/BNBSplitWorker.ts","webpack:///./src/app/Solver/GOSolver/ComputeWorker.ts","webpack:///./src/app/Solver/GOSolver/DefaultSplitWorker.ts","webpack:///./src/app/Solver/GOSolver/BackgroundWorker.ts"],"sourcesContent":["export const getRandomElementFromArray = <T>(array: readonly T[]): T =>\n  array[Math.floor(Math.random() * array.length)]\nexport function getRandomInt(min, max) {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  return Math.floor(Math.random() * (max - min) + min) //The maximum is exclusive and the minimum is inclusive\n}\nexport function getRandomIntInclusive(min, max) {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  return Math.floor(Math.random() * (max - min + 1) + min) //The maximum is inclusive and the minimum is inclusive\n}\nexport function getRandomArbitrary(min, max) {\n  return Math.random() * (max - min) + min\n}\n\n/**\n * Assumes that the object entries are all primitives + objects\n * shallow copy the object,\n * deep copy the\n * @param obj\n * @returns\n */\nexport function deepClone<T>(obj: T): T {\n  if (!obj) return obj\n  if (!Object.keys(obj).length) return {} as T\n  const ret = { ...obj }\n  Object.entries(obj).forEach(([k, v]: any) => {\n    if (typeof v !== 'object') return\n    ret[k] = JSON.parse(JSON.stringify(v))\n  })\n  return ret\n}\n\nexport const clamp = (val, low, high) => {\n  if (val < low) return low\n  if (val > high) return high\n  return val\n}\nexport const getArrLastElement = (arr) =>\n  arr.length ? arr[arr.length - 1] : null\n\nexport const clamp01 = (val) => clamp(val, 0, 1)\nexport const clampPercent = (val) => clamp(val, 0, 100)\n\n//use to pretty print timestamps, or anything really.\nexport function strPadLeft(string, pad, length) {\n  return (new Array(length + 1).join(pad) + string).slice(-length)\n}\n\n//fuzzy compare strings. longer the distance, the higher the mismatch.\nexport function hammingDistance(str1, str2) {\n  let dist = 0\n  str1 = str1.toLowerCase()\n  str2 = str2.toLowerCase()\n  for (let i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\n    let match = true\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i]) match = false\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i]) match = true\n    if (!match) dist++\n  }\n  return dist\n}\n\n//multiplies every numerical value in the obj by a multiplier.\nexport function objMultiplication(obj, multi) {\n  if (multi === 1) return obj\n  Object.keys(obj).forEach((prop: any) => {\n    if (typeof obj[prop] === 'object') objMultiplication(obj[prop], multi)\n    if (typeof obj[prop] === 'number') obj[prop] = obj[prop] * multi\n  })\n  return obj\n}\n\n//assign obj.[keys...] = value\nexport function layeredAssignment(obj, keys: readonly string[], value) {\n  keys.reduce((accu, key, i, arr) => {\n    if (i === arr.length - 1) return (accu[key] = value)\n    if (!accu[key]) accu[key] = {}\n    return accu[key]\n  }, obj)\n  return obj\n}\n//get the value in a nested object, giving array of path\nexport function objPathValue(\n  obj: object | undefined,\n  keys: readonly string[]\n): any {\n  if (!obj || !keys) return undefined\n  !Array.isArray(keys) && console.error(keys)\n  return keys.reduce((a, k) => a?.[k], obj)\n}\n//delete the value denoted by the path. Will also delete empty objects as well.\nexport function deletePropPath(obj, path) {\n  const tempPath = [...path]\n  const lastKey = tempPath.pop()\n  const objPathed = objPathValue(obj, tempPath)\n  delete objPathed?.[lastKey]\n}\n\nexport function objClearEmpties(o) {\n  for (const k in o) {\n    if (typeof o[k] !== 'object') continue\n    objClearEmpties(o[k])\n    if (!Object.keys(o[k]).length) delete o[k]\n  }\n}\nexport function crawlObject(\n  obj: any,\n  keys: string[] = [],\n  validate: (o: any, keys: string[]) => boolean,\n  cb: (o: any, keys: string[]) => void\n) {\n  if (validate(obj, keys)) cb(obj, keys)\n  else\n    obj &&\n      typeof obj === 'object' &&\n      Object.entries(obj).forEach(([key, val]) =>\n        crawlObject(val, [...keys, key], validate, cb)\n      )\n}\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\nexport const getObjectKeysRecursive = (obj) =>\n  typeof obj === 'object'\n    ? Object.values(obj)\n        .flatMap(getObjectKeysRecursive)\n        .concat(Object.keys(obj))\n    : typeof obj === 'string'\n    ? [obj]\n    : []\n\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\n  return typeof value === 'function' ? (value as any)(arg) : value\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyMap<K extends string | number, V>(\n  keys: readonly K[],\n  map: (key: K, i: number) => V\n): StrictDict<`${K}`, V> {\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyValueMap<T, K extends string | number, V>(\n  items: readonly T[],\n  map: (item: T, i: number) => [K, V]\n): StrictDict<`${K}`, V> {\n  return Object.fromEntries(items.map((t, i) => map(t, i))) as any\n}\n\nexport function objectMap<K extends string, V, T>(\n  obj: Record<K, Exclude<V, undefined>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Record<K, T>\nexport function objectMap<K extends string, V, T>(\n  obj: Partial<Record<K, V>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Partial<Record<K, T>>\nexport function objectMap<K extends string, V, T>(\n  obj: Partial<Record<K, V>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Partial<Record<K, T>> {\n  return Object.fromEntries(\n    Object.entries(obj).map(([k, v], i) => [k, fn(v, k, i)])\n  ) as any\n}\n\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\n  for (let i = from; i <= to; i++) yield i\n}\n\n/** range of [from, to], inclusive */\nexport function range(from: number, to: number): number[] {\n  return [...rangeGen(from, to)]\n}\n\nexport function assertUnreachable(value: never): never {\n  throw new Error(`Should not reach this with value ${value}`)\n}\n\n// cartesian product of list of arrays\nexport function cartesian<T>(...q: T[][]): T[][] {\n  return q.reduce((a, b) => a.flatMap((d) => b.map((e) => [d, [e]].flat())), [\n    [],\n  ] as T[][])\n}\n\n/** Will change `arr` in-place */\nexport function toggleInArr<T>(arr: T[], value: T) {\n  const ind = arr.indexOf(value)\n  if (ind < 0) arr.push(value)\n  else arr.splice(ind, 1)\n  return arr\n}\n\nexport function toggleArr<T>(arr: T[], value: T) {\n  return arr.includes(value) ? arr.filter((a) => a !== value) : [...arr, value]\n}\n\nexport function deepFreeze<T>(obj: T, layers = 5): T {\n  if (layers === 0) return obj\n  if (typeof obj === 'object')\n    Object.values(Object.freeze(obj)).forEach((o) => deepFreeze(o, layers--))\n  return obj\n}\n\nexport function arrayMove<T>(arr: T[], oldIndex: number, newIndex: number) {\n  if (newIndex < 0 || newIndex >= arr.length) return arr\n  if (oldIndex < 0 || oldIndex >= arr.length) return arr\n  arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0])\n  return arr\n}\n","import { objectKeyMap } from '../Util/Util'\nimport type { OptNode } from './optimization'\nimport type {\n  ComputeNode,\n  ConstantNode,\n  Data,\n  DataNode,\n  Info,\n  LookupNode,\n  MatchNode,\n  NumNode,\n  ReadNode,\n  StrNode,\n  StrPrioNode,\n  SubscriptNode,\n  ThresholdNode,\n} from './type'\n\ntype Opt = number | OptNode\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype N_S = Num | Str\ntype AnyNode = NumNode | StrNode\n\nexport const todo: OptNode = constant(NaN, { name: 'TODO' })\nexport const one = percent(1),\n  naught = percent(0)\nexport const none = constant('none')\n\nexport function constant(value: number, info?: Info): ConstantNode<number>\nexport function constant(\n  value: string | undefined,\n  info?: Info\n): ConstantNode<string | undefined>\nexport function constant(\n  value: number | string | undefined,\n  info?: Info\n): ConstantNode<number> | ConstantNode<string | undefined>\nexport function constant(\n  value: number | string | undefined,\n  info?: Info\n): ConstantNode<number | string | undefined> {\n  return typeof value === 'number'\n    ? { operation: 'const', operands: [], type: 'number', value, info }\n    : { operation: 'const', operands: [], type: 'string', value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): ConstantNode<number> {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { unit: '%', ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: OptNode, info: Info): OptNode\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: AnyNode, info: Info): AnyNode\nexport function infoMut(node: AnyNode, info: Info): AnyNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, NumNode>,\n  defaultV: Num | 'none',\n  info?: Info\n): LookupNode<NumNode>\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, StrNode>,\n  defaultV: Str | 'none',\n  info?: Info\n): LookupNode<StrNode>\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, AnyNode>,\n  defaultV: N_S | 'none',\n  info?: Info\n): LookupNode<AnyNode> {\n  return {\n    operation: 'lookup',\n    operands:\n      defaultV !== 'none' ? [intoV(index), intoV(defaultV)] : [intoV(index)],\n    table,\n    info,\n  }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function min(...values: Num[]): ComputeNode\nexport function min(...values: Num[]): ComputeNode {\n  return { operation: 'min', operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function max(...values: Num[]): ComputeNode\nexport function max(...values: Num[]): ComputeNode {\n  return { operation: 'max', operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function sum(...values: Num[]): ComputeNode\nexport function sum(...values: Num[]): ComputeNode {\n  return { operation: 'add', operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function prod(...values: Num[]): ComputeNode\nexport function prod(...values: Num[]): ComputeNode {\n  return { operation: 'mul', operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Opt, c: Opt): ComputeNode<OptNode, OptNode>\nexport function frac(x: Num, c: Num): ComputeNode\nexport function frac(x: Num, c: Num): ComputeNode {\n  return { operation: 'sum_frac', operands: intoOps([x, c]) }\n}\nexport function res(base: Opt): ComputeNode<OptNode, OptNode>\nexport function res(base: Num): ComputeNode\nexport function res(base: Num): ComputeNode {\n  return { operation: 'res', operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? eq : neq */\nexport function compareEq(\n  v1: Num,\n  v2: Num,\n  eq: Num,\n  neq: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function compareEq(\n  v1: Num,\n  v2: Num,\n  eq: Str,\n  neq: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function compareEq(\n  v1: Str,\n  v2: Str,\n  eq: Num,\n  neq: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function compareEq(\n  v1: Str,\n  v2: Str,\n  eq: Str,\n  neq: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function compareEq(\n  v1: N_S,\n  v2: N_S,\n  eq: N_S,\n  neq: N_S,\n  info?: Info\n): MatchNode<AnyNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(eq), intoV(neq)],\n    info,\n  }\n}\n/** v1 == v2 ? pass : 0 */\nexport function equal(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function equal(\n  v1: Str,\n  v2: Str,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function equal(\n  v1: N_S,\n  v2: N_S,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(0)],\n    emptyOn: 'unmatch',\n  }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function equalStr(\n  v1: Str,\n  v2: Str,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function equalStr(\n  v1: N_S,\n  v2: N_S,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(undefined)],\n    emptyOn: 'unmatch',\n  }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function unequal(\n  v1: Str,\n  v2: Str,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function unequal(\n  v1: N_S,\n  v2: N_S,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(0), intoVInfo(pass, info)],\n    emptyOn: 'match',\n  }\n}\n/** v1 != v2 ? pass : `undefined` */\nexport function unequalStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function unequalStr(\n  v1: Str,\n  v2: Str,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function unequalStr(\n  v1: N_S,\n  v2: N_S,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(undefined), intoVInfo(pass, info)],\n    emptyOn: 'match',\n  }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(\n  v1: Opt,\n  v2: Opt,\n  pass: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function greaterEq(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function greaterEq(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(0)],\n    emptyOn: 'l',\n  }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): ThresholdNode<StrNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(undefined)],\n    emptyOn: 'l',\n  }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(\n  v1: Opt,\n  v2: Opt,\n  pass: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function lessThan(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function lessThan(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoV(0), intoVInfo(pass, info)],\n    emptyOn: 'ge',\n  }\n}\n/** v1 >= v2 ? ge : le */\nexport function threshold(\n  v1: Opt,\n  v2: Opt,\n  ge: Opt,\n  le: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function threshold(\n  v1: Num,\n  v2: Num,\n  ge: Num,\n  le: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function threshold(\n  v1: Num,\n  v2: Num,\n  ge: Num,\n  le: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoV(ge), intoV(le)],\n    info,\n  }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(\n  nodeList: T,\n  prefix: string[] = []\n): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== 'read')\n      throw new Error(\n        `Found ${(nodeList as any).operation} node while making reader`\n      )\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), (key) =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])\n    ) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(\n  base: AnyNode,\n  data: Data\n): DataNode<NumNode> | DataNode<StrNode>\nexport function data(\n  base: AnyNode,\n  data: Data\n): DataNode<NumNode> | DataNode<StrNode> {\n  return { operation: 'data', operands: [base as any], data }\n}\nexport function resetData(\n  base: NumNode,\n  data: Data,\n  info?: Info\n): DataNode<NumNode>\nexport function resetData(\n  base: StrNode,\n  data: Data,\n  info?: Info\n): DataNode<StrNode>\nexport function resetData(\n  base: AnyNode,\n  data: Data,\n  info?: Info\n): DataNode<AnyNode>\nexport function resetData(\n  base: AnyNode,\n  data: Data,\n  info?: Info\n): DataNode<AnyNode> {\n  return { operation: 'data', operands: [base], data, reset: true, info }\n}\n\nexport function dynRead(\n  name: string,\n  accu: ReadNode<number>['accu'] = 'add',\n  info?: Info\n): ReadNode<number> {\n  return {\n    operation: 'read',\n    operands: [],\n    path: ['dyn', name],\n    accu,\n    type: 'number',\n    info,\n  }\n}\nexport function customRead(\n  path: readonly string[],\n  info?: Info\n): ReadNode<number> {\n  return { operation: 'read', operands: [], path, info, type: 'number' }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: 'read', operands: [], path, type: 'string' }\n}\nexport function read(\n  accu?: ReadNode<number>['accu'],\n  info?: Info\n): ReadNode<number> {\n  return {\n    operation: 'read',\n    operands: [],\n    path: [],\n    accu,\n    info,\n    type: 'number',\n  }\n}\n/**\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\n */\nexport function stringRead(\n  accu?: ReadNode<string | undefined>['accu']\n): ReadNode<string | undefined> {\n  return { operation: 'read', operands: [], path: [], accu, type: 'string' }\n}\nexport function stringPrio(...operands: Str[]): StrPrioNode {\n  return { operation: 'prio', operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(\n  index: NumNode,\n  list: V[],\n  info?: Info\n): SubscriptNode<V> {\n  return { operation: 'subscript', operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: N_S[]): AnyNode[] {\n  return values.map((value) =>\n    typeof value === 'object' ? value : constant(value)\n  )\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: N_S): AnyNode\nfunction intoV(value: N_S): AnyNode {\n  return typeof value !== 'object' ? constant(value) : value\n}\nfunction intoVInfo(value: Num, info: Info | undefined): NumNode\nfunction intoVInfo(value: Str, info: Info | undefined): StrNode\nfunction intoVInfo(value: N_S, info: Info | undefined): AnyNode\nfunction intoVInfo(value: N_S, info: Info | undefined): AnyNode {\n  if (!info) return intoV(value)\n  return typeof value !== 'object'\n    ? constant(value, info)\n    : infoMut({ ...value }, info)\n}\n\ntype _NodeList = { [key: string]: NodeList } & { operation?: never }\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n","import type { AnyNode, Base, NodeData, NumNode, StrNode } from './type'\nimport { constant } from './utils'\n\nexport function deepNodeClone<\n  T extends NodeData<NumNode | StrNode | undefined>\n>(data: T): T {\n  const map = new Map()\n  function internal(orig: any) {\n    if (typeof orig !== 'object') return orig\n    const old = map.get(orig)\n    if (old) return old\n\n    const cache: any = Array.isArray(orig)\n      ? orig.map((val) => internal(val))\n      : Object.fromEntries(\n          Object.entries(orig).map(([key, val]) => [\n            key,\n            key === 'info' ? val : internal(val),\n          ])\n        )\n    map.set(orig, cache)\n    return cache\n  }\n  return internal(data)\n}\n\nexport function forEachNodes<T extends Base<T> = AnyNode>(\n  formulas: T[],\n  topDown: (formula: T) => void,\n  bottomUp: (formula: T) => void\n): void {\n  const visiting = new Set<T>(),\n    visited = new Set<T>()\n\n  function traverse(formula: T) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error('Found cyclical dependency during formula traversal')\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas<\n  Input extends Base<Input> = AnyNode,\n  Interim extends Base<Interim> = Input,\n  Output extends Base<Output> = Interim\n>(\n  formulas: Input[],\n  topDownMap: (formula: Input | Interim) => Interim,\n  bottomUpMap: (current: Interim | Output, orig: Input | Interim) => Output\n): Output[] {\n  const visiting = new Set<Input | Interim>()\n  const topDownMapped = new Map<Input | Interim, Output>()\n  const bottomUpMapped = new Map<Interim, Output>()\n\n  function check(formula: Input | Interim): Output {\n    let topDown: Interim | Output | undefined = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error('Found cyclical dependency during formula mapping')\n      return constant(NaN) as any\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: Interim): Interim | Output {\n    const operands = formula.operands.map(check)\n    return arrayEqual<Interim | Output>(operands, formula.operands)\n      ? formula\n      : { ...formula, operands }\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual<Input | Output>(result, formulas)\n    ? (formulas as any)\n    : result\n}\n\nexport function customMapFormula<Context, Output, Input extends Base<Input>>(\n  formulas: Input[],\n  context: Context,\n  map: (\n    formula: Input,\n    context: Context,\n    map: (node: Input, context: Context) => Output\n  ) => Output\n): Output[] {\n  const contextMapping = new Map<Context, [Set<Input>, Map<Input, Output>]>()\n  function internalMap(formula: Input, context: Context): Output {\n    let current = contextMapping.get(context)\n    if (!current)\n      contextMapping.set(context, (current = [new Set(), new Map()]))\n    const [visiting, mapping] = current\n\n    const old = mapping.get(formula)\n    if (old) return old\n\n    if (visiting.has(formula))\n      throw new Error('Found cyclical dependency during formula mapping')\n\n    visiting.add(formula)\n    const newFormula = map(formula, context, internalMap)\n    mapping.set(formula, newFormula)\n    visiting.delete(formula)\n\n    return newFormula\n  }\n  return formulas.map((formula) => internalMap(formula, context))\n}\n\nfunction arrayEqual<T>(\n  a: readonly T[] | undefined,\n  b: readonly T[] | undefined\n): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import type { ArtifactBuildData } from '../Solver/common'\nimport { assertUnreachable, objPathValue } from '../Util/Util'\nimport { customMapFormula, forEachNodes, mapFormulas } from './internal'\nimport type {\n  AnyNode,\n  CommutativeMonoidOperation,\n  ComputeNode,\n  ConstantNode,\n  Data,\n  NumNode,\n  Operation,\n  ReadNode,\n  StrNode,\n  StrPrioNode,\n  ThresholdNode,\n} from './type'\nimport { constant } from './utils'\n\nexport type OptNode =\n  | ComputeNode<OptNode, OptNode>\n  | ThresholdNode<OptNode, OptNode, OptNode>\n  | ReadNode<number>\n  | ConstantNode<number>\n\nconst allCommutativeMonoidOperations: StrictDict<\n  CommutativeMonoidOperation,\n  (_: number[]) => number\n> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<\n  Operation | 'threshold',\n  (_: number[]) => number\n> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number =>\n    value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(\n  Object.keys(allCommutativeMonoidOperations) as NumNode['operation'][]\n)\n\nexport function optimize(\n  formulas: NumNode[],\n  topLevelData: Data,\n  shouldFold = (_formula: ReadNode<number | string | undefined>) => false\n): OptNode[] {\n  let opts = constantFold(formulas, topLevelData, shouldFold)\n  opts = flatten(opts)\n  return deduplicate(opts)\n}\nexport function precompute(\n  formulas: OptNode[],\n  initial: ArtifactBuildData['values'],\n  binding: (\n    readNode: ReadNode<number> | ReadNode<string | undefined>\n  ) => string,\n  slotCount: number\n): (_: ArtifactBuildData[]) => number[] {\n  let body = `\n\"use strict\";\n// copied from the code above\nfunction res(res) {\n  if (res < 0) return 1 - res / 2\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\n  return 1 - res\n}\nconst x0=0` // making sure `const` has at least one entry\n\n  let i = 1\n  const names = new Map<NumNode | StrNode, string>()\n  forEachNodes(\n    formulas,\n    (_) => {},\n    (f) => {\n      const { operation, operands } = f,\n        name = `x${i++}`,\n        operandNames = operands.map((x: OptNode) => names.get(x)!)\n      names.set(f, name)\n      switch (operation) {\n        case 'read': {\n          const key = binding(f)\n          let arr = new Array(slotCount)\n            .fill(null)\n            .map((x, i) => `(b[${i}].values[\"${key}\"] ?? 0)`)\n          if (initial[key] && initial[key] !== 0) {\n            arr = [initial[key].toString(), ...arr]\n          }\n          body += `,${name}=${arr.join('+')}`\n          break\n        }\n        case 'const':\n          names.set(f, `(${f.value})`)\n          break\n        case 'add':\n        case 'mul':\n          body += `,${name}=${operandNames.join(\n            operation === 'add' ? '+' : '*'\n          )}`\n          break\n        case 'min':\n        case 'max':\n          body += `,${name}=Math.${operation}(${operandNames})`\n          break\n        case 'threshold': {\n          const [value, threshold, pass, fail] = operandNames\n          body += `,${name}=(${value}>=${threshold})?${pass}:${fail}`\n          break\n        }\n        case 'res':\n          body += `,${name}=res(${operandNames[0]})`\n          break\n        case 'sum_frac':\n          body += `,${name}=${operandNames[0]}/(${operandNames[0]}+${operandNames[1]})`\n          break\n\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n  body += `;\\nreturn [${formulas.map((f) => names.get(f)!)}]`\n  return new (Function as any)(`b`, body)\n}\n\nfunction flatten(formulas: OptNode[]): OptNode[] {\n  return mapFormulas(\n    formulas,\n    (f) => f,\n    (_formula) => {\n      let result = _formula\n      if (commutativeMonoidOperationSet.has(_formula.operation as Operation)) {\n        const formula = _formula as ComputeNode<OptNode>\n        const { operation } = formula\n\n        let flattened = false\n        const operands = formula.operands.flatMap((dep) =>\n          dep.operation === operation\n            ? ((flattened = true), dep.operands)\n            : [dep]\n        )\n        result = flattened ? { ...formula, operands } : formula\n      }\n\n      return result\n    }\n  )\n}\nfunction deduplicate(formulas: OptNode[]): OptNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<OptNode, number>(),\n      formulas: new Set<OptNode>(),\n      operation: 'add' as Operation,\n    },\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode<OptNode> = {\n      operation: wrap.common.operation,\n      operands: arrayFromCounts(wrap.common.counts),\n    }\n\n    const candidatesByOperation = new Map<\n      Operation,\n      [ComputeNode<OptNode>, Map<OptNode, number>][]\n    >()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(\n      formulas,\n      (_formula) => {\n        if (wrap.common.formulas.has(_formula)) {\n          const formula = _formula as ComputeNode<OptNode>\n          const remainingCounts = new Map(wrap.common.counts)\n          const operands = formula.operands.filter((dep) => {\n            const count = remainingCounts.get(dep)\n            if (count) {\n              remainingCounts.set(dep, count - 1)\n              return false\n            }\n            return true\n          })\n\n          if (!operands.length) return factored\n          operands.push(factored)\n          return { ...formula, operands }\n        }\n        return _formula\n      },\n      (_formula) => {\n        if (!commutativeMonoidOperationSet.has(_formula.operation as any))\n          return _formula\n        const formula = _formula as ComputeNode<OptNode>\n\n        if (next) {\n          if (next.operation === formula.operation) {\n            const currentCounts = elementCounts(formula.operands),\n              commonCounts = new Map<OptNode, number>()\n            const nextCounts = next.counts\n            let total = 0\n\n            for (const [dependency, currentCount] of currentCounts.entries()) {\n              const commonCount = Math.min(\n                currentCount,\n                nextCounts.get(dependency) ?? 0\n              )\n              if (commonCount) {\n                commonCounts.set(dependency, commonCount)\n                total += commonCount\n              } else commonCounts.delete(dependency)\n            }\n            if (total > 1) {\n              next.counts = commonCounts\n              next.formulas.add(formula)\n            }\n          }\n        } else {\n          const candidates = candidatesByOperation.get(formula.operation)!\n          const counts = elementCounts(formula.operands)\n\n          for (const [candidate, candidateCounts] of candidates) {\n            let total = 0\n\n            const commonCounts = new Map<OptNode, number>()\n            for (const [\n              dependency,\n              candidateCount,\n            ] of candidateCounts.entries()) {\n              const count = Math.min(\n                candidateCount,\n                counts.get(dependency) ?? 0\n              )\n              if (count) {\n                commonCounts.set(dependency, count)\n                total += count\n              }\n            }\n            if (total > 1) {\n              next = {\n                counts: commonCounts,\n                formulas: new Set([formula, candidate]),\n                operation: formula.operation,\n              }\n              candidatesByOperation.clear()\n              break\n            }\n          }\n          if (!next) candidates.push([formula, counts])\n        }\n\n        return formula\n      }\n    )\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(\n  formulas: NumNode[],\n  topLevelData: Data,\n  shouldFold = (_formula: ReadNode<number | string | undefined>) => false\n): OptNode[] {\n  type Context = {\n    data: Data[]\n    processed: Map<NumNode | StrNode, OptNode | StrNode>\n  }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return customMapFormula<typeof context, OptNode | StrNode, AnyNode>(\n    formulas,\n    context,\n    (formula, context, map) => {\n      const { operation } = formula,\n        fold = (x: NumNode, c: typeof context) => map(x, c) as OptNode\n      const foldStr = (x: StrNode, c: typeof context) => map(x, c) as StrNode\n      let result: OptNode | StrNode\n      switch (operation) {\n        case 'const':\n          result = formula\n          break\n        case 'add':\n        case 'mul':\n        case 'max':\n        case 'min': {\n          const f = allOperations[operation]\n          const numericOperands: number[] = []\n          const formulaOperands: OptNode[] = formula.operands\n            .filter((formula) => {\n              const folded = fold(formula, context)\n              return folded.operation === 'const'\n                ? (numericOperands.push(folded.value), false)\n                : true\n            })\n            .map((x) => fold(x, context))\n          const numericValue = f(numericOperands)\n\n          // Fold degenerate cases. This may incorrectly compute NaN\n          // results, which shouldn't appear under expected usage.\n          // - zero\n          //   - 0 * ... = 0\n          // - infinity\n          //   - max(infinity, ...) = infinity\n          //   - infinity + ... = infinity\n          // - (-infinity)\n          //   - min(-infinity, ...) - infinity\n          //   - (-infinity) + ... = -infinity\n          // - NaN\n          //   - operation(NaN, ...) = NaN\n          if (!isFinite(numericValue)) {\n            if (\n              operation !== 'mul' &&\n              (operation !== 'max' || numericValue > 0) &&\n              (operation !== 'min' || numericValue < 0)\n            ) {\n              result = constant(numericValue)\n              break\n            }\n          } else if (operation === 'mul' && numericValue === 0) {\n            result = constant(numericValue)\n            break\n          }\n\n          if (numericValue !== f([]))\n            // Skip vacuous values\n            formulaOperands.push(constant(numericValue))\n          if (formulaOperands.length <= 1)\n            result = formulaOperands[0] ?? constant(f([]))\n          else result = { operation, operands: formulaOperands }\n          break\n        }\n        case 'res':\n        case 'sum_frac': {\n          const operands = formula.operands.map((x) => fold(x, context))\n          const f = allOperations[operation]\n          if (operands.every((x) => x.operation === 'const'))\n            result = constant(\n              f(operands.map((x) => (x as ConstantNode<number>).value))\n            )\n          else result = { ...formula, operands }\n          break\n        }\n        case 'lookup': {\n          const index = foldStr(formula.operands[0], context)\n          if (index.operation === 'const') {\n            const selected = formula.table[index.value!] ?? formula.operands[1]\n            if (selected) {\n              result = map(selected, context)\n              break\n            }\n          }\n          throw new Error(`Unsupported ${operation} node while folding`)\n        }\n        case 'prio': {\n          const first = formula.operands.find((op) => {\n            const folded = foldStr(op, context)\n            if (folded.operation !== 'const')\n              throw new Error(`Unsupported ${operation} node while folding`)\n            return folded.value !== undefined\n          })\n          result = first ? foldStr(first, context) : constant(undefined)\n          break\n        }\n        case 'small': {\n          let smallest = undefined as\n            | ConstantNode<string | undefined>\n            | undefined\n          for (const operand of formula.operands) {\n            const folded = foldStr(operand, context)\n            if (folded.operation !== 'const')\n              throw new Error(`Unsupported ${operation} node while folding`)\n            if (\n              smallest?.value === undefined ||\n              (folded.value !== undefined && folded.value < smallest.value)\n            )\n              smallest = folded\n          }\n          result = smallest ?? constant(undefined)\n          break\n        }\n        case 'match': {\n          const [v1, v2, match, unmatch] = formula.operands.map(\n            (x: NumNode | StrNode) => map(x, context)\n          )\n          if (v1.operation !== 'const' || v2.operation !== 'const')\n            throw new Error(`Unsupported ${operation} node while folding`)\n          result = v1.value === v2.value ? match : unmatch\n          break\n        }\n        case 'threshold': {\n          const [value, threshold, pass, fail] = formula.operands.map(\n            (x) => map(x, context) as OptNode\n          )\n          if (\n            pass.operation === 'const' &&\n            fail.operation === 'const' &&\n            pass.value === fail.value\n          )\n            result = pass\n          else if (\n            value.operation === 'const' &&\n            threshold.operation === 'const'\n          )\n            result = value.value >= threshold.value ? pass : fail\n          else result = { ...formula, operands: [value, threshold, pass, fail] }\n          break\n        }\n        case 'subscript': {\n          const index = fold(formula.operands[0], context)\n          if (index.operation !== 'const')\n            throw new Error('Found non-constant subscript node while folding')\n          result = constant(formula.list[index.value])\n          break\n        }\n        case 'read': {\n          const operands = context.data\n            .map((x) => objPathValue(x, formula.path) as NumNode | StrNode)\n            .filter((x) => x)\n\n          if (operands.length === 0) {\n            if (shouldFold(formula)) {\n              const { accu } = formula\n              if (accu === undefined || accu === 'small')\n                result =\n                  formula.type === 'string'\n                    ? constant(undefined)\n                    : constant(NaN)\n              else result = constant(allOperations[accu]([]))\n            } else result = formula\n          } else if (formula.accu === undefined || operands.length === 1)\n            result = map(operands[operands.length - 1], context)\n          else\n            result = map(\n              { operation: formula.accu, operands } as\n                | ComputeNode\n                | StrPrioNode,\n              context\n            )\n          break\n        }\n        case 'data': {\n          if (formula.reset) context = origin\n          const nextMap = nextContextMap.get(context)!\n          let nextContext = nextMap.get(formula.data)\n          if (!nextContext) {\n            nextContext = {\n              data: [...context.data, formula.data],\n              processed: new Map(),\n            }\n            nextContextMap.set(nextContext, new Map())\n            nextMap.set(formula.data, nextContext)\n          }\n          result = map(formula.operands[0], nextContext)\n          break\n        }\n        default:\n          assertUnreachable(operation)\n      }\n\n      if (result.info) {\n        result = { ...result }\n        delete result.info\n      }\n      return result\n    }\n  ) as OptNode[]\n}\n\nexport const testing = {\n  constantFold,\n  flatten,\n  deduplicate,\n}\n","export const allGenderKeys = ['F', 'M'] as const\nexport type GenderKey = (typeof allGenderKeys)[number]\n\nexport const allElementKeys = [\n  'anemo',\n  'geo',\n  'electro',\n  'hydro',\n  'pyro',\n  'cryo',\n  'dendro',\n] as const\nexport type ElementKey = (typeof allElementKeys)[number]\n\nexport const allElementWithPhyKeys = ['physical', ...allElementKeys] as const\nexport type ElementWithPhyKey = (typeof allElementWithPhyKeys)[number]\n\nexport const allRegionKeys = [\n  'mondstadt',\n  'liyue',\n  'inazuma',\n  'sumeru',\n  'fontaine',\n  'natlan',\n  'snezhnaya',\n  'khaenriah',\n] as const\nexport type RegionKey = (typeof allRegionKeys)[number]\n\nexport const allAscensionKeys = [0, 1, 2, 3, 4, 5, 6] as const\nexport type AscensionKey = (typeof allAscensionKeys)[number]\n\nexport const allMoveKeys = [\n  'normal',\n  'charged',\n  'plunging',\n  'skill',\n  'burst',\n  'elemental',\n] as const\nexport type MoveKey = (typeof allMoveKeys)[number]\n\nexport const nonTravelerCharacterKeys = [\n  'Albedo',\n  'Alhaitham',\n  'Aloy',\n  'Amber',\n  'AratakiItto',\n  'Barbara',\n  'Beidou',\n  'Bennett',\n  'Candace',\n  'Chongyun',\n  'Collei',\n  'Cyno',\n  'Dehya',\n  'Diluc',\n  'Diona',\n  'Dori',\n  'Eula',\n  'Faruzan',\n  'Fischl',\n  'Ganyu',\n  'Gorou',\n  'HuTao',\n  'Jean',\n  'KaedeharaKazuha',\n  'Kaeya',\n  'KamisatoAyaka',\n  'KamisatoAyato',\n  'Keqing',\n  'Klee',\n  'KujouSara',\n  'KukiShinobu',\n  'Layla',\n  'Lisa',\n  'Mika',\n  'Mona',\n  'Nahida',\n  'Nilou',\n  'Ningguang',\n  'Noelle',\n  'Qiqi',\n  'RaidenShogun',\n  'Razor',\n  'Rosaria',\n  'SangonomiyaKokomi',\n  'Sayu',\n  'Shenhe',\n  'ShikanoinHeizou',\n  'Somnia',\n  'Sucrose',\n  'Tartaglia',\n  'Thoma',\n  'Tighnari',\n  'Venti',\n  'Wanderer',\n  'Xiangling',\n  'Xiao',\n  'Xingqiu',\n  'Xinyan',\n  'YaeMiko',\n  'Yanfei',\n  'Yaoyao',\n  'Yelan',\n  'Yoimiya',\n  'YunJin',\n  'Zhongli',\n] as const\n\nexport const allTravelerKeys = [\n  'TravelerAnemo',\n  'TravelerGeo',\n  'TravelerElectro',\n  'TravelerDendro',\n] as const\nexport type TravelerKey = (typeof allTravelerKeys)[number]\n\nexport const locationGenderedCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  'TravelerF',\n  'TravelerM',\n] as const\nexport type LocationGenderedCharacterKey =\n  (typeof locationGenderedCharacterKeys)[number]\n\nexport const allCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  ...allTravelerKeys,\n] as const\nexport type CharacterKey = (typeof allCharacterKeys)[number]\n\nexport const allLocationCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  'Traveler',\n] as const\nexport type LocationCharacterKey = (typeof allLocationCharacterKeys)[number]\n\nexport type LocationKey = LocationCharacterKey | ''\n\nexport function charKeyToLocGenderedCharKey(\n  charKey: CharacterKey,\n  gender: GenderKey\n): LocationGenderedCharacterKey {\n  if (allTravelerKeys.includes(charKey as TravelerKey))\n    return `Traveler${gender}`\n  return charKey as LocationGenderedCharacterKey\n}\n\nexport function charKeyToLocCharKey(\n  charKey: CharacterKey\n): LocationCharacterKey {\n  if (allTravelerKeys.includes(charKey as TravelerKey)) return 'Traveler'\n  return charKey as LocationCharacterKey\n}\n","import type { RarityKey } from './common'\n\nexport const allArtifactSetKeys = [\n  'Adventurer',\n  'ArchaicPetra',\n  'Berserker',\n  'BlizzardStrayer',\n  'BloodstainedChivalry',\n  'BraveHeart',\n  'CrimsonWitchOfFlames',\n  'DeepwoodMemories',\n  'DefendersWill',\n  'DesertPavilionChronicle',\n  'EchoesOfAnOffering',\n  'EmblemOfSeveredFate',\n  'FlowerOfParadiseLost',\n  'Gambler',\n  'GildedDreams',\n  'GladiatorsFinale',\n  'HeartOfDepth',\n  'HuskOfOpulentDreams',\n  'Instructor',\n  'Lavawalker',\n  'LuckyDog',\n  'MaidenBeloved',\n  'MartialArtist',\n  'NoblesseOblige',\n  'NymphsDream',\n  'OceanHuedClam',\n  'PaleFlame',\n  'PrayersForDestiny',\n  'PrayersForIllumination',\n  'PrayersForWisdom',\n  'PrayersToSpringtime',\n  'ResolutionOfSojourner',\n  'RetracingBolide',\n  'Scholar',\n  'ShimenawasReminiscence',\n  'TenacityOfTheMillelith',\n  'TheExile',\n  'ThunderingFury',\n  'Thundersoother',\n  'TinyMiracle',\n  'TravelingDoctor',\n  'VermillionHereafter',\n  'ViridescentVenerer',\n  'VourukashasGlow',\n  'WanderersTroupe',\n] as const\nexport type ArtifactSetKey = (typeof allArtifactSetKeys)[number]\n\nexport const allArtifactSlotKeys = [\n  'flower',\n  'plume',\n  'sands',\n  'goblet',\n  'circlet',\n] as const\nexport type ArtifactSlotKey = (typeof allArtifactSlotKeys)[number]\n\nexport const artMaxLevel: Record<RarityKey, number> = {\n  1: 4,\n  2: 4,\n  3: 12,\n  4: 16,\n  5: 20,\n} as const\n","import type { RarityKey } from './common'\n\nexport const allWeaponTypeKeys = [\n  'sword',\n  'claymore',\n  'polearm',\n  'bow',\n  'catalyst',\n] as const\nexport type WeaponTypeKey = (typeof allWeaponTypeKeys)[number]\n\nexport const allWeaponSwordKeys = [\n  'AmenomaKageuchi',\n  'AquilaFavonia',\n  'BlackcliffLongsword',\n  'CinnabarSpindle',\n  'CoolSteel',\n  'KagotsurubeIsshin',\n  'DarkIronSword',\n  'DullBlade',\n  'FavoniusSword',\n  'FesteringDesire',\n  'FilletBlade',\n  'FreedomSworn',\n  'HaranGeppakuFutsu',\n  'HarbingerOfDawn',\n  'IronSting',\n  'KeyOfKhajNisut',\n  'LightOfFoliarIncision',\n  'LionsRoar',\n  'MistsplitterReforged',\n  'PrimordialJadeCutter',\n  'PrototypeRancour',\n  'RoyalLongsword',\n  'SacrificialSword',\n  'SapwoodBlade',\n  'SilverSword',\n  'SkyriderSword',\n  'SkywardBlade',\n  'SummitShaper',\n  'SwordOfDescension',\n  'TheAlleyFlash',\n  'TheBlackSword',\n  'TheFlute',\n  'ToukabouShigure',\n  'TravelersHandySword',\n  'XiphosMoonlight',\n] as const\nexport type WeaponSwordKey = (typeof allWeaponSwordKeys)[number]\n\nexport const allWeaponClaymoreKeys = [\n  'Akuoumaru',\n  'BeaconOfTheReedSea',\n  'BlackcliffSlasher',\n  'BloodtaintedGreatsword',\n  'DebateClub',\n  'FavoniusGreatsword',\n  'FerrousShadow',\n  'ForestRegalia',\n  'KatsuragikiriNagamasa',\n  'LithicBlade',\n  'LuxuriousSeaLord',\n  'MailedFlower',\n  'MakhairaAquamarine',\n  'OldMercsPal',\n  'PrototypeArchaic',\n  'Rainslasher',\n  'RedhornStonethresher',\n  'RoyalGreatsword',\n  'SacrificialGreatsword',\n  'SerpentSpine',\n  'SkyriderGreatsword',\n  'SkywardPride',\n  'SnowTombedStarsilver',\n  'SongOfBrokenPines',\n  'TheBell',\n  'TheUnforged',\n  'WasterGreatsword',\n  'Whiteblind',\n  'WhiteIronGreatsword',\n  'WolfsGravestone',\n] as const\nexport type WeaponClaymoreKey = (typeof allWeaponClaymoreKeys)[number]\n\nexport const allWeaponPolearmKeys = [\n  'BeginnersProtector',\n  'BlackcliffPole',\n  'BlackTassel',\n  'CalamityQueller',\n  'CrescentPike',\n  'Deathmatch',\n  'DragonsBane',\n  'DragonspineSpear',\n  'EngulfingLightning',\n  'FavoniusLance',\n  'Halberd',\n  'IronPoint',\n  'KitainCrossSpear',\n  'LithicSpear',\n  'MissiveWindspear',\n  'Moonpiercer',\n  'PrimordialJadeWingedSpear',\n  'PrototypeStarglitter',\n  'RoyalSpear',\n  'SkywardSpine',\n  'StaffOfHoma',\n  'StaffOfTheScarletSands',\n  'TheCatch',\n  'VortexVanquisher',\n  'WavebreakersFin',\n  'WhiteTassel',\n] as const\nexport type WeaponPoleArmKey = (typeof allWeaponPolearmKeys)[number]\n\nexport const allWeaponBowKeys = [\n  'AlleyHunter',\n  'AmosBow',\n  'AquaSimulacra',\n  'BlackcliffWarbow',\n  'CompoundBow',\n  'ElegyForTheEnd',\n  'EndOfTheLine',\n  'FadingTwilight',\n  'FavoniusWarbow',\n  'Hamayumi',\n  'HuntersBow',\n  'HuntersPath',\n  'KingsSquire',\n  'Messenger',\n  'MitternachtsWaltz',\n  'MouunsMoon',\n  'PolarStar',\n  'Predator',\n  'PrototypeCrescent',\n  'RavenBow',\n  'RecurveBow',\n  'RoyalBow',\n  'Rust',\n  'SacrificialBow',\n  'SeasonedHuntersBow',\n  'SharpshootersOath',\n  'SkywardHarp',\n  'Slingshot',\n  'TheStringless',\n  'TheViridescentHunt',\n  'ThunderingPulse',\n  'WindblumeOde',\n] as const\nexport type WeaponBowKey = (typeof allWeaponBowKeys)[number]\n\nexport const allWeaponCatalystKeys = [\n  'ApprenticesNotes',\n  'AThousandFloatingDreams',\n  'BlackcliffAgate',\n  'DodocoTales',\n  'EmeraldOrb',\n  'EverlastingMoonglow',\n  'EyeOfPerception',\n  'FavoniusCodex',\n  'Frostbearer',\n  'FruitOfFulfillment',\n  'HakushinRing',\n  'KagurasVerity',\n  'LostPrayerToTheSacredWinds',\n  'MagicGuide',\n  'MappaMare',\n  'MemoryOfDust',\n  'OathswornEye',\n  'OtherworldlyStory',\n  'PocketGrimoire',\n  'PrototypeAmber',\n  'QuantumCatalyst',\n  'RoyalGrimoire',\n  'SacrificialFragments',\n  'SkywardAtlas',\n  'SolarPearl',\n  'TheWidsith',\n  'ThrillingTalesOfDragonSlayers',\n  'TulaytullahsRemembrance',\n  'TwinNephrite',\n  'WanderingEvenstar',\n  'WineAndSong',\n] as const\nexport type WeaponCatalystKey = (typeof allWeaponCatalystKeys)[number]\n\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\nexport type WeaponKey =\n  | WeaponSwordKey\n  | WeaponClaymoreKey\n  | WeaponPoleArmKey\n  | WeaponBowKey\n  | WeaponCatalystKey\n\nexport const weaponMaxLevel: Record<RarityKey, number> = {\n  1: 70,\n  2: 70,\n  3: 90,\n  4: 90,\n  5: 90,\n} as const\n","import type {\n  allArtifactSetKeys,\n  WeaponBowKey,\n  WeaponCatalystKey,\n  WeaponClaymoreKey,\n  WeaponPoleArmKey,\n  WeaponSwordKey,\n} from '@genshin-optimizer/consts'\nimport {\n  allWeaponBowKeys,\n  allWeaponCatalystKeys,\n  allWeaponClaymoreKeys,\n  allWeaponPolearmKeys,\n  allWeaponSwordKeys,\n  nonTravelerCharacterKeys,\n} from '@genshin-optimizer/consts'\n\nexport const allHitModes = ['hit', 'avgHit', 'critHit'] as const\nexport const allAmpReactions = ['vaporize', 'melt'] as const\nexport const allAdditiveReactions = ['spread', 'aggravate'] as const\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\n\nexport const allArtifactRarities = [5, 4, 3] as const\n/**\n * @deprecated\n */\nexport const allSlotKeys = [\n  'flower',\n  'plume',\n  'sands',\n  'goblet',\n  'circlet',\n] as const\n/**\n * @deprecated\n */\nexport const allElements = [\n  'anemo',\n  'geo',\n  'electro',\n  'hydro',\n  'pyro',\n  'cryo',\n  'dendro',\n] as const\n/**\n * @deprecated\n */\nexport const allElementsWithPhy = ['physical', ...allElements] as const\nexport const allInfusionAuraElements = [\n  'pyro',\n  'cryo',\n  'hydro',\n  'electro',\n] as const\n/**\n * @deprecated\n */\nexport const allWeaponTypeKeys = [\n  'sword',\n  'claymore',\n  'polearm',\n  'bow',\n  'catalyst',\n] as const\nexport const allRollColorKeys = [\n  'roll1',\n  'roll2',\n  'roll3',\n  'roll4',\n  'roll5',\n  'roll6',\n] as const\n/**\n * @deprecated\n */\nexport const allAscension = [0, 1, 2, 3, 4, 5, 6] as const\nexport const allRefinement = [1, 2, 3, 4, 5] as const\nexport const substatType = ['max', 'mid', 'min'] as const\nexport const genderKeys = ['F', 'M'] as const\nexport type Gender = (typeof genderKeys)[number]\n\n/**\n * @deprecated\n */\nexport const allLocationCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  'Traveler',\n] as const\nexport const travelerElements = ['anemo', 'geo', 'electro', 'dendro'] as const\nexport const travelerFKeys = [\n  'TravelerAnemoF',\n  'TravelerGeoF',\n  'TravelerElectroF',\n  'TravelerDendroF',\n] as const\nexport const travelerMKeys = [\n  'TravelerAnemoM',\n  'TravelerGeoM',\n  'TravelerElectroM',\n  'TravelerDendroM',\n] as const\n/**\n * @deprecated\n */\nexport const travelerKeys = [\n  'TravelerAnemo',\n  'TravelerGeo',\n  'TravelerElectro',\n  'TravelerDendro',\n] as const\n/**\n * @deprecated\n */\nexport const allCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  ...travelerKeys,\n] as const\n\nexport const allCharacterSheetKeys = [\n  ...nonTravelerCharacterKeys,\n  ...travelerFKeys,\n  ...travelerMKeys,\n]\n\n/**\n * @deprecated\n */\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\n/**\n * @deprecated\n */\nexport type WeaponKey =\n  | WeaponSwordKey\n  | WeaponClaymoreKey\n  | WeaponPoleArmKey\n  | WeaponBowKey\n  | WeaponCatalystKey\n\nexport const characterSpecializedStatKeys = [\n  'hp_',\n  'atk_',\n  'def_',\n  'eleMas',\n  'enerRech_',\n  'heal_',\n  'critRate_',\n  'critDMG_',\n  'physical_dmg_',\n  'anemo_dmg_',\n  'geo_dmg_',\n  'electro_dmg_',\n  'hydro_dmg_',\n  'pyro_dmg_',\n  'cryo_dmg_',\n  'dendro_dmg_',\n] as const\n\nexport type HitModeKey = (typeof allHitModes)[number]\nexport type AmpReactionKey = (typeof allAmpReactions)[number]\nexport type AdditiveReactionKey = (typeof allAdditiveReactions)[number]\nexport type SetNum = (typeof allArtifactSetCount)[number]\nexport type ArtifactRarity = (typeof allArtifactRarities)[number]\n/**\n * @deprecated\n */\nexport type SlotKey = (typeof allSlotKeys)[number]\n/**\n * @deprecated\n */\nexport type ElementKey = (typeof allElements)[number]\n/**\n * @deprecated\n */\nexport type ElementKeyWithPhy = (typeof allElementsWithPhy)[number]\nexport type InfusionAuraElements = (typeof allInfusionAuraElements)[number]\n/**\n * @deprecated\n */\nexport type ArtifactSetKey = (typeof allArtifactSetKeys)[number]\n/**\n * @deprecated\n */\nexport type CharacterKey = (typeof allCharacterKeys)[number]\nexport type CharacterSheetKey = (typeof allCharacterSheetKeys)[number]\n/**\n * @deprecated\n */\nexport type LocationCharacterKey = (typeof allLocationCharacterKeys)[number]\n/**\n * @deprecated\n */\nexport type TravelerKey = (typeof travelerKeys)[number]\nexport type TravelerElementKey = (typeof travelerElements)[number]\n/**\n * @deprecated\n */\nexport type WeaponTypeKey = (typeof allWeaponTypeKeys)[number]\nexport type RollColorKey = (typeof allRollColorKeys)[number]\n/**\n * @deprecated\n */\nexport type Ascension = (typeof allAscension)[number]\nexport type Refinement = (typeof allRefinement)[number]\nexport type CharacterSpecializedStatKey =\n  (typeof characterSpecializedStatKeys)[number]\nexport const absorbableEle = [\n  'hydro',\n  'pyro',\n  'cryo',\n  'electro',\n] as ElementKey[]\nexport const allowedAmpReactions: Dict<ElementKey, AmpReactionKey[]> = {\n  pyro: ['vaporize', 'melt'],\n  hydro: ['vaporize'],\n  cryo: ['melt'],\n  anemo: ['vaporize', 'melt'],\n}\nexport const allowedAdditiveReactions: Dict<ElementKey, AdditiveReactionKey[]> =\n  {\n    dendro: ['spread'],\n    electro: ['aggravate'],\n    anemo: ['aggravate'],\n  }\n\nexport type SubstatType = (typeof substatType)[number]\n\n/**\n * @deprecated\n */\nexport function charKeyToLocCharKey(\n  charKey: CharacterKey\n): LocationCharacterKey {\n  if (travelerKeys.includes(charKey as TravelerKey)) return 'Traveler'\n  return charKey as LocationCharacterKey\n}\n\nexport function TravelerToElement(\n  key: TravelerKey,\n  element: TravelerElementKey\n): TravelerKey {\n  return ('Traveler' +\n    element.toUpperCase().slice(0, 1) +\n    element.slice(1)) as TravelerKey\n}\n\n/**\n * @deprecated\n */\nexport type LocationKey = LocationCharacterKey | ''\n\nexport function charKeyToCharName(ck: CharacterKey, gender: Gender): string {\n  return ck.startsWith('Traveler') ? 'Traveler' + gender : ck\n}\n","import type { ArtSetExclusion } from '../Database/DataManagers/BuildSettingData'\nimport { forEachNodes, mapFormulas } from '../Formula/internal'\nimport type { OptNode } from '../Formula/optimization'\nimport { allOperations, constantFold } from '../Formula/optimization'\nimport type { ConstantNode } from '../Formula/type'\nimport { constant, dynRead, max, min, sum, threshold } from '../Formula/utils'\nimport type { ArtifactSetKey, SlotKey } from '../Types/consts'\nimport { allSlotKeys } from '../Types/consts'\nimport { assertUnreachable, objectKeyMap, objectMap, range } from '../Util/Util'\n\ntype MicropassOperation =\n  | 'reaffine'\n  | 'pruneArtRange'\n  | 'pruneNodeRange'\n  | 'pruneOrder'\nexport function pruneAll(\n  nodes: OptNode[],\n  minimum: number[],\n  arts: ArtifactsBySlot,\n  numTop: number,\n  exclusion: ArtSetExclusion,\n  forced: Dict<MicropassOperation, boolean>\n): { nodes: OptNode[]; arts: ArtifactsBySlot } {\n  let should = forced\n  /** If `key` makes progress, all operations in `value` should be performed */\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\n    pruneOrder: { pruneNodeRange: true },\n    pruneArtRange: { pruneNodeRange: true },\n    pruneNodeRange: { reaffine: true },\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true },\n  }\n  let count = 0\n  while (Object.values(should).some((x) => x) && count++ < 20) {\n    if (should.pruneOrder) {\n      delete should.pruneOrder\n      const newArts = pruneOrder(arts, numTop, exclusion)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneOrder }\n      }\n    }\n    if (should.pruneArtRange) {\n      delete should.pruneArtRange\n      const newArts = pruneArtRange(nodes, arts, minimum)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneArtRange }\n      }\n    }\n    if (should.pruneNodeRange) {\n      delete should.pruneNodeRange\n      const newNodes = pruneNodeRange(nodes, arts)\n      if (nodes !== newNodes) {\n        nodes = newNodes\n        should = { ...should, ...deps.pruneNodeRange }\n      }\n    }\n    if (should.reaffine) {\n      delete should.reaffine\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\n      if (nodes !== newNodes || arts !== newArts) {\n        nodes = newNodes\n        arts = newArts\n        should = { ...should, ...deps.reaffine }\n      }\n    }\n  }\n  return { nodes, arts }\n}\n\nexport function pruneExclusion(\n  nodes: OptNode[],\n  exclusion: ArtSetExclusion\n): OptNode[] {\n  const maxValues: Dict<keyof typeof exclusion, number> = {}\n  for (const [key, e] of Object.entries(exclusion)) {\n    if (!e.includes(4)) continue\n    maxValues[key] = e.includes(2) ? 1 : 3\n  }\n  return mapFormulas(\n    nodes,\n    (f) => f,\n    (f) => {\n      if (f.operation !== 'threshold') return f\n\n      const [v, t, pass, fail] = f.operands\n      if (v.operation === 'read' && t.operation === 'const') {\n        const key = v.path[v.path.length - 1],\n          thres = t.value\n        if (key in maxValues) {\n          const max: number = maxValues[key]\n          if (max < thres) return fail\n          if (thres === 2 && exclusion[key]!.includes(2))\n            return threshold(v, 4, pass, fail)\n        }\n      }\n      return f\n    }\n  )\n}\n\nfunction reaffine(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot,\n  forceRename = false\n): { nodes: OptNode[]; arts: ArtifactsBySlot } {\n  const affineNodes = new Set<OptNode>(),\n    topLevelAffine = new Set<OptNode>()\n\n  function visit(node: OptNode, isAffine: boolean): OptNode {\n    if (isAffine) affineNodes.add(node)\n    else\n      node.operands.forEach(\n        (op) => affineNodes.has(op) && topLevelAffine.add(op)\n      )\n    return node\n  }\n\n  const dynKeys = new Set<string>()\n\n  nodes = mapFormulas(\n    nodes,\n    (_) => _,\n    (f) => {\n      const { operation } = f\n      switch (operation) {\n        case 'read':\n          dynKeys.add(f.path[1])\n          return visit(f, true)\n        case 'add': {\n          const affineOps = f.operands.filter((op) => affineNodes.has(op))\n          const nonAffineOps = f.operands.filter((op) => !affineNodes.has(op))\n          if (nonAffineOps.length === 0) return visit(f, true)\n          if (affineOps.length <= 1) return visit(f, false)\n          const affine = visit(sum(...affineOps), true)\n          return visit(sum(affine, ...nonAffineOps), false)\n        }\n        case 'mul': {\n          const nonConst = f.operands.filter((op) => op.operation !== 'const')\n          return visit(\n            f,\n            nonConst.length === 0 ||\n              (nonConst.length === 1 && affineNodes.has(nonConst[0]))\n          )\n        }\n        case 'const':\n          return visit(f, true)\n        case 'res':\n        case 'threshold':\n        case 'sum_frac':\n        case 'max':\n        case 'min':\n          return visit(f, false)\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n\n  nodes\n    .filter((node) => affineNodes.has(node))\n    .forEach((node) => topLevelAffine.add(node))\n  if (\n    [...topLevelAffine].every(\n      ({ operation }) => operation === 'read' || operation === 'const'\n    ) &&\n    Object.keys(arts.base).length === dynKeys.size\n  )\n    return { nodes, arts }\n\n  let current = -1\n  function nextDynKey(): string {\n    while (dynKeys.has(`${++current}`));\n    return `${current}`\n  }\n\n  const affine = [...topLevelAffine].filter((f) => f.operation !== 'const')\n  const affineMap = new Map(\n    affine.map((node) => [\n      node,\n      !forceRename && node.operation === 'read' && node.path[0] === 'dyn'\n        ? node\n        : dynRead(nextDynKey()),\n    ])\n  )\n  nodes = mapFormulas(\n    nodes,\n    (f) => affineMap.get(f) ?? f,\n    (f) => f\n  )\n\n  function reaffineArt(stat: DynStat): DynStat {\n    const values = constantFold(\n      [...affineMap.keys()],\n      {\n        dyn: objectMap(stat, (value) => constant(value)),\n      } as any,\n      (_) => true\n    )\n    return Object.fromEntries(\n      [...affineMap.values()].map((v, i) => [\n        v.path[1],\n        (values[i] as ConstantNode<number>).value,\n      ])\n    )\n  }\n  const result = {\n    nodes,\n    arts: {\n      base: reaffineArt(arts.base),\n      values: objectKeyMap(allSlotKeys, (slot) =>\n        arts.values[slot].map(({ id, set, values }) => ({\n          id,\n          set,\n          values: reaffineArt(values),\n        }))\n      ),\n    },\n  }\n  const offsets = Object.entries(reaffineArt({}))\n  for (const arts of Object.values(result.arts.values))\n    for (const { values } of arts)\n      for (const [key, baseValue] of offsets) values[key] -= baseValue\n  return result\n}\n/** Remove artifacts that cannot be in top `numTop` builds */\nfunction pruneOrder(\n  arts: ArtifactsBySlot,\n  numTop: number,\n  exclusion: ArtSetExclusion\n): ArtifactsBySlot {\n  let progress = false\n  /**\n   * Note:\n   * This function assumes that every base (reaffined) stats are monotonically increasing. That is, artifacts\n   * with higher stats are better. This remains true as long as the main and substats are in increasing. Set\n   * effects that decrease enemy resistance (which is monotonically decreasing) does not violate this assumption\n   * as set effects are not handled here.\n   */\n  const allowRainbow = !exclusion.rainbow?.length,\n    keys = Object.keys(arts.base)\n  const noSwitchIn = new Set(\n    Object.entries(exclusion)\n      .filter(([_, v]) => v.length)\n      .map(([k]) => k) as ArtifactSetKey[]\n  )\n  const noSwitchOut = new Set(\n    Object.entries(exclusion)\n      .filter(([_, v]) => v.includes(2) && !v.includes(4))\n      .map(([k]) => k) as ArtifactSetKey[]\n  )\n  const values = objectKeyMap(allSlotKeys, (slot) => {\n    const list = arts.values[slot]\n    const newList = list.filter((art) => {\n      let count = 0\n      return list.every((other) => {\n        const otherBetterEqual = keys.every(\n          (k) => (other.values[k] ?? 0) >= (art.values[k] ?? 0)\n        )\n        const otherMaybeBetter = keys.some(\n          (k) => (other.values[k] ?? 0) > (art.values[k] ?? 0)\n        )\n        const otherBetter =\n          otherBetterEqual && (otherMaybeBetter || other.id > art.id)\n        const canSwitch =\n          (allowRainbow &&\n            !noSwitchIn.has(other.set!) &&\n            !noSwitchOut.has(art.set!)) ||\n          art.set === other.set\n        if (otherBetter && canSwitch) count++\n        return count < numTop\n      })\n    })\n    if (newList.length !== list.length) progress = true\n    return newList\n  })\n  return progress ? { base: arts.base, values } : arts\n}\n/** Remove artifacts that cannot reach `minimum` in any build */\nfunction pruneArtRange(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot,\n  minimum: number[]\n): ArtifactsBySlot {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  const wrap = { arts }\n  while (true) {\n    const artRanges = objectKeyMap(allSlotKeys, (slot) =>\n      computeArtRange(wrap.arts.values[slot])\n    )\n    const otherArtRanges = objectKeyMap(allSlotKeys, (key) =>\n      addArtRange(\n        Object.entries(artRanges)\n          .map((a) => (a[0] === key ? baseRange : a[1]))\n          .filter((x) => x)\n      )\n    )\n\n    let progress = false\n    const values = objectKeyMap(allSlotKeys, (slot) => {\n      const result = wrap.arts.values[slot].filter((art) => {\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\n        const newRange = computeNodeRange(nodes, read)\n        return nodes.every(\n          (node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity)\n        )\n      })\n      if (result.length !== wrap.arts.values[slot].length) progress = true\n      return result\n    })\n    if (!progress) break\n    wrap.arts = { base: wrap.arts.base, values }\n  }\n  return wrap.arts\n}\nfunction pruneNodeRange(nodes: OptNode[], arts: ArtifactsBySlot): OptNode[] {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  const reads = addArtRange([\n    baseRange,\n    ...Object.values(arts.values).map((values) => computeArtRange(values)),\n  ])\n  const nodeRange = computeNodeRange(nodes, reads)\n\n  return mapFormulas(\n    nodes,\n    (f) => {\n      {\n        const { min, max } = nodeRange.get(f)!\n        if (min === max) return constant(min)\n      }\n      const { operation } = f\n      const operandRanges = f.operands.map((x) => nodeRange.get(x)!)\n      switch (operation) {\n        case 'threshold': {\n          const [value, threshold, pass, fail] = operandRanges\n          if (value.min >= threshold.max) return f.operands[2]\n          else if (value.max < threshold.min) return f.operands[3]\n          if (\n            pass.max === pass.min &&\n            fail.max === fail.min &&\n            pass.min === fail.min &&\n            isFinite(pass.min)\n          )\n            return constant(pass.max)\n          break\n        }\n        case 'min': {\n          const newOperands = f.operands.filter((_, i) => {\n            const op1 = operandRanges[i]\n            return operandRanges.every((op2) => op1.min <= op2.max)\n          })\n          if (newOperands.length < operandRanges.length)\n            return min(...newOperands)\n          break\n        }\n        case 'max': {\n          const newOperands = f.operands.filter((_, i) => {\n            const op1 = operandRanges[i]\n            return operandRanges.every((op2) => op1.max >= op2.min)\n          })\n          if (newOperands.length < operandRanges.length)\n            return max(...newOperands)\n          break\n        }\n      }\n      return f\n    },\n    (f) => f\n  )\n}\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\n  const result: DynMinMax = {}\n  ranges.forEach((range) => {\n    Object.entries(range).forEach(([key, value]) => {\n      if (result[key]) {\n        result[key].min += value.min\n        result[key].max += value.max\n      } else result[key] = { ...value }\n    })\n  })\n  return result\n}\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\n  const result: DynMinMax = {}\n  if (arts.length) {\n    Object.keys(arts[0].values)\n      .filter((key) => arts.every((art) => art.values[key]))\n      .forEach(\n        (key) =>\n          (result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\n      )\n    arts.forEach(({ values }) => {\n      for (const [key, value] of Object.entries(values)) {\n        if (!result[key]) result[key] = { min: 0, max: value }\n        else {\n          if (result[key].max < value) result[key].max = value\n          if (result[key].min > value) result[key].min = value\n        }\n      }\n    })\n  }\n  return result\n}\nexport function computeFullArtRange(arts: ArtifactsBySlot): DynMinMax {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  return addArtRange([\n    baseRange,\n    ...Object.values(arts.values).map((values) => computeArtRange(values)),\n  ])\n}\nexport function computeNodeRange(\n  nodes: OptNode[],\n  reads: DynMinMax\n): Map<OptNode, MinMax> {\n  const range = new Map<OptNode, MinMax>()\n\n  forEachNodes(\n    nodes,\n    (_) => {},\n    (f) => {\n      const { operation } = f\n      const operands = f.operands.map((op) => range.get(op)!)\n      let current: MinMax\n      switch (operation) {\n        case 'read':\n          if (f.path[0] !== 'dyn')\n            throw new Error(\n              `Found non-dyn path ${f.path} while computing range`\n            )\n          current = reads[f.path[1]] ?? { min: 0, max: 0 }\n          break\n        case 'const':\n          current = computeMinMax([f.value])\n          break\n        case 'add':\n        case 'min':\n        case 'max':\n          current = {\n            min: allOperations[operation](operands.map((x) => x.min)),\n            max: allOperations[operation](operands.map((x) => x.max)),\n          }\n          break\n        case 'res':\n          current = {\n            min: allOperations[operation]([operands[0].max]),\n            max: allOperations[operation]([operands[0].min]),\n          }\n          break\n        case 'mul':\n          current = operands.reduce((accu, current) =>\n            computeMinMax([\n              accu.min * current.min,\n              accu.min * current.max,\n              accu.max * current.min,\n              accu.max * current.max,\n            ])\n          )\n          break\n        case 'threshold':\n          if (operands[0].min >= operands[1].max) current = operands[2]\n          else if (operands[0].max < operands[1].min) current = operands[3]\n          else current = computeMinMax([], [operands[2], operands[3]])\n          break\n        case 'sum_frac': {\n          const [x, c] = operands,\n            sum = { min: x.min + c.min, max: x.max + c.max }\n          if (sum.min <= 0 && sum.max >= 0)\n            current =\n              x.min <= 0 && x.max >= 0\n                ? { min: NaN, max: NaN }\n                : { min: -Infinity, max: Infinity }\n          // TODO: Check this\n          else\n            current = computeMinMax([\n              x.min / sum.min,\n              x.min / sum.max,\n              x.max / sum.min,\n              x.max / sum.max,\n            ])\n          break\n        }\n        default:\n          assertUnreachable(operation)\n      }\n      range.set(f, current)\n    }\n  )\n  return range\n}\nfunction computeMinMax(\n  values: readonly number[],\n  minMaxes: readonly MinMax[] = []\n): MinMax {\n  const max = Math.max(...values, ...minMaxes.map((x) => x.max))\n  const min = Math.min(...values, ...minMaxes.map((x) => x.min))\n  return { min, max }\n}\n\nexport function filterArts(\n  arts: ArtifactsBySlot,\n  filters: RequestFilter\n): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objectKeyMap(allSlotKeys, (slot) => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case 'id':\n          return arts.values[slot].filter((art) => filter.ids.has(art.id))\n        case 'exclude':\n          return arts.values[slot].filter((art) => !filter.sets.has(art.set!))\n        case 'required':\n          return arts.values[slot].filter((art) => filter.sets.has(art.set!))\n      }\n    }),\n  }\n}\n\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\n  return builds\n    .flatMap((x) => x)\n    .sort((a, b) => b.value - a.value)\n    .slice(0, maxNum)\n}\nexport function mergePlot(plots: PlotData[]): PlotData {\n  let scale = 0.01\n  const reductionScaling = 2,\n    maxCount = 1500\n  let keys = new Set(\n    plots.flatMap((x) =>\n      Object.values(x).map((v) => Math.round(v.plot! / scale))\n    )\n  )\n  while (keys.size > maxCount) {\n    scale *= reductionScaling\n    keys = new Set([...keys].map((key) => Math.round(key / reductionScaling)))\n  }\n  const result: PlotData = {}\n  for (const plot of plots)\n    for (const build of Object.values(plot)) {\n      const x = Math.round(build.plot! / scale) * scale\n      if (!result[x] || result[x]!.value < build.value) result[x] = build\n    }\n  return result\n}\n\nexport function countBuilds(arts: ArtifactsBySlot): number {\n  return allSlotKeys.reduce(\n    (_count, slot) => _count * arts.values[slot].length,\n    1\n  )\n}\n\nexport function* filterFeasiblePerm(\n  filters: Iterable<RequestFilter>,\n  _artSets: ArtifactsBySlot\n): Iterable<RequestFilter> {\n  const artSets = objectMap(\n    _artSets.values,\n    (values) => new Set(values.map((v) => v.set))\n  )\n  filter_loop: for (const filter of filters) {\n    for (const [slot, f] of Object.entries(filter)) {\n      const available = artSets[slot]!\n      switch (f.kind) {\n        case 'required':\n          if ([...f.sets].every((s) => !available.has(s))) continue filter_loop\n          break\n        case 'exclude':\n          if ([...available].every((s) => f.sets.has(s!))) continue filter_loop\n          break\n        case 'id':\n          break\n      }\n    }\n    yield filter\n  }\n}\nexport function exclusionToAllowed(\n  exclusion: number[] | undefined\n): Set<number> {\n  return new Set(\n    exclusion?.includes(2)\n      ? exclusion.includes(4)\n        ? [0, 1]\n        : [0, 1, 4, 5]\n      : exclusion?.includes(4)\n      ? [0, 1, 2, 3]\n      : [0, 1, 2, 3, 4, 5]\n  )\n}\n/** A *disjoint* set of `RequestFilter` satisfying the exclusion rules */\nexport function* artSetPerm(\n  exclusion: ArtSetExclusion,\n  _artSets: ArtifactSetKey[]\n): Iterable<RequestFilter> {\n  /**\n   * This generation algorithm is separated into two parts:\n   * - \"Shape\" generation\n   *   - It first generates all build \"shapes\", e.g., AABBC, ABBCD\n   *   - It then filters the generated shapes according to the rainbow exclusion, e.g., removes ABBCD if excluding 3 rainbows\n   *   - It then merges the remaining shapes into wildcards, e.g. AABAA + AABAB + AABAC => AABA*\n   * - Shape filling\n   *   - From the given shapes, it tries to fill in all non-rainbow slots, e.g., slots A and B of AABBC, with actual artifacts\n   *   - It then fills the rainbow slots, e.g., slot C of AABBC while ensuring the exclusion rule of each sets\n   */\n  const artSets = [...new Set(_artSets)],\n    allowedRainbows = exclusionToAllowed(exclusion.rainbow)\n  let shapes: number[][] = []\n  function populateShapes(\n    current: number[],\n    list: Set<number>,\n    rainbows: number[]\n  ) {\n    if (current.length === 5) {\n      if (allowedRainbows.has(rainbows.length)) shapes.push(current)\n      return\n    }\n    for (const i of list)\n      populateShapes(\n        [...current, i],\n        list,\n        rainbows.filter((j) => j !== i)\n      )\n    populateShapes(\n      [...current, current.length],\n      new Set([...list, current.length]),\n      [...rainbows, current.length]\n    )\n  }\n  populateShapes([0], new Set([0]), [0])\n  function indexOfShape(shape: number[], replacing: number) {\n    if (range(replacing + 1, 4).some((i) => shape[i] !== 5)) return undefined\n    shape = [...shape]\n    shape[replacing] = 5\n    return shape.reduce((a, b) => a * 6 + b, 0)\n  }\n  for (let replacing = 4; replacing >= 0; replacing--) {\n    const required: Map<number, number> = new Map()\n    for (const shape of shapes) {\n      const id = indexOfShape(shape, replacing)\n      if (id === undefined) continue\n      required.set(\n        id,\n        (required.get(id) ?? new Set(shape.slice(0, replacing)).size + 1) - 1\n      )\n    }\n    for (const [id, remaining] of required.entries()) {\n      if (remaining === 0) {\n        const shape = [\n          ...shapes.find((shape) => indexOfShape(shape, replacing) === id)!,\n        ]\n        shape[replacing] = 5\n        shapes = shapes.filter((shape) => indexOfShape(shape, replacing) !== id)\n        shapes.push(shape)\n      }\n    }\n  }\n\n  // Shapes are now calculated and merged, proceed to fill in the sets\n\n  const noFilter = { kind: 'exclude' as const, sets: new Set<ArtifactSetKey>() }\n  const result: RequestFilter = objectKeyMap(allSlotKeys, (_) => noFilter)\n\n  const counts = {\n    ...objectMap(exclusion, (_) => 0),\n    ...objectKeyMap(artSets, (_) => 0),\n  }\n  const allowedCounts = objectMap(exclusion, exclusionToAllowed)\n\n  function* check(shape: number[]) {\n    const used: Set<ArtifactSetKey> = new Set(),\n      rainbows: number[] = []\n    let groupped: number[][] = []\n    for (const i of shape) {\n      groupped.push([])\n      if (i === 5) rainbows.push(groupped.length - 1)\n      else groupped[i].push(groupped.length - 1)\n    }\n    groupped = groupped\n      .filter((v) => v.length)\n      .sort((a, b) => b.length - a.length)\n    let usableRainbows = rainbows.length\n\n    // Inception.. because js doesn't like functions inside a for-loop\n    function* check(i: number) {\n      if (i === groupped.length) return yield* check_free(0)\n\n      for (const set of artSets) {\n        if (used.has(set)) continue\n        const length = groupped[i].length,\n          allowedSet = allowedCounts[set]\n        let requiredRainbows = 0\n\n        if (allowedSet && !allowedSet.has(length)) {\n          // Look ahead and see if we have enough rainbows to fill to the next `allowedSet` if we use the current set\n          requiredRainbows =\n            (range(length + 1, 5).find((l) => allowedSet.has(l)) ?? 6) - length\n          if (requiredRainbows > usableRainbows) continue // Not enough rainbows. Next..\n        }\n\n        used.add(set)\n        counts[set] = groupped[i].length\n        groupped[i].forEach(\n          (j) =>\n            (result[allSlotKeys[j]] = {\n              kind: 'required',\n              sets: new Set([set]),\n            })\n        )\n        usableRainbows -= requiredRainbows\n\n        yield* check(i + 1)\n\n        usableRainbows += requiredRainbows\n        counts[set] = 0\n        used.delete(set)\n      }\n    }\n    // We separate filling rainbow slots from groupped slots because it has an entirely\n    // different set of rules regarding what can be filled and what states to be kept.\n    function* check_free(i: number) {\n      const remaining = rainbows.length - i,\n        isolated: ArtifactSetKey[] = [],\n        missing: ArtifactSetKey[] = [],\n        rejected: ArtifactSetKey[] = []\n      let required = 0\n      for (const set of artSets) {\n        const allowedSet = allowedCounts[set],\n          count = counts[set]\n        if (!allowedSet) continue\n        if (range(1, remaining).every((j) => !allowedSet.has(count + j)))\n          rejected.push(set)\n        else if (!allowedSet.has(count)) {\n          required += [...allowedSet].find((x) => x > count)! - count\n          missing.push(set)\n        } else if (range(0, remaining).some((j) => !allowedSet.has(count + j)))\n          isolated.push(set)\n      }\n      if (required > remaining) return\n      if (i === rainbows.length) {\n        yield { ...result }\n        return\n      }\n      if (required === remaining) {\n        for (const set of missing) {\n          counts[set]++\n          result[allSlotKeys[rainbows[i]]] = {\n            kind: 'required',\n            sets: new Set([set]),\n          }\n          yield* check_free(i + 1)\n          counts[set]--\n        }\n        return\n      }\n      for (const set of [...isolated, ...missing]) {\n        counts[set]++\n        result[allSlotKeys[rainbows[i]]] = {\n          kind: 'required',\n          sets: new Set([set]),\n        }\n        yield* check_free(i + 1)\n        counts[set]--\n      }\n      result[allSlotKeys[rainbows[i]]] = {\n        kind: 'exclude',\n        sets: new Set([...missing, ...rejected, ...isolated]),\n      }\n      yield* check_free(i + 1)\n    }\n    yield* check(0)\n  }\n  for (const shape of shapes) yield* check(shape)\n}\n\nexport type RequestFilter = StrictDict<\n  SlotKey,\n  | { kind: 'required'; sets: Set<ArtifactSetKey> }\n  | { kind: 'exclude'; sets: Set<ArtifactSetKey> }\n  | { kind: 'id'; ids: Set<string> }\n>\n\nexport type DynStat = { [key in string]: number }\nexport type ArtifactBuildData = {\n  id: string\n  set?: ArtifactSetKey\n  values: DynStat\n}\nexport type ArtifactsBySlot = {\n  base: DynStat\n  values: StrictDict<SlotKey, ArtifactBuildData[]>\n}\n\nexport type PlotData = Dict<number, Build>\nexport interface Build {\n  value: number\n  plot?: number\n  artifactIds: string[]\n}\n\nexport type DynMinMax = { [key in string]: MinMax }\nexport type MinMax = { min: number; max: number }\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { customMapFormula, forEachNodes } from '../../Formula/internal'\nimport type { OptNode } from '../../Formula/optimization'\nimport { allOperations } from '../../Formula/optimization'\nimport type { ConstantNode } from '../../Formula/type'\nimport { prod, threshold } from '../../Formula/utils'\nimport { assertUnreachable, cartesian } from '../../Util/Util'\nimport type { ArtifactsBySlot, MinMax } from '../common'\nimport { computeFullArtRange, computeNodeRange } from '../common'\nimport type { Linear } from './linearUB'\n\n/**\n * With xi being the variables and pi(x1, x2, ...) being polynomials on xi\n *    LinTerm  = $c + w1*x1 + w2*x2 + ...\n *    PolyProd = $k * p1 * p2 * ...\n *    PolySum  = $c + p1 + p2 + ...\n *\n * $c is used as additive constant, $k is used as multiplicative constant.\n */\nexport type PolynomialWithBounds = PolyProd | PolySum | LinTerm\ntype LinTerm = { type: 'lin'; lin: Linear; min: number; max: number }\ntype PolyProd = {\n  type: 'prod'\n  terms: PolynomialWithBounds[]\n  $k: number\n  min: number\n  max: number\n}\ntype PolySum = {\n  type: 'sum'\n  terms: PolynomialWithBounds[]\n  $c: number\n  min: number\n  max: number\n}\n\nfunction constP(n: number): LinTerm {\n  return { type: 'lin', lin: { $c: n }, min: n, max: n }\n}\nfunction readP(k: string, minmax: MinMax): LinTerm {\n  return { type: 'lin', lin: { [k]: 1, $c: 0 }, ...minmax }\n}\nfunction sumP(...terms: (PolynomialWithBounds | number)[]): PolySum {\n  const c = (terms.filter((v) => typeof v === 'number') as number[]).reduce(\n    (a, b) => a + b,\n    0\n  )\n  const poly = terms.filter(\n    (v) => typeof v !== 'number'\n  ) as PolynomialWithBounds[]\n  return {\n    type: 'sum',\n    terms: poly,\n    $c: c,\n    min: poly.reduce((a, { min }) => a + min, c),\n    max: poly.reduce((a, { max }) => a + max, c),\n  }\n}\nfunction prodP(...terms: (PolynomialWithBounds | number)[]): PolyProd {\n  const k = (terms.filter((v) => typeof v === 'number') as number[]).reduce(\n    (a, b) => a * b,\n    1\n  )\n  const poly = terms.filter(\n    (v) => typeof v !== 'number'\n  ) as PolynomialWithBounds[]\n  const minMax = poly.reduce(\n    ({ min: min1, max: max1 }, { min: min2, max: max2 }) => {\n      return {\n        min: Math.min(min1 * min2, min1 * max2, max1 * min2, max1 * max2),\n        max: Math.max(min1 * min2, min1 * max2, max1 * min2, max1 * max2),\n      }\n    },\n    { min: k, max: k }\n  )\n  return { type: 'prod', terms: poly, $k: k, ...minMax }\n}\n\nfunction slopePoint(\n  slope: number,\n  x0: number,\n  y0: number,\n  poly: PolynomialWithBounds\n): PolynomialWithBounds {\n  return sumP(y0 - slope * x0, prodP(slope, poly))\n}\nfunction interpolate(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  poly: PolynomialWithBounds,\n  upper: boolean\n): PolynomialWithBounds {\n  if (Math.abs(x0 - x1) < 1e-10)\n    return constP(upper ? Math.max(y0, y1) : Math.min(y0, y1))\n  return slopePoint((y1 - y0) / (x1 - x0), x0, y0, poly)\n}\n\nexport function polyUB(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot\n): SumOfMonomials[] {\n  const minMaxes = new Map<OptNode, MinMax>()\n  forEachNodes(\n    nodes,\n    (f) => {\n      const { operation } = f\n      if (operation === 'mul') minMaxes.set(f, { min: NaN, max: NaN })\n      switch (operation) {\n        case 'mul':\n        case 'min':\n        case 'max':\n        case 'threshold':\n        case 'res':\n        case 'sum_frac':\n          f.operands.forEach((op) => minMaxes.set(op, { min: NaN, max: NaN }))\n      }\n    },\n    (_) => _\n  )\n  const statMinMax = computeFullArtRange(arts)\n  const nodeRanges = computeNodeRange([...minMaxes.keys()], statMinMax)\n  for (const [node, minMax] of nodeRanges.entries()) minMaxes.set(node, minMax)\n\n  const upper = 'u',\n    lower = 'l',\n    exact = 'e'\n  type Context = typeof upper | typeof lower | typeof exact\n  const poly = customMapFormula<Context, PolynomialWithBounds, OptNode>(\n    nodes,\n    upper,\n    (f, context, _map) => {\n      const { operation } = f\n      const map: (op: OptNode, c?: Context) => PolynomialWithBounds = (\n        op,\n        c = context\n      ) => _map(op, c)\n      const oppositeContext = context === upper ? lower : upper\n\n      switch (operation) {\n        case 'const':\n          return constP(f.value)\n        case 'read':\n          return readP(f.path[1], minMaxes.get(f)!)\n        case 'add':\n          return sumP(...f.operands.map((op) => map(op)))\n        case 'mul': {\n          if (context === exact)\n            return prodP(...f.operands.map((op) => map(op)))\n          const { min: minf, max: maxf } = minMaxes.get(f)!\n          if (minf === maxf) return constP(minf) // Handles zero coeff\n          const zeroCrossing =\n            minf * maxf < 0 ||\n            f.operands.some((op) => {\n              const { min, max } = minMaxes.get(op)!\n              return min * max < 0\n            })\n          if (zeroCrossing) return map(f, exact)\n\n          const signf = minf === 0 ? maxf : minf\n          const op = allOperations[operation]\n          const k = op(\n            f.operands\n              .filter((op) => op.operation === 'const')\n              .map((c) => (c as ConstantNode<number>).value)\n          )\n          const polys = f.operands\n            .filter((op) => op.operation !== 'const')\n            .map((op) => {\n              const { min, max } = minMaxes.get(op)!\n              const sign = min === 0 ? max : min\n              const ctx = signf * sign > 0 ? context : oppositeContext\n              const p = map(op, ctx)\n\n              if (\n                (ctx === lower && max > 0 && p.min < -min) ||\n                (ctx === upper && min < 0 && p.max > -max)\n              )\n                throw new PolyError(\n                  'Unallowed large crossing post approximation',\n                  operation\n                )\n\n              return p\n            })\n          return prodP(k, ...polys)\n        }\n        case 'min':\n        case 'max': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          const op = allOperations[operation]\n          const xs = f.operands.filter((op) => op.operation !== 'const'),\n            [xOp] = xs\n          if (xs.length !== 1) throw new PolyError('Multivariate', operation)\n\n          const x = map(xOp),\n            c = op(\n              f.operands\n                .filter((op) => op.operation === 'const')\n                .map((c) => (c as ConstantNode<number>).value)\n            )\n          if (\n            (operation === 'max' && context === lower) ||\n            (operation === 'min' && context === upper)\n          )\n            return x\n          const { min, max } = minMaxes.get(xOp)!,\n            yMin = op([min, c]),\n            yMax = op([max, c])\n          return interpolate(min, yMin, max, yMax, x, context === upper)\n        }\n        case 'res': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          if (context === lower)\n            throw new PolyError('Unsupported direction', operation)\n          const op = allOperations[operation]\n          const [xOp] = f.operands,\n            { min, max } = minMaxes.get(xOp)!\n          const x = map(xOp, oppositeContext)\n          // Linear region 1 - base/2 or concave region with peak at base = 0\n          if (min < 0 && max < 1.75) return sumP(1, prodP(-0.5, x))\n          // Clamp `min` to guarantee upper bound\n          else\n            return interpolate(\n              min,\n              op([min]),\n              max,\n              op([max]),\n              x,\n              context === upper\n            )\n        }\n        case 'sum_frac': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          if (context === lower)\n            throw new PolyError('Unsupported direction', operation)\n          const [xOp, cOp] = f.operands\n          if (cOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          const x = map(xOp),\n            c = cOp.value,\n            { min, max } = minMaxes.get(xOp)!\n          if (min <= -c)\n            throw new PolyError('Unallowed negative argument', operation)\n          const loc = Math.sqrt((min + c) * (max + c))\n          return slopePoint(c / (loc + c) / (loc + c), loc, loc / (loc + c), x)\n        }\n        case 'threshold': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          const [vOp, tOp, pOp, fOp] = f.operands\n          if (tOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          const { min, max } = minMaxes.get(vOp)!\n          if (min >= tOp.value) return map(pOp)\n          if (max < tOp.value) return map(fOp)\n\n          if (fOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          if (pOp.operation !== 'const') {\n            if (fOp.value !== 0)\n              throw new PolyError('Unsupported pattern', operation)\n\n            const threshOp = threshold(vOp, tOp, 1, fOp),\n              mulOp = prod(threshOp, pOp)\n            // Populate `minMaxes` to ensure consistency\n            const { min, max } = minMaxes.get(pOp)!\n            minMaxes.set(threshOp, { min: 0, max: 1 })\n            minMaxes.set(mulOp, {\n              min: Math.min(min, 0),\n              max: Math.max(max, 0),\n            })\n            return map(mulOp)\n          }\n          const thresh = tOp.value,\n            pass = pOp.value,\n            fail = fOp.value\n          const isFirstHalf = pass > fail === (context === upper)\n\n          const v = map(vOp, isFirstHalf ? upper : lower)\n          if (isFirstHalf) {\n            const slope = (pass - fail) / (thresh - min)\n            return slopePoint(slope, thresh, pass, v)\n          }\n          // not first half -> return const(fail)\n          // Can also interpolate slopePoint on 2nd half, but I choose not to\n          return constP(fail)\n        }\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n\n  return poly.map((p) => expandPoly(p))\n}\n\nexport type SumOfMonomials = Monomial[]\ntype Monomial = {\n  $k: number\n  terms: string[]\n}\nfunction constM(v: number): Monomial {\n  return { $k: v, terms: [] }\n}\nfunction weightedReadM(key: string, v: number): Monomial {\n  return { $k: v, terms: [key] }\n}\nfunction sumM(...monomials: Monomial[][]): Monomial[] {\n  return monomials.flat()\n}\nfunction prodM(...monomials: Monomial[][]): Monomial[] {\n  return cartesian(...monomials).map((monos) =>\n    monos.reduce(\n      (ret, nxt) => {\n        ret.$k *= nxt.$k\n        ret.terms.push(...nxt.terms)\n        return ret\n      },\n      { $k: 1, terms: [] }\n    )\n  )\n}\nfunction foldLikeTerms(mon: Monomial[]): Monomial[] {\n  mon.forEach((m) => m.terms.sort())\n  mon.sort(({ terms: termsA }, { terms: termsB }) => {\n    if (termsA.length !== termsB.length) return termsA.length - termsB.length\n    for (let i = 0; i < termsA.length; i++) {\n      if (termsA[i] !== termsB[i]) return termsA[i] < termsB[i] ? -1 : +1\n    }\n    return 0\n  })\n\n  for (let i = mon.length - 2; i >= 0; i--) {\n    if (mon[i].$k === 0) {\n      mon.splice(i, 1)\n      continue\n    }\n    const a = mon[i].terms\n    const b = mon[i + 1].terms\n    if (a.length !== b.length) continue\n    if (a.every((ai, i) => ai === b[i])) {\n      mon[i].$k = mon[i].$k + mon[i + 1].$k\n      mon.splice(i + 1, 1)\n    }\n  }\n  return mon\n}\nfunction expandPoly(node: PolynomialWithBounds): SumOfMonomials {\n  function toExpandedPoly(n: PolynomialWithBounds): Monomial[] {\n    switch (n.type) {\n      case 'lin':\n        return Object.entries(n.lin)\n          .filter(([_, v]) => v !== 0)\n          .map(([k, v]) => {\n            if (k === '$c') return constM(v)\n            return weightedReadM(k, v)\n          })\n      case 'sum':\n        return sumM(...n.terms.map((t) => toExpandedPoly(t)), [constM(n.$c)])\n      case 'prod':\n        return prodM(...n.terms.map((t) => toExpandedPoly(t)), [constM(n.$k)])\n    }\n  }\n\n  return foldLikeTerms(toExpandedPoly(node))\n}\n\nclass PolyError extends Error {\n  constructor(cause: string, operation: string) {\n    super(\n      `Found ${cause} in ${operation} node when generating polynomial upper bound`\n    )\n  }\n}\n","// Matrix convention is row-major, indexed A_{ij} = A[i][j]\ntype Pivot = { i: number; j: number }\nconst zero = 1e-8 // Small number equivalent to 0 for numerical instability\n\n/** Checks that all constraints are satisfied (Ax <= b) */\nexport function isFeasible(Ab: number[][], x: number[]): boolean {\n  const b = x.length\n  return Ab.every(\n    (row) => x.reduce((tot, xi, i) => tot + xi * row[i], 0) <= row[b] + zero\n  )\n}\n\n/**\n * Solve a Linear Program defined by:\n *              min  c^T x\n *               x\n *   Subject to:     Ax <= b\n *                    x >= 0\n *\n * Implemented according to the Simplex Method (Sec 4) of:\n *   Ferguson, https://www.math.ucla.edu/~tom/LP.pdf\n *\n * Does not implement any cycle detection, though that *shouldnt* be a problem for GO's use\n *   case. This algorithm will always return a feasible solution, though it may be suboptimal.\n *\n * @param c        Objective vector\n * @param Ab       Constraints matrix with thresholds. Inputted in block form [A, b]\n * @returns        a valid solution x, optimal if everything went well.\n */\nexport function solveLP(c: number[], Ab: number[][]) {\n  const rows = Ab.length + 1\n  const cols = Ab[0].length\n\n  const tableau = Array(rows)\n    .fill(0)\n    .map((_) => Array(cols).fill(0))\n  Ab.forEach((Ai, i) => Ai.forEach((Aij, j) => (tableau[i][j] = Aij)))\n  c.forEach((cj, j) => (tableau[rows - 1][j] = cj))\n\n  const pivotHistory: Pivot[] = [] // Keep track of all chosen pivots for backtracking later\n\n  while (tableau.some((t, i) => i < rows - 1 && t[cols - 1] < -zero)) {\n    const piv = findPiv2(tableau)\n    pivotHistory.push(piv)\n    pivotInplace(tableau, piv)\n  }\n\n  while (tableau[rows - 1].some((t, j) => j < cols - 1 && t < -zero)) {\n    const piv = findPiv1(tableau)\n    pivotHistory.push(piv)\n    pivotInplace(tableau, piv)\n  }\n\n  const xOpt = c.map((_, i) => backtrack(tableau, pivotHistory, i))\n  if (!isFeasible(Ab, xOpt)) throw Error('COMPUTED SOLUTION IS NOT FEASIBLE')\n  return xOpt\n}\n\n/** Standard `pivot` operation on LPs */\nfunction pivotInplace(A: number[][], { i, j }: Pivot) {\n  const Aij = A[i][j]\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    for (let k = 0; k < A[0].length; k++) {\n      if (k === j) continue\n      A[h][k] -= (A[i][k] * A[h][j]) / Aij\n    }\n  }\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    A[h][j] = -A[h][j] / Aij\n  }\n  for (let k = 0; k < A[0].length; k++) {\n    if (k === j) continue\n    A[i][k] = A[i][k] / Aij\n  }\n  A[i][j] = 1 / Aij\n}\n\n/** Find a pivot according to Case 1 (Ferguson p23) */\nfunction findPiv1(A: number[][]) {\n  const r = A.length,\n    c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let j = 0; j < c - 1; j++) {\n    if (A[r - 1][j] >= -zero) continue\n    for (let i = 0; i < r - 1; i++) {\n      if (A[i][j] > zero) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('UNBOUNDED FEASIBLE')\n  }\n  if (minloc.i < 0) throw Error('NO PIVOTS (done)')\n  return { i: minloc.i, j: minloc.j }\n}\n\n/** Find a pivot according to Case 2 (Ferguson p24) */\nfunction findPiv2(A: number[][]) {\n  const r = A.length,\n    c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let i = 0; i < r - 1; i++) {\n    if (A[i][c - 1] >= -zero) continue\n    for (let j = 0; j < c - 1; j++) {\n      if (A[i][j] < -zero) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('INFEASIBLE')\n    return { i: minloc.i, j: minloc.j }\n  }\n  throw Error('NO PIVOTS (done)')\n}\n\n/** Backtracking algorithm to find solution vector */\nfunction backtrack(tableau: number[][], pivotHistory: Pivot[], targ: number) {\n  let side = 1 // 0 left, 1 right\n  pivotHistory.forEach(({ i, j }) => {\n    if (side === 1 && j === targ) {\n      targ = i\n      side = 0\n    } else if (side === 0 && i === targ) {\n      targ = j\n      side = 1\n    }\n  })\n\n  const ncol = tableau[0].length\n  return side === 0 ? tableau[targ][ncol - 1] : 0\n}\n","import type { OptNode } from '../../Formula/optimization'\nimport { assertUnreachable, cartesian } from '../../Util/Util'\nimport type { ArtifactsBySlot, DynStat, MinMax } from '../common'\nimport { computeFullArtRange } from '../common'\nimport { polyUB } from './polyUB'\nimport { solveLP } from './solveLP'\n\nexport type Linear = DynStat & { $c: number }\n\nfunction weightedSum(\n  ...entries: readonly (readonly [number, Linear])[]\n): Linear {\n  const result = { $c: 0 }\n  for (const [weight, entry] of entries)\n    for (const [k, v] of Object.entries(entry))\n      result[k] = (result[k] ?? 0) + weight * v\n  return result\n}\n\nexport function linearUB(nodes: OptNode[], arts: ArtifactsBySlot): Linear[] {\n  const polys = polyUB(nodes, arts)\n  const minMax = computeFullArtRange(arts)\n\n  return polys.map((poly) =>\n    weightedSum(\n      ...poly.map((mon) => {\n        const bounds = mon.terms.map((key) => minMax[key])\n        const { w, $c } = linbound(bounds, mon.$k >= 0 ? 'upper' : 'lower')\n        const linboi: Linear = { $c }\n        mon.terms.forEach((key, i) => (linboi[key] = w[i] + (linboi[key] ?? 0)))\n        return [mon.$k, linboi] as readonly [number, Linear]\n      })\n    )\n  )\n}\n\n/**\n * Constructs a linear upper/lower bound for a monomial on a bounded domain using an LP.\n *\n * Monomial is assumed to be\n *    m(x) = x1 * x2 * ... * xn\n * on bounded domain\n *    min_1 <= x1 <= max_1\n *    min_2 <= x2 <= max_2\n *    ...\n *    min_n <= xn <= max_n\n *\n * @param bounds List of min & max bounds for each xi\n * @returns A linear function L(x) = w . x + $c\n *            satisfying      m(x) <= L(x) <= m(x) + err (resp. m(x) - err <= L(x) <= m(x))\n */\nfunction linbound(\n  bounds: MinMax[],\n  direction: 'upper' | 'lower' = 'upper'\n): { w: number[]; $c: number; err: number } {\n  if (bounds.length === 0) return { w: [], $c: 1, err: 0 } // vacuous product is 0\n  const nVar = bounds.length\n\n  // Re-scale bounds to [0, 1] for numerical stability.\n  const boundScale = bounds.map(({ min, max }) => Math.max(-min, max))\n  const scaleProd = boundScale.reduce((prod, v) => prod * v, 1)\n  bounds = bounds.map(({ min, max }, i) => ({\n    min: min / boundScale[i],\n    max: max / boundScale[i],\n  }))\n  // Setting up the linear program in terms of constraints.\n  //   cartesian(bounds) loops 2^nVar times\n  const cons = cartesian(...bounds.map(({ min, max }) => [min, max])).flatMap(\n    (coords) => {\n      const prod = coords.reduce((prod, v) => prod * v, 1)\n      const sum = coords.reduce((sum, v) => sum + v, 0)\n      switch (direction) {\n        case 'upper':\n          return [\n            [...coords, -1, 0, sum - prod - nVar],\n            [...coords.map((v) => -v), 1, -1, nVar + prod - sum],\n          ]\n        case 'lower':\n          return [\n            [...coords.map((v) => -v), -1, 0, prod - sum - nVar],\n            [...coords, 1, -1, nVar + sum - prod],\n          ]\n        default:\n          assertUnreachable(direction)\n      }\n    }\n  )\n\n  const objective = [...bounds.map((_) => 0), 0, 1]\n  try {\n    const soln = solveLP(objective, cons)\n    switch (direction) {\n      case 'upper':\n        return {\n          w: soln\n            .slice(0, nVar)\n            .map((wi, i) => ((1 - wi) * scaleProd) / boundScale[i]),\n          $c: scaleProd * (soln[nVar] - nVar),\n          err: scaleProd * soln[nVar + 1],\n        }\n      case 'lower':\n        return {\n          w: soln\n            .slice(0, nVar)\n            .map((wi, i) => ((1 - wi) * scaleProd) / boundScale[i]),\n          $c: scaleProd * (nVar - soln[nVar]),\n          err: scaleProd * soln[nVar + 1],\n        }\n      default:\n        assertUnreachable(direction)\n    }\n  } catch (e) {\n    console.log('ERROR on bounds', bounds)\n    console.log('Possibly numerical instability issue.')\n    console.log(e)\n    throw e\n  }\n}\n","import type { Interim, Setup } from '..'\nimport type { OptNode } from '../../Formula/optimization'\nimport type { ArtifactSlotKey } from '@genshin-optimizer/consts'\nimport { objectKeyValueMap, objectMap } from '../../Util/Util'\nimport type {\n  ArtifactBuildData,\n  ArtifactsBySlot,\n  DynStat,\n  RequestFilter,\n} from '../common'\nimport { countBuilds, filterArts, pruneAll } from '../common'\nimport type { SplitWorker } from './BackgroundWorker'\nimport { linearUB } from './linearUB'\n\ntype Approximation = {\n  base: number\n  /** optimization target contribution from a given artifact (id) */\n  conts: StrictDict<string, number>\n}\ntype Filter = {\n  nodes: OptNode[]\n  arts: ArtifactsBySlot\n  /**\n   * The contribution of each artifact to the optimization target. The (over)estimated\n   * optimization target value is the sum of contributions of all artifacts in the build.\n   */\n  approxs: Approximation[]\n  maxConts: Record<ArtifactSlotKey, number>[]\n  /** How many times has this filter been splitted */\n  age: number\n  /** Total number of builds in this filter */\n  count: number\n  /** Whether or not this filter is in a valid (calculated) state */\n  calculated?: boolean\n}\nexport class BNBSplitWorker implements SplitWorker {\n  min: number[]\n  nodes: OptNode[]\n  arts: ArtifactsBySlot\n  topN: number\n\n  /**\n   * Filters are not neccessarily in a valid state, i.e., \"calculated\".\n   * We amortize the calculation to 1-per-split so that the calculation\n   * overhead doesn't lead to lag.\n   */\n  filters: Filter[] = []\n  interim: Interim | undefined\n  firstUncalculated = 0\n\n  callback: (interim: Interim) => void\n\n  constructor(\n    { arts, optTarget, constraints, topN }: Setup,\n    callback: (interim: Interim) => void\n  ) {\n    this.arts = arts\n    this.min = [-Infinity, ...constraints.map((x) => x.min)]\n    this.nodes = [optTarget, ...constraints.map((x) => x.value)]\n    this.callback = callback\n    this.topN = topN\n\n    // make sure we can approximate it\n    linearUB(this.nodes, arts)\n  }\n\n  addFilter(filter: RequestFilter): void {\n    const arts = filterArts(this.arts, filter),\n      count = countBuilds(arts)\n    if (count)\n      this.filters.push({\n        nodes: this.nodes,\n        arts,\n        maxConts: [],\n        approxs: [],\n        age: 0,\n        count,\n      })\n  }\n  setThreshold(newThreshold: number): void {\n    if (newThreshold > this.min[0]) {\n      this.min[0] = newThreshold\n      // All calculations become stale\n      this.firstUncalculated = 0\n      this.filters.forEach((filter) => delete filter.calculated)\n    }\n  }\n  *split(filter: RequestFilter, minCount: number): Generator<RequestFilter> {\n    this.addFilter(filter)\n\n    while (this.filters.length) {\n      const filter = this.getApproxFilter(),\n        { arts, count } = filter\n\n      if (count <= minCount) {\n        if (!count) continue\n        if (this.firstUncalculated < this.filters.length)\n          this.calculateFilter(this.firstUncalculated++) // Amortize the filter calculation to 1-per-split\n\n        this.reportInterim(false)\n        yield objectMap(arts.values, (arts) => ({\n          kind: 'id' as const,\n          ids: new Set(arts.map((art) => art.id)),\n        }))\n      } else this.splitOldFilter(filter)\n    }\n\n    this.reportInterim(true)\n  }\n\n  reportInterim(forced = false) {\n    if (this.interim && (this.interim.skipped > 1000000 || forced === true)) {\n      this.callback(this.interim)\n      this.interim = undefined\n    }\n  }\n\n  splitOldFilter({ nodes, arts, approxs, age }: Filter) {\n    /**\n     * Split the artifacts in each slot into high/low main (index 0) contribution along 1/3 of the\n     * contribution range. If the main contribution of a slot is in range 500-2000, the the high-\n     * contibution artifact has contribution of at least 1500, and the rest are low-contribution.\n     */\n    const splitted = objectMap(arts.values, (arts) => {\n      const remaining = arts\n        .map((art) => ({ art, cont: approxs[0].conts[art.id] }))\n        .sort(({ cont: c1 }, { cont: c2 }) => c2 - c1)\n      const minCont = remaining[remaining.length - 1]?.cont ?? 0\n      let contCutoff =\n        remaining.reduce(\n          (accu, { cont }) => accu + cont,\n          -minCont * remaining.length\n        ) / 3\n\n      const index = Math.max(\n        1,\n        remaining.findIndex(({ cont }) => (contCutoff -= cont - minCont) <= 0)\n      )\n      const lowArts = remaining.splice(index).map(({ art }) => art),\n        highArts = remaining.map(({ art }) => art)\n      return {\n        high: {\n          arts: highArts,\n          maxConts: approxs.map((approx) => maxContribution(highArts, approx)),\n        },\n        low: {\n          arts: lowArts,\n          maxConts: approxs.map((approx) => maxContribution(lowArts, approx)),\n        },\n      }\n    })\n    const remaining = Object.keys(splitted),\n      { filters } = this\n    const current: StrictDict<ArtifactSlotKey, ArtifactBuildData[]> = {} as any\n    const currentCont: StrictDict<ArtifactSlotKey, number[]> = {} as any\n    function partialSplit(count: number) {\n      if (!remaining.length) {\n        const maxConts = approxs.map((_, i) =>\n          objectMap(currentCont, (val) => val[i])\n        )\n        const currentArts = { base: arts.base, values: { ...current } }\n        filters.push({\n          nodes,\n          arts: currentArts,\n          maxConts,\n          approxs,\n          age: age + 1,\n          count,\n        })\n        return\n      }\n      const slot = remaining.pop()!,\n        { high, low } = splitted[slot]\n      if (low.arts.length) {\n        current[slot] = low.arts\n        currentCont[slot] = low.maxConts\n        partialSplit(count * low.arts.length)\n      }\n      if (high.arts.length) {\n        current[slot] = high.arts\n        currentCont[slot] = high.maxConts\n        partialSplit(count * high.arts.length)\n      }\n      remaining.push(slot)\n    }\n    partialSplit(1)\n  }\n\n  /** *Precondition*: `this.filters` must not be empty */\n  getApproxFilter(): Filter {\n    this.calculateFilter(this.filters.length - 1)\n    if (this.firstUncalculated > this.filters.length)\n      this.firstUncalculated = this.filters.length\n    return this.filters.pop()!\n  }\n  /** Update calculate on filter at index `i` if not done so already */\n  calculateFilter(i: number): void {\n    let { nodes, arts, maxConts, approxs } = this.filters[i]\n    const { age, count: oldCount, calculated } = this.filters[i]\n    if (calculated) return\n    if (age < 3 || age % 5 === 2) {\n      // Make sure the condition includes initial filter `age === 0`\n      // Either the filter is so early that we can get a good cutoff, or the problem has\n      // gotten small enough that the old approximation becomes inaccurate\n      ;({ nodes, arts } = pruneAll(\n        nodes,\n        this.min,\n        arts,\n        this.topN,\n        {},\n        { pruneNodeRange: true }\n      ))\n      if (Object.values(arts.values).every((x) => x.length)) {\n        approxs = approximation(nodes, arts)\n        maxConts = approxs.map((approx) =>\n          objectMap(arts.values, (val) => maxContribution(val, approx))\n        )\n      }\n    }\n    // Removing artifacts that doesn't meet the required opt target contributions.\n    //\n    // We could actually loop `newValues` computation if the removed artifacts have\n    // the highest contribution in one of the target node as the removal will raise\n    // the required contribution even further. However, once is generally enough.\n    const leadingConts = maxConts.map((cont, i) =>\n      Object.values(cont).reduce(\n        (accu, val) => accu + val,\n        approxs[i].base - this.min[i]\n      )\n    )\n    const newValues = objectMap(arts.values, (arts, slot) => {\n      const requiredConts = leadingConts.map((lc, i) => maxConts[i][slot] - lc)\n      return arts.filter(({ id }) =>\n        approxs.every(({ conts }, i) => conts[id] >= requiredConts[i])\n      )\n    })\n    arts = { base: arts.base, values: newValues }\n    const newCount = countBuilds(arts)\n    if (newCount !== oldCount)\n      if (this.interim) this.interim.skipped += oldCount - newCount\n      else\n        this.interim = {\n          resultType: 'interim',\n          buildValues: undefined,\n          tested: 0,\n          failed: 0,\n          skipped: oldCount - newCount,\n        }\n    this.filters[i] = {\n      nodes,\n      arts,\n      maxConts,\n      approxs,\n      age,\n      count: newCount,\n      calculated: true,\n    }\n  }\n}\n\nfunction maxContribution(\n  arts: ArtifactBuildData[],\n  approximation: Approximation\n): number {\n  return Math.max(...arts.map(({ id }) => approximation.conts[id]!))\n}\nfunction approximation(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot\n): Approximation[] {\n  return linearUB(nodes, arts).map((weight) => ({\n    base: dot(arts.base, weight, weight.$c),\n    conts: objectKeyValueMap(Object.values(arts.values).flat(), (data) => [\n      data.id,\n      dot(data.values, weight, 0),\n    ]),\n  }))\n}\nfunction dot(values: DynStat, lin: DynStat, c: number): number {\n  return Object.entries(values).reduce(\n    (accu, [k, v]) => accu + (lin[k] ?? 0) * v,\n    c\n  )\n}\n","import type { Interim, Setup } from '..'\nimport type { OptNode } from '../../Formula/optimization'\nimport { optimize, precompute } from '../../Formula/optimization'\nimport type {\n  ArtifactBuildData,\n  ArtifactsBySlot,\n  Build,\n  PlotData,\n  RequestFilter,\n} from '../common'\nimport { countBuilds, filterArts, mergePlot, pruneAll } from '../common'\n\nexport class ComputeWorker {\n  builds: Build[] = []\n  buildValues: number[] | undefined = undefined\n  plotData: PlotData | undefined\n  threshold = -Infinity\n  topN: number\n  min: number[]\n\n  arts: ArtifactsBySlot\n  nodes: OptNode[]\n\n  callback: (interim: Interim) => void\n\n  constructor(\n    { arts, optTarget, constraints, plotBase, topN }: Setup,\n    callback: (interim: Interim) => void\n  ) {\n    this.arts = arts\n    this.min = constraints.map((x) => x.min)\n    this.topN = topN\n    this.callback = callback\n    this.nodes = constraints.map((x) => x.value)\n    this.nodes.push(optTarget)\n    if (plotBase) {\n      this.plotData = {}\n      this.nodes.push(plotBase)\n    }\n    this.nodes = optimize(this.nodes, {}, (_) => false)\n  }\n\n  setThreshold(newThreshold: number) {\n    if (this.threshold > newThreshold) this.threshold = newThreshold\n  }\n  compute(filter: RequestFilter) {\n    const { min } = this\n    let preArts = filterArts(this.arts, filter)\n    const totalCount = countBuilds(preArts),\n      oldMaxBuildCount = this.builds.length\n\n    let nodes = this.nodes\n    ;({ nodes, arts: preArts } = pruneAll(\n      nodes,\n      min,\n      preArts,\n      this.topN,\n      {},\n      {\n        pruneArtRange: true,\n        pruneNodeRange: true,\n      }\n    ))\n    const arts = Object.values(preArts.values).sort(\n      (a, b) => a.length - b.length\n    )\n    const compute = precompute(\n      nodes,\n      preArts.base,\n      (f) => f.path[1],\n      arts.length\n    )\n\n    const buffer = Array<ArtifactBuildData>(arts.length)\n    const count = {\n      tested: 0,\n      failed: 0,\n      skipped: totalCount - countBuilds(preArts),\n    }\n\n    const permute = (i: number) => {\n      if (i < 0) {\n        const result = compute(buffer)\n        if (min.every((m, i) => m <= result[i])) {\n          const value = result[min.length],\n            { builds, plotData } = this\n          let build: Build | undefined\n          if (value >= this.threshold) {\n            build = {\n              value,\n              artifactIds: buffer.map((x) => x.id).filter((id) => id),\n            }\n            builds.push(build)\n          }\n          if (plotData) {\n            const x = result[min.length + 1]\n            if (!plotData[x] || plotData[x]!.value < value) {\n              if (!build)\n                build = {\n                  value,\n                  artifactIds: buffer.map((x) => x.id).filter((id) => id),\n                }\n              build.plot = x\n              plotData[x] = build\n            }\n          }\n        } else count.failed += 1\n        return\n      }\n      arts[i].forEach((art) => {\n        buffer[i] = art\n        permute(i - 1)\n      })\n      if (i === 0) {\n        count.tested += arts[0].length\n        if (count.tested > 1 << 16) this.interimReport(count)\n      }\n    }\n\n    permute(arts.length - 1)\n    this.interimReport(count, this.builds.length > oldMaxBuildCount)\n  }\n\n  refresh(force: boolean): void {\n    const { topN } = this\n    if (Object.keys(this.plotData ?? {}).length >= 100000)\n      this.plotData = mergePlot([this.plotData!])\n\n    if (this.builds.length >= 1000 || force) {\n      this.builds = this.builds.sort((a, b) => b.value - a.value).slice(0, topN)\n      this.buildValues = this.builds.map((x) => x.value)\n      this.threshold = Math.max(\n        this.threshold,\n        this.buildValues[topN - 1] ?? -Infinity\n      )\n    }\n  }\n  interimReport(\n    count: { tested: number; failed: number; skipped: number },\n    forced = false\n  ) {\n    this.refresh(forced)\n    this.callback({\n      resultType: 'interim',\n      buildValues: this.buildValues,\n      ...count,\n    })\n    this.buildValues = undefined\n    count.tested = 0\n    count.failed = 0\n    count.skipped = 0\n  }\n}\n","import { allArtifactSlotKeys } from '@genshin-optimizer/consts'\nimport type { Interim, Setup } from '..'\nimport { assertUnreachable } from '../../Util/Util'\nimport type { ArtifactsBySlot, RequestFilter } from '../common'\nimport { countBuilds, filterArts } from '../common'\nimport type { SplitWorker } from './BackgroundWorker'\n\nexport class DefaultSplitWorker implements SplitWorker {\n  arts: ArtifactsBySlot\n  stack: { filter: RequestFilter; count: number; splittedBy: 'id' | 'set' }[] =\n    []\n\n  constructor({ arts }: Setup, _callback: (interim: Interim) => void) {\n    this.arts = arts\n  }\n\n  setThreshold(_newThreshold: number): void {}\n  add(\n    filter: RequestFilter,\n    splittedBy: (typeof this.stack)[number]['splittedBy']\n  ) {\n    this.stack.push({\n      filter,\n      count: countBuilds(filterArts(this.arts, filter)),\n      splittedBy,\n    })\n  }\n  *split(filter: RequestFilter, minCount: number): Generator<RequestFilter> {\n    this.add(filter, 'set')\n    for (let current = this.stack.pop(); current; current = this.stack.pop()) {\n      const { filter, count, splittedBy } = current\n      if (count <= minCount) {\n        yield filter\n        continue\n      }\n\n      switch (splittedBy) {\n        case 'set':\n          this.splitBySet(filter)\n          break\n        case 'id':\n          this.splitByID(filter, count, minCount)\n          break\n        default:\n          assertUnreachable(splittedBy)\n      }\n    }\n  }\n\n  splitBySet(filter: RequestFilter): void {\n    const arts = filterArts(this.arts, filter)\n    const candidates = allArtifactSlotKeys\n      .map((slot) => ({\n        slot,\n        sets: new Set(arts.values[slot].map((x) => x.set)),\n      }))\n      .filter(({ sets }) => sets.size > 1)\n\n    if (!candidates.length) return this.add(filter, 'id')\n\n    const { sets, slot } = candidates.reduce((a, b) =>\n      a.sets.size < b.sets.size ? a : b\n    )\n    sets.forEach((set) =>\n      this.add(\n        { ...filter, [slot]: { kind: 'required', sets: new Set([set]) } },\n        'set'\n      )\n    )\n  }\n  splitByID(filter: RequestFilter, count: number, minCount: number): void {\n    const arts = filterArts(this.arts, filter)\n    const { slot, length } = allArtifactSlotKeys\n      .map((slot) => ({ slot, length: arts.values[slot].length }))\n      .filter((x) => x.length > 1)\n      // We always have entries because `count > 1`\n      .reduce((a, b) => (a.length < b.length ? a : b))\n\n    const numChunks = Math.ceil(count / minCount)\n    const boundedNumChunks = Math.min(numChunks, length)\n    const chunk = Array(boundedNumChunks)\n      .fill(0)\n      .map((_) => new Set<string>())\n    arts.values[slot].forEach(({ id }, i) =>\n      chunk[i % boundedNumChunks].add(id)\n    )\n    chunk.forEach((ids) =>\n      this.add({ ...filter, [slot]: { kind: 'id', ids } }, 'id')\n    )\n  }\n}\n","import type { WorkerCommand, WorkerResult } from '..'\nimport { assertUnreachable } from '../../Util/Util'\nimport type { RequestFilter } from '../common'\nimport {\n  artSetPerm,\n  countBuilds,\n  filterArts,\n  filterFeasiblePerm,\n} from '../common'\nimport { BNBSplitWorker } from './BNBSplitWorker'\nimport { ComputeWorker } from './ComputeWorker'\nimport { DefaultSplitWorker } from './DefaultSplitWorker'\n\ndeclare function postMessage(command: WorkerCommand | WorkerResult): void\n\nlet splitWorker: SplitWorker, computeWorker: ComputeWorker\n\nasync function handleEvent(e: MessageEvent<WorkerCommand>): Promise<void> {\n  const { data } = e,\n    { command } = data\n  switch (command) {\n    case 'split':\n      for (const filter of splitWorker.split(\n        data.filter,\n        data.maxIterateSize\n      )) {\n        postMessage({ command: 'iterate', filter })\n        // Suspend here in case a `threshold` is sent over\n        //\n        // Make sure to use task-based mechanisms such as `setTimeout` so that\n        // this function suspends until the next event loop. If we instead use\n        // microtask-based ones such as `Promise.resolved`, the suspension will\n        // not be long enough.\n        await new Promise((r) => setTimeout(r))\n      }\n      break\n    case 'iterate':\n      computeWorker.compute(data.filter)\n      break\n    case 'threshold': {\n      splitWorker.setThreshold(data.threshold)\n      computeWorker.setThreshold(data.threshold)\n      return // This is a fire-and-forget command\n    }\n    case 'finalize': {\n      computeWorker.refresh(true)\n      const { builds, plotData } = computeWorker\n      postMessage({ resultType: 'finalize', builds, plotData })\n      break\n    }\n    case 'count': {\n      const { exclusion, maxIterateSize } = data,\n        arts = computeWorker.arts\n      const perms = filterFeasiblePerm(\n        artSetPerm(exclusion, [\n          ...new Set(\n            Object.values(arts.values).flatMap((x) => x.map((x) => x.set!))\n          ),\n        ]),\n        arts\n      )\n      let count = 0\n      for (const filter of perms) {\n        postMessage({ command: 'split', filter, maxIterateSize })\n        count += countBuilds(filterArts(arts, filter))\n      }\n      postMessage({ resultType: 'count', count })\n      break\n    }\n    case 'setup':\n      try {\n        splitWorker = new BNBSplitWorker(data, (x) => postMessage(x))\n      } catch {\n        splitWorker = new DefaultSplitWorker(data, (x) => postMessage(x))\n      }\n      computeWorker = new ComputeWorker(data, (x) => postMessage(x))\n      break\n    default:\n      assertUnreachable(command)\n  }\n  postMessage({ resultType: 'done' })\n}\nonmessage = async (e: MessageEvent<WorkerCommand>) => {\n  try {\n    await handleEvent(e)\n  } catch (e) {\n    postMessage({ resultType: 'err', message: (e as any).message })\n  }\n}\n\nexport interface SplitWorker {\n  split(filter: RequestFilter, minCount: number): Iterable<RequestFilter>\n  setThreshold(newThreshold: number): void\n}\n"],"names":["objPathValue","obj","keys","Array","isArray","console","error","reduce","a","k","objectKeyMap","map","Object","fromEntries","i","objectKeyValueMap","items","t","objectMap","fn","entries","v","rangeGen","from","to","range","assertUnreachable","value","Error","cartesian","q","b","flatMap","d","e","flat","constant","NaN","name","percent","info","operation","operands","type","Number","MAX_VALUE","Infinity","unit","sum","values","intoOps","dynRead","accu","path","intoV","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","forEach","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","arrayEqual","set","result","customMapFormula","context","contextMapping","internalMap","current","mapping","old","newFormula","undefined","length","every","allCommutativeMonoidOperations","min","x","Math","max","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","flatten","f","_formula","flattened","dep","deduplicate","elementCounts","array","wrap","common","counts","next","factored","count","fill","candidatesByOperation","remainingCounts","filter","push","currentCounts","commonCounts","nextCounts","total","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","constantFold","topLevelData","shouldFold","origin","data","processed","nextContextMap","fold","c","foldStr","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","op","smallest","operand","v1","v2","match","unmatch","list","reset","nextMap","nextContext","nonTravelerCharacterKeys","allTravelerKeys","allArtifactSlotKeys","allWeaponSwordKeys","allWeaponClaymoreKeys","allWeaponPolearmKeys","allWeaponBowKeys","allWeaponCatalystKeys","allSlotKeys","travelerKeys","pruneAll","nodes","minimum","arts","numTop","exclusion","forced","should","deps","pruneNodeRange","reaffine","pruneOrder","pruneArtRange","some","newArts","newNodes","forceRename","affineNodes","topLevelAffine","visit","node","isAffine","dynKeys","_","affineOps","nonAffineOps","affine","nonConst","base","size","nextDynKey","affineMap","reaffineArt","stat","dyn","slot","id","offsets","key","baseValue","progress","allowRainbow","rainbow","noSwitchIn","noSwitchOut","includes","newList","art","other","otherBetterEqual","otherMaybeBetter","otherBetter","canSwitch","baseRange","artRanges","computeArtRange","otherArtRanges","addArtRange","read","newRange","computeNodeRange","nodeRange","operandRanges","newOperands","op1","op2","ranges","computeFullArtRange","reads","computeMinMax","minMaxes","filterArts","filters","kind","ids","sets","countBuilds","_count","exclusionToAllowed","artSetPerm","_artSets","artSets","allowedRainbows","shapes","indexOfShape","shape","replacing","populateShapes","rainbows","j","required","slice","remaining","noFilter","allowedCounts","used","groupped","sort","usableRainbows","check_free","isolated","missing","rejected","allowedSet","requiredRainbows","l","constP","n","lin","$c","sumP","terms","poly","prodP","minMax","min1","max1","min2","max2","$k","slopePoint","slope","x0","y0","interpolate","x1","y1","upper","abs","polyUB","statMinMax","nodeRanges","lower","exact","_map","oppositeContext","minmax","minf","maxf","zeroCrossing","signf","polys","ctx","p","PolyError","xs","xOp","cOp","loc","sqrt","vOp","tOp","pOp","fOp","threshOp","ge","le","mulOp","prod","thresh","isFirstHalf","toExpandedPoly","constM","weightedReadM","monomials","sumM","monos","ret","nxt","prodM","mon","m","termsA","termsB","splice","ai","foldLikeTerms","expandPoly","constructor","cause","super","zero","solveLP","Ab","rows","cols","tableau","Ai","Aij","cj","pivotHistory","piv","findPiv2","pivotInplace","findPiv1","xOpt","targ","side","ncol","backtrack","row","tot","xi","isFeasible","A","h","r","minloc","cmp","linearUB","weight","entry","weightedSum","bounds","w","direction","err","nVar","boundScale","scaleProd","cons","coords","objective","soln","wi","log","linbound","linboi","BNBSplitWorker","optTarget","constraints","topN","callback","interim","firstUncalculated","this","addFilter","maxConts","approxs","age","setThreshold","newThreshold","calculated","minCount","getApproxFilter","calculateFilter","reportInterim","splitOldFilter","skipped","splitted","cont","conts","c1","c2","minCont","contCutoff","findIndex","lowArts","highArts","high","approx","maxContribution","low","currentCont","partialSplit","val","currentArts","pop","oldCount","dot","approximation","leadingConts","newValues","requiredConts","lc","newCount","resultType","buildValues","tested","failed","ComputeWorker","plotBase","builds","plotData","opts","optimize","compute","preArts","totalCount","oldMaxBuildCount","initial","binding","slotCount","body","names","operandNames","arr","toString","join","Function","precompute","buffer","permute","build","artifactIds","plot","interimReport","refresh","force","plots","scale","round","mergePlot","DefaultSplitWorker","_callback","stack","_newThreshold","splittedBy","splitBySet","splitByID","numChunks","ceil","boundedNumChunks","chunk","splitWorker","computeWorker","async","handleEvent","command","split","maxIterateSize","postMessage","Promise","setTimeout","perms","filter_loop","available","s","filterFeasiblePerm","onmessage","message"],"sourceRoot":""}