{"version":3,"file":"156.e9a1657727ed7bb7.js","mappings":"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UACA,oBACA,OACA,SACA,kBACA,SACA,UACA,YACA,QACA,WACA,QACA,WACA,YACA,OACA,UACA,SACA,UACA,SACA,SACA,QACA,UACA,SACA,WAGWC,EAAkB,CAC7B,gBACA,cACA,kBACA,kBChHK,MAiDMC,EAAsB,CACjC,SACA,QACA,QACA,SACA,WC7CWC,EAAqB,CAChC,kBACA,gBACA,sBACA,kBACA,YACA,oBACA,gBACA,YACA,gBACA,kBACA,cACA,eACA,oBACA,kBACA,YACA,iBACA,wBACA,YACA,uBACA,uBACA,mBACA,iBACA,mBACA,eACA,cACA,gBACA,eACA,eACA,oBACA,gBACA,gBACA,WACA,kBACA,sBACA,mBAIWC,EAAwB,CACnC,YACA,qBACA,oBACA,yBACA,aACA,qBACA,gBACA,gBACA,wBACA,cACA,mBACA,eACA,qBACA,cACA,mBACA,cACA,uBACA,kBACA,wBACA,eACA,qBACA,eACA,uBACA,oBACA,UACA,cACA,mBACA,aACA,sBACA,mBAIWC,EAAuB,CAClC,qBACA,iBACA,cACA,kBACA,eACA,aACA,cACA,mBACA,qBACA,gBACA,UACA,YACA,mBACA,cACA,mBACA,cACA,4BACA,uBACA,aACA,eACA,cACA,yBACA,WACA,mBACA,kBACA,eAIWC,EAAmB,CAC9B,cACA,UACA,gBACA,mBACA,cACA,iBACA,eACA,iBACA,iBACA,WACA,aACA,cACA,cACA,YACA,oBACA,aACA,YACA,WACA,oBACA,WACA,aACA,WACA,OACA,iBACA,qBACA,oBACA,cACA,YACA,gBACA,qBACA,kBACA,gBAIWC,EAAwB,CACnC,mBACA,0BACA,kBACA,cACA,aACA,sBACA,kBACA,gBACA,cACA,qBACA,eACA,gBACA,6BACA,aACA,YACA,eACA,eACA,oBACA,iBACA,iBACA,kBACA,gBACA,uBACA,eACA,aACA,aACA,gCACA,0BACA,eACA,oBACA,eC3JWC,EAAc,CACzB,SACA,QACA,QACA,SACA,WA0EWC,EAAe,CAC1B,gBACA,cACA,kBACA,kBC9FK,SAA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","sources":["webpack:///./src/app/Util/Util.ts","webpack:///./src/app/Formula/utils.ts","webpack:///./src/app/Formula/internal.ts","webpack:///./src/app/Formula/optimization.ts","webpack:///../../libs/consts/src/character.ts","webpack:///../../libs/consts/src/artifact.ts","webpack:///../../libs/consts/src/weapon.ts","webpack:///./src/app/Types/consts.ts","webpack:///./src/app/Solver/common.ts","webpack:///./src/app/Solver/GOSolver/polyUB.ts","webpack:///./src/app/Solver/GOSolver/solveLP.ts","webpack:///./src/app/Solver/GOSolver/linearUB.ts","webpack:///./src/app/Solver/GOSolver/BNBSplitWorker.ts","webpack:///./src/app/Solver/GOSolver/ComputeWorker.ts","webpack:///./src/app/Solver/GOSolver/DefaultSplitWorker.ts","webpack:///./src/app/Solver/GOSolver/BackgroundWorker.ts"],"sourcesContent":["export const getRandomElementFromArray = <T>(array: readonly T[]): T =>\n  array[Math.floor(Math.random() * array.length)]\nexport function getRandomInt(min, max) {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  return Math.floor(Math.random() * (max - min) + min) //The maximum is exclusive and the minimum is inclusive\n}\nexport function getRandomIntInclusive(min, max) {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  return Math.floor(Math.random() * (max - min + 1) + min) //The maximum is inclusive and the minimum is inclusive\n}\nexport function getRandomArbitrary(min, max) {\n  return Math.random() * (max - min) + min\n}\n\n/**\n * Assumes that the object entries are all primitives + objects\n * shallow copy the object,\n * deep copy the\n * @param obj\n * @returns\n */\nexport function deepClone<T>(obj: T): T {\n  if (!obj) return obj\n  if (!Object.keys(obj).length) return {} as T\n  const ret = { ...obj }\n  Object.entries(obj).forEach(([k, v]: any) => {\n    if (typeof v !== 'object') return\n    ret[k] = JSON.parse(JSON.stringify(v))\n  })\n  return ret\n}\n\nexport const clamp = (val, low, high) => {\n  if (val < low) return low\n  if (val > high) return high\n  return val\n}\nexport const getArrLastElement = (arr) =>\n  arr.length ? arr[arr.length - 1] : null\n\nexport const clamp01 = (val) => clamp(val, 0, 1)\nexport const clampPercent = (val) => clamp(val, 0, 100)\n\n//use to pretty print timestamps, or anything really.\nexport function strPadLeft(string, pad, length) {\n  return (new Array(length + 1).join(pad) + string).slice(-length)\n}\n\n//fuzzy compare strings. longer the distance, the higher the mismatch.\nexport function hammingDistance(str1, str2) {\n  let dist = 0\n  str1 = str1.toLowerCase()\n  str2 = str2.toLowerCase()\n  for (let i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\n    let match = true\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i]) match = false\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i]) match = true\n    if (!match) dist++\n  }\n  return dist\n}\n\n//multiplies every numerical value in the obj by a multiplier.\nexport function objMultiplication(obj, multi) {\n  if (multi === 1) return obj\n  Object.keys(obj).forEach((prop: any) => {\n    if (typeof obj[prop] === 'object') objMultiplication(obj[prop], multi)\n    if (typeof obj[prop] === 'number') obj[prop] = obj[prop] * multi\n  })\n  return obj\n}\n\n//assign obj.[keys...] = value\nexport function layeredAssignment(obj, keys: readonly string[], value) {\n  keys.reduce((accu, key, i, arr) => {\n    if (i === arr.length - 1) return (accu[key] = value)\n    if (!accu[key]) accu[key] = {}\n    return accu[key]\n  }, obj)\n  return obj\n}\n//get the value in a nested object, giving array of path\nexport function objPathValue(\n  obj: object | undefined,\n  keys: readonly string[]\n): any {\n  if (!obj || !keys) return undefined\n  !Array.isArray(keys) && console.error(keys)\n  return keys.reduce((a, k) => a?.[k], obj)\n}\n//delete the value denoted by the path. Will also delete empty objects as well.\nexport function deletePropPath(obj, path) {\n  const tempPath = [...path]\n  const lastKey = tempPath.pop()\n  const objPathed = objPathValue(obj, tempPath)\n  delete objPathed?.[lastKey]\n}\n\nexport function objClearEmpties(o) {\n  for (const k in o) {\n    if (typeof o[k] !== 'object') continue\n    objClearEmpties(o[k])\n    if (!Object.keys(o[k]).length) delete o[k]\n  }\n}\nexport function crawlObject(\n  obj: any,\n  keys: string[] = [],\n  validate: (o: any, keys: string[]) => boolean,\n  cb: (o: any, keys: string[]) => void\n) {\n  if (validate(obj, keys)) cb(obj, keys)\n  else\n    obj &&\n      typeof obj === 'object' &&\n      Object.entries(obj).forEach(([key, val]) =>\n        crawlObject(val, [...keys, key], validate, cb)\n      )\n}\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\nexport const getObjectKeysRecursive = (obj) =>\n  typeof obj === 'object'\n    ? Object.values(obj)\n        .flatMap(getObjectKeysRecursive)\n        .concat(Object.keys(obj))\n    : typeof obj === 'string'\n    ? [obj]\n    : []\n\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\n  return typeof value === 'function' ? (value as any)(arg) : value\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyMap<K extends string | number, V>(\n  keys: readonly K[],\n  map: (key: K, i: number) => V\n): StrictDict<`${K}`, V> {\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyValueMap<T, K extends string | number, V>(\n  items: readonly T[],\n  map: (item: T, i: number) => [K, V]\n): StrictDict<`${K}`, V> {\n  return Object.fromEntries(items.map((t, i) => map(t, i))) as any\n}\n\nexport function objectMap<K extends string, V, T>(\n  obj: Record<K, Exclude<V, undefined>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Record<K, T>\nexport function objectMap<K extends string, V, T>(\n  obj: Partial<Record<K, V>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Partial<Record<K, T>>\nexport function objectMap<K extends string, V, T>(\n  obj: Partial<Record<K, V>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Partial<Record<K, T>> {\n  return Object.fromEntries(\n    Object.entries(obj).map(([k, v], i) => [k, fn(v, k, i)])\n  ) as any\n}\n\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\n  for (let i = from; i <= to; i++) yield i\n}\n\n/** range of [from, to], inclusive */\nexport function range(from: number, to: number): number[] {\n  return [...rangeGen(from, to)]\n}\n\nexport function assertUnreachable(value: never): never {\n  throw new Error(`Should not reach this with value ${value}`)\n}\n\n// cartesian product of list of arrays\nexport function cartesian<T>(...q: T[][]): T[][] {\n  return q.reduce((a, b) => a.flatMap((d) => b.map((e) => [d, [e]].flat())), [\n    [],\n  ] as T[][])\n}\n\n/** Will change `arr` in-place */\nexport function toggleInArr<T>(arr: T[], value: T) {\n  const ind = arr.indexOf(value)\n  if (ind < 0) arr.push(value)\n  else arr.splice(ind, 1)\n  return arr\n}\n\nexport function toggleArr<T>(arr: T[], value: T) {\n  return arr.includes(value) ? arr.filter((a) => a !== value) : [...arr, value]\n}\n\nexport function deepFreeze<T>(obj: T, layers = 5): T {\n  if (layers === 0) return obj\n  if (typeof obj === 'object')\n    Object.values(Object.freeze(obj)).forEach((o) => deepFreeze(o, layers--))\n  return obj\n}\n\nexport function arrayMove<T>(arr: T[], oldIndex: number, newIndex: number) {\n  if (newIndex < 0 || newIndex >= arr.length) return arr\n  if (oldIndex < 0 || oldIndex >= arr.length) return arr\n  arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0])\n  return arr\n}\n","import { objectKeyMap } from '../Util/Util'\nimport type { OptNode } from './optimization'\nimport type {\n  ComputeNode,\n  ConstantNode,\n  Data,\n  DataNode,\n  Info,\n  LookupNode,\n  MatchNode,\n  NumNode,\n  ReadNode,\n  StrNode,\n  StrPrioNode,\n  SubscriptNode,\n  ThresholdNode,\n} from './type'\n\ntype Opt = number | OptNode\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype N_S = Num | Str\ntype AnyNode = NumNode | StrNode\n\nexport const todo: OptNode = constant(NaN, { name: 'TODO' })\nexport const one = percent(1),\n  naught = percent(0)\nexport const none = constant('none')\n\nexport function constant(value: number, info?: Info): ConstantNode<number>\nexport function constant(\n  value: string | undefined,\n  info?: Info\n): ConstantNode<string | undefined>\nexport function constant(\n  value: number | string | undefined,\n  info?: Info\n): ConstantNode<number> | ConstantNode<string | undefined>\nexport function constant(\n  value: number | string | undefined,\n  info?: Info\n): ConstantNode<number | string | undefined> {\n  return typeof value === 'number'\n    ? { operation: 'const', operands: [], type: 'number', value, info }\n    : { operation: 'const', operands: [], type: 'string', value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): ConstantNode<number> {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { unit: '%', ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: OptNode, info: Info): OptNode\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: AnyNode, info: Info): AnyNode\nexport function infoMut(node: AnyNode, info: Info): AnyNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, NumNode>,\n  defaultV: Num | 'none',\n  info?: Info\n): LookupNode<NumNode>\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, StrNode>,\n  defaultV: Str | 'none',\n  info?: Info\n): LookupNode<StrNode>\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, AnyNode>,\n  defaultV: N_S | 'none',\n  info?: Info\n): LookupNode<AnyNode> {\n  return {\n    operation: 'lookup',\n    operands:\n      defaultV !== 'none' ? [intoV(index), intoV(defaultV)] : [intoV(index)],\n    table,\n    info,\n  }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function min(...values: Num[]): ComputeNode\nexport function min(...values: Num[]): ComputeNode {\n  return { operation: 'min', operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function max(...values: Num[]): ComputeNode\nexport function max(...values: Num[]): ComputeNode {\n  return { operation: 'max', operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function sum(...values: Num[]): ComputeNode\nexport function sum(...values: Num[]): ComputeNode {\n  return { operation: 'add', operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function prod(...values: Num[]): ComputeNode\nexport function prod(...values: Num[]): ComputeNode {\n  return { operation: 'mul', operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Opt, c: Opt): ComputeNode<OptNode, OptNode>\nexport function frac(x: Num, c: Num): ComputeNode\nexport function frac(x: Num, c: Num): ComputeNode {\n  return { operation: 'sum_frac', operands: intoOps([x, c]) }\n}\nexport function res(base: Opt): ComputeNode<OptNode, OptNode>\nexport function res(base: Num): ComputeNode\nexport function res(base: Num): ComputeNode {\n  return { operation: 'res', operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? eq : neq */\nexport function compareEq(\n  v1: Num,\n  v2: Num,\n  eq: Num,\n  neq: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function compareEq(\n  v1: Num,\n  v2: Num,\n  eq: Str,\n  neq: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function compareEq(\n  v1: Str,\n  v2: Str,\n  eq: Num,\n  neq: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function compareEq(\n  v1: Str,\n  v2: Str,\n  eq: Str,\n  neq: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function compareEq(\n  v1: N_S,\n  v2: N_S,\n  eq: N_S,\n  neq: N_S,\n  info?: Info\n): MatchNode<AnyNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(eq), intoV(neq)],\n    info,\n  }\n}\n/** v1 == v2 ? pass : 0 */\nexport function equal(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function equal(\n  v1: Str,\n  v2: Str,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function equal(\n  v1: N_S,\n  v2: N_S,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(0)],\n    emptyOn: 'unmatch',\n  }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function equalStr(\n  v1: Str,\n  v2: Str,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function equalStr(\n  v1: N_S,\n  v2: N_S,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(undefined)],\n    emptyOn: 'unmatch',\n  }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function unequal(\n  v1: Str,\n  v2: Str,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function unequal(\n  v1: N_S,\n  v2: N_S,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(0), intoVInfo(pass, info)],\n    emptyOn: 'match',\n  }\n}\n/** v1 != v2 ? pass : `undefined` */\nexport function unequalStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function unequalStr(\n  v1: Str,\n  v2: Str,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function unequalStr(\n  v1: N_S,\n  v2: N_S,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(undefined), intoVInfo(pass, info)],\n    emptyOn: 'match',\n  }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(\n  v1: Opt,\n  v2: Opt,\n  pass: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function greaterEq(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function greaterEq(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(0)],\n    emptyOn: 'l',\n  }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): ThresholdNode<StrNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(undefined)],\n    emptyOn: 'l',\n  }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(\n  v1: Opt,\n  v2: Opt,\n  pass: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function lessThan(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function lessThan(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoV(0), intoVInfo(pass, info)],\n    emptyOn: 'ge',\n  }\n}\n/** v1 >= v2 ? ge : le */\nexport function threshold(\n  v1: Opt,\n  v2: Opt,\n  ge: Opt,\n  le: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function threshold(\n  v1: Num,\n  v2: Num,\n  ge: Num,\n  le: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function threshold(\n  v1: Num,\n  v2: Num,\n  ge: Num,\n  le: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoV(ge), intoV(le)],\n    info,\n  }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(\n  nodeList: T,\n  prefix: string[] = []\n): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== 'read')\n      throw new Error(\n        `Found ${(nodeList as any).operation} node while making reader`\n      )\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), (key) =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])\n    ) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(\n  base: AnyNode,\n  data: Data\n): DataNode<NumNode> | DataNode<StrNode>\nexport function data(\n  base: AnyNode,\n  data: Data\n): DataNode<NumNode> | DataNode<StrNode> {\n  return { operation: 'data', operands: [base as any], data }\n}\nexport function resetData(\n  base: NumNode,\n  data: Data,\n  info?: Info\n): DataNode<NumNode>\nexport function resetData(\n  base: StrNode,\n  data: Data,\n  info?: Info\n): DataNode<StrNode>\nexport function resetData(\n  base: AnyNode,\n  data: Data,\n  info?: Info\n): DataNode<AnyNode>\nexport function resetData(\n  base: AnyNode,\n  data: Data,\n  info?: Info\n): DataNode<AnyNode> {\n  return { operation: 'data', operands: [base], data, reset: true, info }\n}\n\nexport function customRead(\n  path: readonly string[],\n  info?: Info\n): ReadNode<number> {\n  return { operation: 'read', operands: [], path, info, type: 'number' }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: 'read', operands: [], path, type: 'string' }\n}\nexport function read(\n  accu?: ReadNode<number>['accu'],\n  info?: Info\n): ReadNode<number> {\n  return {\n    operation: 'read',\n    operands: [],\n    path: [],\n    accu,\n    info,\n    type: 'number',\n  }\n}\n/**\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\n */\nexport function stringRead(\n  accu?: ReadNode<string | undefined>['accu']\n): ReadNode<string | undefined> {\n  return { operation: 'read', operands: [], path: [], accu, type: 'string' }\n}\nexport function stringPrio(...operands: Str[]): StrPrioNode {\n  return { operation: 'prio', operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(\n  index: NumNode,\n  list: V[],\n  info?: Info\n): SubscriptNode<V> {\n  return { operation: 'subscript', operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: N_S[]): AnyNode[] {\n  return values.map((value) =>\n    typeof value === 'object' ? value : constant(value)\n  )\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: N_S): AnyNode\nfunction intoV(value: N_S): AnyNode {\n  return typeof value !== 'object' ? constant(value) : value\n}\nfunction intoVInfo(value: Num, info: Info | undefined): NumNode\nfunction intoVInfo(value: Str, info: Info | undefined): StrNode\nfunction intoVInfo(value: N_S, info: Info | undefined): AnyNode\nfunction intoVInfo(value: N_S, info: Info | undefined): AnyNode {\n  if (!info) return intoV(value)\n  return typeof value !== 'object'\n    ? constant(value, info)\n    : infoMut({ ...value }, info)\n}\n\ntype _NodeList = { [key: string]: NodeList } & { operation?: never }\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n","import type { AnyNode, Base, NodeData, NumNode, StrNode } from './type'\nimport { constant } from './utils'\n\nexport function deepNodeClone<\n  T extends NodeData<NumNode | StrNode | undefined>\n>(data: T): T {\n  const map = new Map()\n  function internal(orig: any) {\n    if (typeof orig !== 'object') return orig\n    const old = map.get(orig)\n    if (old) return old\n\n    const cache: any = Array.isArray(orig)\n      ? orig.map((val) => internal(val))\n      : Object.fromEntries(\n          Object.entries(orig).map(([key, val]) => [\n            key,\n            key === 'info' ? val : internal(val),\n          ])\n        )\n    map.set(orig, cache)\n    return cache\n  }\n  return internal(data)\n}\n\nexport function forEachNodes<T extends Base<T> = AnyNode>(\n  formulas: T[],\n  topDown: (formula: T) => void,\n  bottomUp: (formula: T) => void\n): void {\n  const visiting = new Set<T>(),\n    visited = new Set<T>()\n\n  function traverse(formula: T) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error('Found cyclical dependency during formula traversal')\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas<\n  Input extends Base<Input> = AnyNode,\n  Interim extends Base<Interim> = Input,\n  Output extends Base<Output> = Interim\n>(\n  formulas: Input[],\n  topDownMap: (formula: Input | Interim) => Interim,\n  bottomUpMap: (current: Interim | Output, orig: Input | Interim) => Output\n): Output[] {\n  const visiting = new Set<Input | Interim>()\n  const topDownMapped = new Map<Input | Interim, Output>()\n  const bottomUpMapped = new Map<Interim, Output>()\n\n  function check(formula: Input | Interim): Output {\n    let topDown: Interim | Output | undefined = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error('Found cyclical dependency during formula mapping')\n      return constant(NaN) as any\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: Interim): Interim | Output {\n    const operands = formula.operands.map(check)\n    return arrayEqual<Interim | Output>(operands, formula.operands)\n      ? formula\n      : { ...formula, operands }\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual<Input | Output>(result, formulas)\n    ? (formulas as any)\n    : result\n}\n\nexport function customMapFormula<Context, Output, Input extends Base<Input>>(\n  formulas: Input[],\n  context: Context,\n  map: (\n    formula: Input,\n    context: Context,\n    map: (node: Input, context: Context) => Output\n  ) => Output\n): Output[] {\n  const contextMapping = new Map<Context, [Set<Input>, Map<Input, Output>]>()\n  function internalMap(formula: Input, context: Context): Output {\n    let current = contextMapping.get(context)\n    if (!current)\n      contextMapping.set(context, (current = [new Set(), new Map()]))\n    const [visiting, mapping] = current\n\n    const old = mapping.get(formula)\n    if (old) return old\n\n    if (visiting.has(formula))\n      throw new Error('Found cyclical dependency during formula mapping')\n\n    visiting.add(formula)\n    const newFormula = map(formula, context, internalMap)\n    mapping.set(formula, newFormula)\n    visiting.delete(formula)\n\n    return newFormula\n  }\n  return formulas.map((formula) => internalMap(formula, context))\n}\n\nfunction arrayEqual<T>(\n  a: readonly T[] | undefined,\n  b: readonly T[] | undefined\n): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import type { ArtifactBuildData } from '../Solver/common'\nimport { assertUnreachable, objPathValue } from '../Util/Util'\nimport { customMapFormula, forEachNodes, mapFormulas } from './internal'\nimport type {\n  AnyNode,\n  CommutativeMonoidOperation,\n  ComputeNode,\n  ConstantNode,\n  Data,\n  NumNode,\n  Operation,\n  ReadNode,\n  StrNode,\n  StrPrioNode,\n  ThresholdNode,\n} from './type'\nimport { constant } from './utils'\n\nexport type OptNode =\n  | ComputeNode<OptNode, OptNode>\n  | ThresholdNode<OptNode, OptNode, OptNode>\n  | ReadNode<number>\n  | ConstantNode<number>\n\nconst allCommutativeMonoidOperations: StrictDict<\n  CommutativeMonoidOperation,\n  (_: number[]) => number\n> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<\n  Operation | 'threshold',\n  (_: number[]) => number\n> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number =>\n    value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(\n  Object.keys(allCommutativeMonoidOperations) as NumNode['operation'][]\n)\n\nexport function optimize(\n  formulas: NumNode[],\n  topLevelData: Data,\n  shouldFold = (_formula: ReadNode<number | string | undefined>) => false\n): OptNode[] {\n  let opts = constantFold(formulas, topLevelData, shouldFold)\n  opts = flatten(opts)\n  return deduplicate(opts)\n}\nexport function precompute(\n  formulas: OptNode[],\n  initial: ArtifactBuildData['values'],\n  binding: (\n    readNode: ReadNode<number> | ReadNode<string | undefined>\n  ) => string,\n  slotCount: number\n): (_: ArtifactBuildData[]) => number[] {\n  let body = `\n\"use strict\";\n// copied from the code above\nfunction res(res) {\n  if (res < 0) return 1 - res / 2\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\n  return 1 - res\n}\nconst x0=0` // making sure `const` has at least one entry\n\n  let i = 1\n  const names = new Map<NumNode | StrNode, string>()\n  forEachNodes(\n    formulas,\n    (_) => {},\n    (f) => {\n      const { operation, operands } = f,\n        name = `x${i++}`,\n        operandNames = operands.map((x: OptNode) => names.get(x)!)\n      names.set(f, name)\n      switch (operation) {\n        case 'read': {\n          const key = binding(f)\n          let arr = new Array(slotCount)\n            .fill(null)\n            .map((x, i) => `(b[${i}].values[\"${key}\"] ?? 0)`)\n          if (initial[key] && initial[key] !== 0) {\n            arr = [initial[key].toString(), ...arr]\n          }\n          body += `,${name}=${arr.join('+')}`\n          break\n        }\n        case 'const':\n          names.set(f, `(${f.value})`)\n          break\n        case 'add':\n        case 'mul':\n          body += `,${name}=${operandNames.join(\n            operation === 'add' ? '+' : '*'\n          )}`\n          break\n        case 'min':\n        case 'max':\n          body += `,${name}=Math.${operation}(${operandNames})`\n          break\n        case 'threshold': {\n          const [value, threshold, pass, fail] = operandNames\n          body += `,${name}=(${value}>=${threshold})?${pass}:${fail}`\n          break\n        }\n        case 'res':\n          body += `,${name}=res(${operandNames[0]})`\n          break\n        case 'sum_frac':\n          body += `,${name}=${operandNames[0]}/(${operandNames[0]}+${operandNames[1]})`\n          break\n\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n  body += `;\\nreturn [${formulas.map((f) => names.get(f)!)}]`\n  return new (Function as any)(`b`, body)\n}\n\nfunction flatten(formulas: OptNode[]): OptNode[] {\n  return mapFormulas(\n    formulas,\n    (f) => f,\n    (_formula) => {\n      let result = _formula\n      if (commutativeMonoidOperationSet.has(_formula.operation as Operation)) {\n        const formula = _formula as ComputeNode<OptNode>\n        const { operation } = formula\n\n        let flattened = false\n        const operands = formula.operands.flatMap((dep) =>\n          dep.operation === operation\n            ? ((flattened = true), dep.operands)\n            : [dep]\n        )\n        result = flattened ? { ...formula, operands } : formula\n      }\n\n      return result\n    }\n  )\n}\nfunction deduplicate(formulas: OptNode[]): OptNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<OptNode, number>(),\n      formulas: new Set<OptNode>(),\n      operation: 'add' as Operation,\n    },\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode<OptNode> = {\n      operation: wrap.common.operation,\n      operands: arrayFromCounts(wrap.common.counts),\n    }\n\n    const candidatesByOperation = new Map<\n      Operation,\n      [ComputeNode<OptNode>, Map<OptNode, number>][]\n    >()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(\n      formulas,\n      (_formula) => {\n        if (wrap.common.formulas.has(_formula)) {\n          const formula = _formula as ComputeNode<OptNode>\n          const remainingCounts = new Map(wrap.common.counts)\n          const operands = formula.operands.filter((dep) => {\n            const count = remainingCounts.get(dep)\n            if (count) {\n              remainingCounts.set(dep, count - 1)\n              return false\n            }\n            return true\n          })\n\n          if (!operands.length) return factored\n          operands.push(factored)\n          return { ...formula, operands }\n        }\n        return _formula\n      },\n      (_formula) => {\n        if (!commutativeMonoidOperationSet.has(_formula.operation as any))\n          return _formula\n        const formula = _formula as ComputeNode<OptNode>\n\n        if (next) {\n          if (next.operation === formula.operation) {\n            const currentCounts = elementCounts(formula.operands),\n              commonCounts = new Map<OptNode, number>()\n            const nextCounts = next.counts\n            let total = 0\n\n            for (const [dependency, currentCount] of currentCounts.entries()) {\n              const commonCount = Math.min(\n                currentCount,\n                nextCounts.get(dependency) ?? 0\n              )\n              if (commonCount) {\n                commonCounts.set(dependency, commonCount)\n                total += commonCount\n              } else commonCounts.delete(dependency)\n            }\n            if (total > 1) {\n              next.counts = commonCounts\n              next.formulas.add(formula)\n            }\n          }\n        } else {\n          const candidates = candidatesByOperation.get(formula.operation)!\n          const counts = elementCounts(formula.operands)\n\n          for (const [candidate, candidateCounts] of candidates) {\n            let total = 0\n\n            const commonCounts = new Map<OptNode, number>()\n            for (const [\n              dependency,\n              candidateCount,\n            ] of candidateCounts.entries()) {\n              const count = Math.min(\n                candidateCount,\n                counts.get(dependency) ?? 0\n              )\n              if (count) {\n                commonCounts.set(dependency, count)\n                total += count\n              }\n            }\n            if (total > 1) {\n              next = {\n                counts: commonCounts,\n                formulas: new Set([formula, candidate]),\n                operation: formula.operation,\n              }\n              candidatesByOperation.clear()\n              break\n            }\n          }\n          if (!next) candidates.push([formula, counts])\n        }\n\n        return formula\n      }\n    )\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(\n  formulas: NumNode[],\n  topLevelData: Data,\n  shouldFold = (_formula: ReadNode<number | string | undefined>) => false\n): OptNode[] {\n  type Context = {\n    data: Data[]\n    processed: Map<NumNode | StrNode, OptNode | StrNode>\n  }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return customMapFormula<typeof context, OptNode | StrNode, AnyNode>(\n    formulas,\n    context,\n    (formula, context, map) => {\n      const { operation } = formula,\n        fold = (x: NumNode, c: typeof context) => map(x, c) as OptNode\n      const foldStr = (x: StrNode, c: typeof context) => map(x, c) as StrNode\n      let result: OptNode | StrNode\n      switch (operation) {\n        case 'const':\n          result = formula\n          break\n        case 'add':\n        case 'mul':\n        case 'max':\n        case 'min': {\n          const f = allOperations[operation]\n          const numericOperands: number[] = []\n          const formulaOperands: OptNode[] = formula.operands\n            .filter((formula) => {\n              const folded = fold(formula, context)\n              return folded.operation === 'const'\n                ? (numericOperands.push(folded.value), false)\n                : true\n            })\n            .map((x) => fold(x, context))\n          const numericValue = f(numericOperands)\n\n          // Fold degenerate cases. This may incorrectly compute NaN\n          // results, which shouldn't appear under expected usage.\n          // - zero\n          //   - 0 * ... = 0\n          // - infinity\n          //   - max(infinity, ...) = infinity\n          //   - infinity + ... = infinity\n          // - (-infinity)\n          //   - min(-infinity, ...) - infinity\n          //   - (-infinity) + ... = -infinity\n          // - NaN\n          //   - operation(NaN, ...) = NaN\n          if (!isFinite(numericValue)) {\n            if (\n              operation !== 'mul' &&\n              (operation !== 'max' || numericValue > 0) &&\n              (operation !== 'min' || numericValue < 0)\n            ) {\n              result = constant(numericValue)\n              break\n            }\n          } else if (operation === 'mul' && numericValue === 0) {\n            result = constant(numericValue)\n            break\n          }\n\n          if (numericValue !== f([]))\n            // Skip vacuous values\n            formulaOperands.push(constant(numericValue))\n          if (formulaOperands.length <= 1)\n            result = formulaOperands[0] ?? constant(f([]))\n          else result = { operation, operands: formulaOperands }\n          break\n        }\n        case 'res':\n        case 'sum_frac': {\n          const operands = formula.operands.map((x) => fold(x, context))\n          const f = allOperations[operation]\n          if (operands.every((x) => x.operation === 'const'))\n            result = constant(\n              f(operands.map((x) => (x as ConstantNode<number>).value))\n            )\n          else result = { ...formula, operands }\n          break\n        }\n        case 'lookup': {\n          const index = foldStr(formula.operands[0], context)\n          if (index.operation === 'const') {\n            const selected = formula.table[index.value!] ?? formula.operands[1]\n            if (selected) {\n              result = map(selected, context)\n              break\n            }\n          }\n          throw new Error(`Unsupported ${operation} node while folding`)\n        }\n        case 'prio': {\n          const first = formula.operands.find((op) => {\n            const folded = foldStr(op, context)\n            if (folded.operation !== 'const')\n              throw new Error(`Unsupported ${operation} node while folding`)\n            return folded.value !== undefined\n          })\n          result = first ? foldStr(first, context) : constant(undefined)\n          break\n        }\n        case 'small': {\n          let smallest = undefined as\n            | ConstantNode<string | undefined>\n            | undefined\n          for (const operand of formula.operands) {\n            const folded = foldStr(operand, context)\n            if (folded.operation !== 'const')\n              throw new Error(`Unsupported ${operation} node while folding`)\n            if (\n              smallest?.value === undefined ||\n              (folded.value !== undefined && folded.value < smallest.value)\n            )\n              smallest = folded\n          }\n          result = smallest ?? constant(undefined)\n          break\n        }\n        case 'match': {\n          const [v1, v2, match, unmatch] = formula.operands.map(\n            (x: NumNode | StrNode) => map(x, context)\n          )\n          if (v1.operation !== 'const' || v2.operation !== 'const')\n            throw new Error(`Unsupported ${operation} node while folding`)\n          result = v1.value === v2.value ? match : unmatch\n          break\n        }\n        case 'threshold': {\n          const [value, threshold, pass, fail] = formula.operands.map(\n            (x) => map(x, context) as OptNode\n          )\n          if (\n            pass.operation === 'const' &&\n            fail.operation === 'const' &&\n            pass.value === fail.value\n          )\n            result = pass\n          else if (\n            value.operation === 'const' &&\n            threshold.operation === 'const'\n          )\n            result = value.value >= threshold.value ? pass : fail\n          else result = { ...formula, operands: [value, threshold, pass, fail] }\n          break\n        }\n        case 'subscript': {\n          const index = fold(formula.operands[0], context)\n          if (index.operation !== 'const')\n            throw new Error('Found non-constant subscript node while folding')\n          result = constant(formula.list[index.value])\n          break\n        }\n        case 'read': {\n          const operands = context.data\n            .map((x) => objPathValue(x, formula.path) as NumNode | StrNode)\n            .filter((x) => x)\n\n          if (operands.length === 0) {\n            if (shouldFold(formula)) {\n              const { accu } = formula\n              if (accu === undefined || accu === 'small')\n                result =\n                  formula.type === 'string'\n                    ? constant(undefined)\n                    : constant(NaN)\n              else result = constant(allOperations[accu]([]))\n            } else result = formula\n          } else if (formula.accu === undefined || operands.length === 1)\n            result = map(operands[operands.length - 1], context)\n          else\n            result = map(\n              { operation: formula.accu, operands } as\n                | ComputeNode\n                | StrPrioNode,\n              context\n            )\n          break\n        }\n        case 'data': {\n          if (formula.reset) context = origin\n          const nextMap = nextContextMap.get(context)!\n          let nextContext = nextMap.get(formula.data)\n          if (!nextContext) {\n            nextContext = {\n              data: [...context.data, formula.data],\n              processed: new Map(),\n            }\n            nextContextMap.set(nextContext, new Map())\n            nextMap.set(formula.data, nextContext)\n          }\n          result = map(formula.operands[0], nextContext)\n          break\n        }\n        default:\n          assertUnreachable(operation)\n      }\n\n      if (result.info) {\n        result = { ...result }\n        delete result.info\n      }\n      return result\n    }\n  ) as OptNode[]\n}\n\nexport const testing = {\n  constantFold,\n  flatten,\n  deduplicate,\n}\n","export const allGenderKeys = ['F', 'M'] as const\nexport type GenderKey = (typeof allGenderKeys)[number]\n\nexport const allElementKeys = [\n  'anemo',\n  'geo',\n  'electro',\n  'hydro',\n  'pyro',\n  'cryo',\n  'dendro',\n] as const\nexport type ElementKey = (typeof allElementKeys)[number]\n\nexport const allElementWithPhyKeys = ['physical', ...allElementKeys] as const\nexport type ElementWithPhyKey = (typeof allElementWithPhyKeys)[number]\n\nexport const allRegionKeys = [\n  'mondstadt',\n  'liyue',\n  'inazuma',\n  'sumeru',\n  'fontaine',\n  'natlan',\n  'snezhnaya',\n  'khaenriah',\n] as const\nexport type RegionKey = (typeof allRegionKeys)[number]\n\nexport const allAscensionKeys = [0, 1, 2, 3, 4, 5, 6] as const\nexport type AscensionKey = (typeof allAscensionKeys)[number]\n\nexport const allMoveKeys = [\n  'normal',\n  'charged',\n  'plunging',\n  'skill',\n  'burst',\n  'elemental',\n] as const\nexport type MoveKey = (typeof allMoveKeys)[number]\n\nexport const nonTravelerCharacterKeys = [\n  'Albedo',\n  'Alhaitham',\n  'Aloy',\n  'Amber',\n  'AratakiItto',\n  'Barbara',\n  'Beidou',\n  'Bennett',\n  'Candace',\n  'Chongyun',\n  'Collei',\n  'Cyno',\n  'Dehya',\n  'Diluc',\n  'Diona',\n  'Dori',\n  'Eula',\n  'Faruzan',\n  'Fischl',\n  'Ganyu',\n  'Gorou',\n  'HuTao',\n  'Jean',\n  'KaedeharaKazuha',\n  'Kaeya',\n  'KamisatoAyaka',\n  'KamisatoAyato',\n  'Keqing',\n  'Klee',\n  'KujouSara',\n  'KukiShinobu',\n  'Layla',\n  'Lisa',\n  'Mika',\n  'Mona',\n  'Nahida',\n  'Nilou',\n  'Ningguang',\n  'Noelle',\n  'Qiqi',\n  'RaidenShogun',\n  'Razor',\n  'Rosaria',\n  'SangonomiyaKokomi',\n  'Sayu',\n  'Shenhe',\n  'ShikanoinHeizou',\n  'Somnia',\n  'Sucrose',\n  'Tartaglia',\n  'Thoma',\n  'Tighnari',\n  'Venti',\n  'Wanderer',\n  'Xiangling',\n  'Xiao',\n  'Xingqiu',\n  'Xinyan',\n  'YaeMiko',\n  'Yanfei',\n  'Yaoyao',\n  'Yelan',\n  'Yoimiya',\n  'YunJin',\n  'Zhongli',\n] as const\n\nexport const allTravelerKeys = [\n  'TravelerAnemo',\n  'TravelerGeo',\n  'TravelerElectro',\n  'TravelerDendro',\n] as const\nexport type TravelerKey = (typeof allTravelerKeys)[number]\n\nexport const locationGenderedCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  'TravelerF',\n  'TravelerM',\n] as const\nexport type LocationGenderedCharacterKey =\n  (typeof locationGenderedCharacterKeys)[number]\n\nexport const allCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  ...allTravelerKeys,\n] as const\nexport type CharacterKey = (typeof allCharacterKeys)[number]\n\nexport const allLocationCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  'Traveler',\n] as const\nexport type LocationCharacterKey = (typeof allLocationCharacterKeys)[number]\n\nexport type LocationKey = LocationCharacterKey | ''\n\nexport function charKeyToLocGenderedCharKey(\n  charKey: CharacterKey,\n  gender: GenderKey\n): LocationGenderedCharacterKey {\n  if (allTravelerKeys.includes(charKey as TravelerKey))\n    return `Traveler${gender}`\n  return charKey as LocationGenderedCharacterKey\n}\n\nexport function charKeyToLocCharKey(\n  charKey: CharacterKey\n): LocationCharacterKey {\n  if (allTravelerKeys.includes(charKey as TravelerKey)) return 'Traveler'\n  return charKey as LocationCharacterKey\n}\n","import type { RarityKey } from './common'\n\nexport const allArtifactSetKeys = [\n  'Adventurer',\n  'ArchaicPetra',\n  'Berserker',\n  'BlizzardStrayer',\n  'BloodstainedChivalry',\n  'BraveHeart',\n  'CrimsonWitchOfFlames',\n  'DeepwoodMemories',\n  'DefendersWill',\n  'DesertPavilionChronicle',\n  'EchoesOfAnOffering',\n  'EmblemOfSeveredFate',\n  'FlowerOfParadiseLost',\n  'Gambler',\n  'GildedDreams',\n  'GladiatorsFinale',\n  'HeartOfDepth',\n  'HuskOfOpulentDreams',\n  'Instructor',\n  'Lavawalker',\n  'LuckyDog',\n  'MaidenBeloved',\n  'MartialArtist',\n  'NoblesseOblige',\n  'NymphsDream',\n  'OceanHuedClam',\n  'PaleFlame',\n  'PrayersForDestiny',\n  'PrayersForIllumination',\n  'PrayersForWisdom',\n  'PrayersToSpringtime',\n  'ResolutionOfSojourner',\n  'RetracingBolide',\n  'Scholar',\n  'ShimenawasReminiscence',\n  'TenacityOfTheMillelith',\n  'TheExile',\n  'ThunderingFury',\n  'Thundersoother',\n  'TinyMiracle',\n  'TravelingDoctor',\n  'VermillionHereafter',\n  'ViridescentVenerer',\n  'VourukashasGlow',\n  'WanderersTroupe',\n] as const\nexport type ArtifactSetKey = (typeof allArtifactSetKeys)[number]\n\nexport const allArtifactSlotKeys = [\n  'flower',\n  'plume',\n  'sands',\n  'goblet',\n  'circlet',\n] as const\nexport type ArtifactSlotKey = (typeof allArtifactSlotKeys)[number]\n\nexport const artMaxLevel: Record<RarityKey, number> = {\n  1: 4,\n  2: 4,\n  3: 12,\n  4: 16,\n  5: 20,\n} as const\n","import type { RarityKey } from './common'\n\nexport const allWeaponTypeKeys = [\n  'sword',\n  'claymore',\n  'polearm',\n  'bow',\n  'catalyst',\n] as const\nexport type WeaponTypeKey = (typeof allWeaponTypeKeys)[number]\n\nexport const allWeaponSwordKeys = [\n  'AmenomaKageuchi',\n  'AquilaFavonia',\n  'BlackcliffLongsword',\n  'CinnabarSpindle',\n  'CoolSteel',\n  'KagotsurubeIsshin',\n  'DarkIronSword',\n  'DullBlade',\n  'FavoniusSword',\n  'FesteringDesire',\n  'FilletBlade',\n  'FreedomSworn',\n  'HaranGeppakuFutsu',\n  'HarbingerOfDawn',\n  'IronSting',\n  'KeyOfKhajNisut',\n  'LightOfFoliarIncision',\n  'LionsRoar',\n  'MistsplitterReforged',\n  'PrimordialJadeCutter',\n  'PrototypeRancour',\n  'RoyalLongsword',\n  'SacrificialSword',\n  'SapwoodBlade',\n  'SilverSword',\n  'SkyriderSword',\n  'SkywardBlade',\n  'SummitShaper',\n  'SwordOfDescension',\n  'TheAlleyFlash',\n  'TheBlackSword',\n  'TheFlute',\n  'ToukabouShigure',\n  'TravelersHandySword',\n  'XiphosMoonlight',\n] as const\nexport type WeaponSwordKey = (typeof allWeaponSwordKeys)[number]\n\nexport const allWeaponClaymoreKeys = [\n  'Akuoumaru',\n  'BeaconOfTheReedSea',\n  'BlackcliffSlasher',\n  'BloodtaintedGreatsword',\n  'DebateClub',\n  'FavoniusGreatsword',\n  'FerrousShadow',\n  'ForestRegalia',\n  'KatsuragikiriNagamasa',\n  'LithicBlade',\n  'LuxuriousSeaLord',\n  'MailedFlower',\n  'MakhairaAquamarine',\n  'OldMercsPal',\n  'PrototypeArchaic',\n  'Rainslasher',\n  'RedhornStonethresher',\n  'RoyalGreatsword',\n  'SacrificialGreatsword',\n  'SerpentSpine',\n  'SkyriderGreatsword',\n  'SkywardPride',\n  'SnowTombedStarsilver',\n  'SongOfBrokenPines',\n  'TheBell',\n  'TheUnforged',\n  'WasterGreatsword',\n  'Whiteblind',\n  'WhiteIronGreatsword',\n  'WolfsGravestone',\n] as const\nexport type WeaponClaymoreKey = (typeof allWeaponClaymoreKeys)[number]\n\nexport const allWeaponPolearmKeys = [\n  'BeginnersProtector',\n  'BlackcliffPole',\n  'BlackTassel',\n  'CalamityQueller',\n  'CrescentPike',\n  'Deathmatch',\n  'DragonsBane',\n  'DragonspineSpear',\n  'EngulfingLightning',\n  'FavoniusLance',\n  'Halberd',\n  'IronPoint',\n  'KitainCrossSpear',\n  'LithicSpear',\n  'MissiveWindspear',\n  'Moonpiercer',\n  'PrimordialJadeWingedSpear',\n  'PrototypeStarglitter',\n  'RoyalSpear',\n  'SkywardSpine',\n  'StaffOfHoma',\n  'StaffOfTheScarletSands',\n  'TheCatch',\n  'VortexVanquisher',\n  'WavebreakersFin',\n  'WhiteTassel',\n] as const\nexport type WeaponPoleArmKey = (typeof allWeaponPolearmKeys)[number]\n\nexport const allWeaponBowKeys = [\n  'AlleyHunter',\n  'AmosBow',\n  'AquaSimulacra',\n  'BlackcliffWarbow',\n  'CompoundBow',\n  'ElegyForTheEnd',\n  'EndOfTheLine',\n  'FadingTwilight',\n  'FavoniusWarbow',\n  'Hamayumi',\n  'HuntersBow',\n  'HuntersPath',\n  'KingsSquire',\n  'Messenger',\n  'MitternachtsWaltz',\n  'MouunsMoon',\n  'PolarStar',\n  'Predator',\n  'PrototypeCrescent',\n  'RavenBow',\n  'RecurveBow',\n  'RoyalBow',\n  'Rust',\n  'SacrificialBow',\n  'SeasonedHuntersBow',\n  'SharpshootersOath',\n  'SkywardHarp',\n  'Slingshot',\n  'TheStringless',\n  'TheViridescentHunt',\n  'ThunderingPulse',\n  'WindblumeOde',\n] as const\nexport type WeaponBowKey = (typeof allWeaponBowKeys)[number]\n\nexport const allWeaponCatalystKeys = [\n  'ApprenticesNotes',\n  'AThousandFloatingDreams',\n  'BlackcliffAgate',\n  'DodocoTales',\n  'EmeraldOrb',\n  'EverlastingMoonglow',\n  'EyeOfPerception',\n  'FavoniusCodex',\n  'Frostbearer',\n  'FruitOfFulfillment',\n  'HakushinRing',\n  'KagurasVerity',\n  'LostPrayerToTheSacredWinds',\n  'MagicGuide',\n  'MappaMare',\n  'MemoryOfDust',\n  'OathswornEye',\n  'OtherworldlyStory',\n  'PocketGrimoire',\n  'PrototypeAmber',\n  'QuantumCatalyst',\n  'RoyalGrimoire',\n  'SacrificialFragments',\n  'SkywardAtlas',\n  'SolarPearl',\n  'TheWidsith',\n  'ThrillingTalesOfDragonSlayers',\n  'TulaytullahsRemembrance',\n  'TwinNephrite',\n  'WanderingEvenstar',\n  'WineAndSong',\n] as const\nexport type WeaponCatalystKey = (typeof allWeaponCatalystKeys)[number]\n\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\nexport type WeaponKey =\n  | WeaponSwordKey\n  | WeaponClaymoreKey\n  | WeaponPoleArmKey\n  | WeaponBowKey\n  | WeaponCatalystKey\n\nexport const weaponMaxLevel: Record<RarityKey, number> = {\n  1: 70,\n  2: 70,\n  3: 90,\n  4: 90,\n  5: 90,\n} as const\n","import type {\n  allArtifactSetKeys,\n  WeaponBowKey,\n  WeaponCatalystKey,\n  WeaponClaymoreKey,\n  WeaponPoleArmKey,\n  WeaponSwordKey,\n} from '@genshin-optimizer/consts'\nimport {\n  allWeaponBowKeys,\n  allWeaponCatalystKeys,\n  allWeaponClaymoreKeys,\n  allWeaponPolearmKeys,\n  allWeaponSwordKeys,\n  nonTravelerCharacterKeys,\n} from '@genshin-optimizer/consts'\n\nexport const allHitModes = ['hit', 'avgHit', 'critHit'] as const\nexport const allAmpReactions = ['vaporize', 'melt'] as const\nexport const allAdditiveReactions = ['spread', 'aggravate'] as const\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\n\nexport const allArtifactRarities = [5, 4, 3] as const\n/**\n * @deprecated\n */\nexport const allSlotKeys = [\n  'flower',\n  'plume',\n  'sands',\n  'goblet',\n  'circlet',\n] as const\n/**\n * @deprecated\n */\nexport const allElements = [\n  'anemo',\n  'geo',\n  'electro',\n  'hydro',\n  'pyro',\n  'cryo',\n  'dendro',\n] as const\n/**\n * @deprecated\n */\nexport const allElementsWithPhy = ['physical', ...allElements] as const\nexport const allInfusionAuraElements = [\n  'pyro',\n  'cryo',\n  'hydro',\n  'electro',\n] as const\n/**\n * @deprecated\n */\nexport const allWeaponTypeKeys = [\n  'sword',\n  'claymore',\n  'polearm',\n  'bow',\n  'catalyst',\n] as const\nexport const allRollColorKeys = [\n  'roll1',\n  'roll2',\n  'roll3',\n  'roll4',\n  'roll5',\n  'roll6',\n] as const\n/**\n * @deprecated\n */\nexport const allAscension = [0, 1, 2, 3, 4, 5, 6] as const\nexport const allRefinement = [1, 2, 3, 4, 5] as const\nexport const substatType = ['max', 'mid', 'min'] as const\nexport const genderKeys = ['F', 'M'] as const\nexport type Gender = (typeof genderKeys)[number]\n\n/**\n * @deprecated\n */\nexport const allLocationCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  'Traveler',\n] as const\nexport const travelerElements = ['anemo', 'geo', 'electro', 'dendro'] as const\nexport const travelerFKeys = [\n  'TravelerAnemoF',\n  'TravelerGeoF',\n  'TravelerElectroF',\n  'TravelerDendroF',\n] as const\nexport const travelerMKeys = [\n  'TravelerAnemoM',\n  'TravelerGeoM',\n  'TravelerElectroM',\n  'TravelerDendroM',\n] as const\n/**\n * @deprecated\n */\nexport const travelerKeys = [\n  'TravelerAnemo',\n  'TravelerGeo',\n  'TravelerElectro',\n  'TravelerDendro',\n] as const\n/**\n * @deprecated\n */\nexport const allCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  ...travelerKeys,\n] as const\n\nexport const allCharacterSheetKeys = [\n  ...nonTravelerCharacterKeys,\n  ...travelerFKeys,\n  ...travelerMKeys,\n]\n\n/**\n * @deprecated\n */\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\n/**\n * @deprecated\n */\nexport type WeaponKey =\n  | WeaponSwordKey\n  | WeaponClaymoreKey\n  | WeaponPoleArmKey\n  | WeaponBowKey\n  | WeaponCatalystKey\n\nexport const characterSpecializedStatKeys = [\n  'hp_',\n  'atk_',\n  'def_',\n  'eleMas',\n  'enerRech_',\n  'heal_',\n  'critRate_',\n  'critDMG_',\n  'physical_dmg_',\n  'anemo_dmg_',\n  'geo_dmg_',\n  'electro_dmg_',\n  'hydro_dmg_',\n  'pyro_dmg_',\n  'cryo_dmg_',\n  'dendro_dmg_',\n] as const\n\nexport type HitModeKey = (typeof allHitModes)[number]\nexport type AmpReactionKey = (typeof allAmpReactions)[number]\nexport type AdditiveReactionKey = (typeof allAdditiveReactions)[number]\nexport type SetNum = (typeof allArtifactSetCount)[number]\nexport type ArtifactRarity = (typeof allArtifactRarities)[number]\n/**\n * @deprecated\n */\nexport type SlotKey = (typeof allSlotKeys)[number]\n/**\n * @deprecated\n */\nexport type ElementKey = (typeof allElements)[number]\n/**\n * @deprecated\n */\nexport type ElementKeyWithPhy = (typeof allElementsWithPhy)[number]\nexport type InfusionAuraElements = (typeof allInfusionAuraElements)[number]\n/**\n * @deprecated\n */\nexport type ArtifactSetKey = (typeof allArtifactSetKeys)[number]\n/**\n * @deprecated\n */\nexport type CharacterKey = (typeof allCharacterKeys)[number]\nexport type CharacterSheetKey = (typeof allCharacterSheetKeys)[number]\n/**\n * @deprecated\n */\nexport type LocationCharacterKey = (typeof allLocationCharacterKeys)[number]\n/**\n * @deprecated\n */\nexport type TravelerKey = (typeof travelerKeys)[number]\nexport type TravelerElementKey = (typeof travelerElements)[number]\n/**\n * @deprecated\n */\nexport type WeaponTypeKey = (typeof allWeaponTypeKeys)[number]\nexport type RollColorKey = (typeof allRollColorKeys)[number]\n/**\n * @deprecated\n */\nexport type Ascension = (typeof allAscension)[number]\nexport type Refinement = (typeof allRefinement)[number]\nexport type CharacterSpecializedStatKey =\n  (typeof characterSpecializedStatKeys)[number]\nexport const absorbableEle = [\n  'hydro',\n  'pyro',\n  'cryo',\n  'electro',\n] as ElementKey[]\nexport const allowedAmpReactions: Dict<ElementKey, AmpReactionKey[]> = {\n  pyro: ['vaporize', 'melt'],\n  hydro: ['vaporize'],\n  cryo: ['melt'],\n  anemo: ['vaporize', 'melt'],\n}\nexport const allowedAdditiveReactions: Dict<ElementKey, AdditiveReactionKey[]> =\n  {\n    dendro: ['spread'],\n    electro: ['aggravate'],\n    anemo: ['aggravate'],\n  }\n\nexport type SubstatType = (typeof substatType)[number]\n\n/**\n * @deprecated\n */\nexport function charKeyToLocCharKey(\n  charKey: CharacterKey\n): LocationCharacterKey {\n  if (travelerKeys.includes(charKey as TravelerKey)) return 'Traveler'\n  return charKey as LocationCharacterKey\n}\n\nexport function TravelerToElement(\n  key: TravelerKey,\n  element: TravelerElementKey\n): TravelerKey {\n  return ('Traveler' +\n    element.toUpperCase().slice(0, 1) +\n    element.slice(1)) as TravelerKey\n}\n\n/**\n * @deprecated\n */\nexport type LocationKey = LocationCharacterKey | ''\n\nexport function charKeyToCharName(ck: CharacterKey, gender: Gender): string {\n  return ck.startsWith('Traveler') ? 'Traveler' + gender : ck\n}\n","import type { ArtSetExclusion } from '../Database/DataManagers/BuildSettingData'\nimport { forEachNodes, mapFormulas } from '../Formula/internal'\nimport type { OptNode } from '../Formula/optimization'\nimport { allOperations, constantFold } from '../Formula/optimization'\nimport type { ConstantNode } from '../Formula/type'\nimport { constant, customRead, max, min, threshold } from '../Formula/utils'\nimport type { ArtifactSetKey, SlotKey } from '../Types/consts'\nimport { allSlotKeys } from '../Types/consts'\nimport { assertUnreachable, objectKeyMap, objectMap, range } from '../Util/Util'\n\ntype MicropassOperation =\n  | 'reaffine'\n  | 'pruneArtRange'\n  | 'pruneNodeRange'\n  | 'pruneOrder'\nexport function pruneAll(\n  nodes: OptNode[],\n  minimum: number[],\n  arts: ArtifactsBySlot,\n  numTop: number,\n  exclusion: ArtSetExclusion,\n  forced: Dict<MicropassOperation, boolean>\n): { nodes: OptNode[]; arts: ArtifactsBySlot } {\n  let should = forced\n  /** If `key` makes progress, all operations in `value` should be performed */\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\n    pruneOrder: { pruneNodeRange: true },\n    pruneArtRange: { pruneNodeRange: true },\n    pruneNodeRange: { reaffine: true },\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true },\n  }\n  let count = 0\n  while (Object.values(should).some((x) => x) && count++ < 20) {\n    if (should.pruneOrder) {\n      delete should.pruneOrder\n      const newArts = pruneOrder(arts, numTop, exclusion)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneOrder }\n      }\n    }\n    if (should.pruneArtRange) {\n      delete should.pruneArtRange\n      const newArts = pruneArtRange(nodes, arts, minimum)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneArtRange }\n      }\n    }\n    if (should.pruneNodeRange) {\n      delete should.pruneNodeRange\n      const newNodes = pruneNodeRange(nodes, arts)\n      if (nodes !== newNodes) {\n        nodes = newNodes\n        should = { ...should, ...deps.pruneNodeRange }\n      }\n    }\n    if (should.reaffine) {\n      delete should.reaffine\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\n      if (nodes !== newNodes || arts !== newArts) {\n        nodes = newNodes\n        arts = newArts\n        should = { ...should, ...deps.reaffine }\n      }\n    }\n  }\n  return { nodes, arts }\n}\n\nexport function pruneExclusion(\n  nodes: OptNode[],\n  exclusion: ArtSetExclusion\n): OptNode[] {\n  const maxValues: Dict<keyof typeof exclusion, number> = {}\n  for (const [key, e] of Object.entries(exclusion)) {\n    if (!e.includes(4)) continue\n    maxValues[key] = e.includes(2) ? 1 : 3\n  }\n  return mapFormulas(\n    nodes,\n    (f) => f,\n    (f) => {\n      if (f.operation !== 'threshold') return f\n\n      const [v, t, pass, fail] = f.operands\n      if (v.operation === 'read' && t.operation === 'const') {\n        const key = v.path[v.path.length - 1],\n          thres = t.value\n        if (key in maxValues) {\n          const max: number = maxValues[key]\n          if (max < thres) return fail\n          if (thres === 2 && exclusion[key]!.includes(2))\n            return threshold(v, 4, pass, fail)\n        }\n      }\n      return f\n    }\n  )\n}\n\nfunction reaffine(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot,\n  forceRename = false\n): { nodes: OptNode[]; arts: ArtifactsBySlot } {\n  const affineNodes = new Set<OptNode>(),\n    topLevelAffine = new Set<OptNode>()\n\n  function visit(node: OptNode, isAffine: boolean) {\n    if (isAffine) affineNodes.add(node)\n    else\n      node.operands.forEach(\n        (op) => affineNodes.has(op) && topLevelAffine.add(op)\n      )\n  }\n\n  const dynKeys = new Set<string>()\n\n  forEachNodes(\n    nodes,\n    (_) => {},\n    (f) => {\n      const { operation } = f\n      switch (operation) {\n        case 'read':\n          dynKeys.add(f.path[1])\n          visit(f, true)\n          break\n        case 'add':\n          visit(\n            f,\n            f.operands.every((op) => affineNodes.has(op))\n          )\n          break\n        case 'mul': {\n          const nonConst = f.operands.filter((op) => op.operation !== 'const')\n          visit(\n            f,\n            nonConst.length === 0 ||\n              (nonConst.length === 1 && affineNodes.has(nonConst[0]))\n          )\n          break\n        }\n        case 'const':\n          visit(f, true)\n          break\n        case 'res':\n        case 'threshold':\n        case 'sum_frac':\n        case 'max':\n        case 'min':\n          visit(f, false)\n          break\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n\n  if (\n    [...topLevelAffine].every(\n      ({ operation }) => operation === 'read' || operation === 'const'\n    ) &&\n    Object.keys(arts.base).length === dynKeys.size\n  )\n    return { nodes, arts }\n\n  let current = -1\n  function nextDynKey(): string {\n    while (dynKeys.has(`${++current}`));\n    return `${current}`\n  }\n\n  nodes.forEach((node) => affineNodes.has(node) && topLevelAffine.add(node))\n  const affine = [...topLevelAffine].filter((f) => f.operation !== 'const')\n  const affineMap = new Map(\n    affine.map((node) => [\n      node,\n      !forceRename && node.operation === 'read' && node.path[0] === 'dyn'\n        ? node\n        : { ...customRead(['dyn', `${nextDynKey()}`]), accu: 'add' as const },\n    ])\n  )\n  nodes = mapFormulas(\n    nodes,\n    (f) => affineMap.get(f) ?? f,\n    (f) => f\n  )\n\n  function reaffineArt(stat: DynStat): DynStat {\n    const values = constantFold(\n      [...affineMap.keys()],\n      {\n        dyn: objectMap(stat, (value) => constant(value)),\n      } as any,\n      (_) => true\n    )\n    return Object.fromEntries(\n      [...affineMap.values()].map((v, i) => [\n        v.path[1],\n        (values[i] as ConstantNode<number>).value,\n      ])\n    )\n  }\n  const result = {\n    nodes,\n    arts: {\n      base: reaffineArt(arts.base),\n      values: objectKeyMap(allSlotKeys, (slot) =>\n        arts.values[slot].map(({ id, set, values }) => ({\n          id,\n          set,\n          values: reaffineArt(values),\n        }))\n      ),\n    },\n  }\n  const offsets = Object.entries(reaffineArt({}))\n  for (const arts of Object.values(result.arts.values))\n    for (const { values } of arts)\n      for (const [key, baseValue] of offsets) values[key] -= baseValue\n  return result\n}\n/** Remove artifacts that cannot be in top `numTop` builds */\nfunction pruneOrder(\n  arts: ArtifactsBySlot,\n  numTop: number,\n  exclusion: ArtSetExclusion\n): ArtifactsBySlot {\n  let progress = false\n  /**\n   * Note:\n   * This function assumes that every base (reaffined) stats are monotonically increasing. That is, artifacts\n   * with higher stats are better. This remains true as long as the main and substats are in increasing. Set\n   * effects that decrease enemy resistance (which is monotonically decreasing) does not violate this assumption\n   * as set effects are not handled here.\n   */\n  const allowRainbow = !exclusion.rainbow?.length,\n    keys = Object.keys(arts.base)\n  const noSwitchIn = new Set(\n    Object.entries(exclusion)\n      .filter(([_, v]) => v.length)\n      .map(([k]) => k) as ArtifactSetKey[]\n  )\n  const noSwitchOut = new Set(\n    Object.entries(exclusion)\n      .filter(([_, v]) => v.includes(2) && !v.includes(4))\n      .map(([k]) => k) as ArtifactSetKey[]\n  )\n  const values = objectKeyMap(allSlotKeys, (slot) => {\n    const list = arts.values[slot]\n    const newList = list.filter((art) => {\n      let count = 0\n      return list.every((other) => {\n        const otherBetterEqual = keys.every(\n          (k) => (other.values[k] ?? 0) >= (art.values[k] ?? 0)\n        )\n        const otherMaybeBetter = keys.some(\n          (k) => (other.values[k] ?? 0) > (art.values[k] ?? 0)\n        )\n        const otherBetter =\n          otherBetterEqual && (otherMaybeBetter || other.id > art.id)\n        const canSwitch =\n          (allowRainbow &&\n            !noSwitchIn.has(other.set!) &&\n            !noSwitchOut.has(art.set!)) ||\n          art.set === other.set\n        if (otherBetter && canSwitch) count++\n        return count < numTop\n      })\n    })\n    if (newList.length !== list.length) progress = true\n    return newList\n  })\n  return progress ? { base: arts.base, values } : arts\n}\n/** Remove artifacts that cannot reach `minimum` in any build */\nfunction pruneArtRange(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot,\n  minimum: number[]\n): ArtifactsBySlot {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  const wrap = { arts }\n  while (true) {\n    const artRanges = objectKeyMap(allSlotKeys, (slot) =>\n      computeArtRange(wrap.arts.values[slot])\n    )\n    const otherArtRanges = objectKeyMap(allSlotKeys, (key) =>\n      addArtRange(\n        Object.entries(artRanges)\n          .map((a) => (a[0] === key ? baseRange : a[1]))\n          .filter((x) => x)\n      )\n    )\n\n    let progress = false\n    const values = objectKeyMap(allSlotKeys, (slot) => {\n      const result = wrap.arts.values[slot].filter((art) => {\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\n        const newRange = computeNodeRange(nodes, read)\n        return nodes.every(\n          (node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity)\n        )\n      })\n      if (result.length !== wrap.arts.values[slot].length) progress = true\n      return result\n    })\n    if (!progress) break\n    wrap.arts = { base: wrap.arts.base, values }\n  }\n  return wrap.arts\n}\nfunction pruneNodeRange(nodes: OptNode[], arts: ArtifactsBySlot): OptNode[] {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  const reads = addArtRange([\n    baseRange,\n    ...Object.values(arts.values).map((values) => computeArtRange(values)),\n  ])\n  const nodeRange = computeNodeRange(nodes, reads)\n\n  return mapFormulas(\n    nodes,\n    (f) => {\n      {\n        const { min, max } = nodeRange.get(f)!\n        if (min === max) return constant(min)\n      }\n      const { operation } = f\n      const operandRanges = f.operands.map((x) => nodeRange.get(x)!)\n      switch (operation) {\n        case 'threshold': {\n          const [value, threshold, pass, fail] = operandRanges\n          if (value.min >= threshold.max) return f.operands[2]\n          else if (value.max < threshold.min) return f.operands[3]\n          if (\n            pass.max === pass.min &&\n            fail.max === fail.min &&\n            pass.min === fail.min &&\n            isFinite(pass.min)\n          )\n            return constant(pass.max)\n          break\n        }\n        case 'min': {\n          const newOperands = f.operands.filter((_, i) => {\n            const op1 = operandRanges[i]\n            return operandRanges.every((op2) => op1.min <= op2.max)\n          })\n          if (newOperands.length < operandRanges.length)\n            return min(...newOperands)\n          break\n        }\n        case 'max': {\n          const newOperands = f.operands.filter((_, i) => {\n            const op1 = operandRanges[i]\n            return operandRanges.every((op2) => op1.max >= op2.min)\n          })\n          if (newOperands.length < operandRanges.length)\n            return max(...newOperands)\n          break\n        }\n      }\n      return f\n    },\n    (f) => f\n  )\n}\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\n  const result: DynMinMax = {}\n  ranges.forEach((range) => {\n    Object.entries(range).forEach(([key, value]) => {\n      if (result[key]) {\n        result[key].min += value.min\n        result[key].max += value.max\n      } else result[key] = { ...value }\n    })\n  })\n  return result\n}\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\n  const result: DynMinMax = {}\n  if (arts.length) {\n    Object.keys(arts[0].values)\n      .filter((key) => arts.every((art) => art.values[key]))\n      .forEach(\n        (key) =>\n          (result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\n      )\n    arts.forEach(({ values }) => {\n      for (const [key, value] of Object.entries(values)) {\n        if (!result[key]) result[key] = { min: 0, max: value }\n        else {\n          if (result[key].max < value) result[key].max = value\n          if (result[key].min > value) result[key].min = value\n        }\n      }\n    })\n  }\n  return result\n}\nexport function computeFullArtRange(arts: ArtifactsBySlot): DynMinMax {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  return addArtRange([\n    baseRange,\n    ...Object.values(arts.values).map((values) => computeArtRange(values)),\n  ])\n}\nexport function computeNodeRange(\n  nodes: OptNode[],\n  reads: DynMinMax\n): Map<OptNode, MinMax> {\n  const range = new Map<OptNode, MinMax>()\n\n  forEachNodes(\n    nodes,\n    (_) => {},\n    (f) => {\n      const { operation } = f\n      const operands = f.operands.map((op) => range.get(op)!)\n      let current: MinMax\n      switch (operation) {\n        case 'read':\n          if (f.path[0] !== 'dyn')\n            throw new Error(\n              `Found non-dyn path ${f.path} while computing range`\n            )\n          current = reads[f.path[1]] ?? { min: 0, max: 0 }\n          break\n        case 'const':\n          current = computeMinMax([f.value])\n          break\n        case 'add':\n        case 'min':\n        case 'max':\n          current = {\n            min: allOperations[operation](operands.map((x) => x.min)),\n            max: allOperations[operation](operands.map((x) => x.max)),\n          }\n          break\n        case 'res':\n          current = {\n            min: allOperations[operation]([operands[0].max]),\n            max: allOperations[operation]([operands[0].min]),\n          }\n          break\n        case 'mul':\n          current = operands.reduce((accu, current) =>\n            computeMinMax([\n              accu.min * current.min,\n              accu.min * current.max,\n              accu.max * current.min,\n              accu.max * current.max,\n            ])\n          )\n          break\n        case 'threshold':\n          if (operands[0].min >= operands[1].max) current = operands[2]\n          else if (operands[0].max < operands[1].min) current = operands[3]\n          else current = computeMinMax([], [operands[2], operands[3]])\n          break\n        case 'sum_frac': {\n          const [x, c] = operands,\n            sum = { min: x.min + c.min, max: x.max + c.max }\n          if (sum.min <= 0 && sum.max >= 0)\n            current =\n              x.min <= 0 && x.max >= 0\n                ? { min: NaN, max: NaN }\n                : { min: -Infinity, max: Infinity }\n          // TODO: Check this\n          else\n            current = computeMinMax([\n              x.min / sum.min,\n              x.min / sum.max,\n              x.max / sum.min,\n              x.max / sum.max,\n            ])\n          break\n        }\n        default:\n          assertUnreachable(operation)\n      }\n      range.set(f, current)\n    }\n  )\n  return range\n}\nfunction computeMinMax(\n  values: readonly number[],\n  minMaxes: readonly MinMax[] = []\n): MinMax {\n  const max = Math.max(...values, ...minMaxes.map((x) => x.max))\n  const min = Math.min(...values, ...minMaxes.map((x) => x.min))\n  return { min, max }\n}\n\nexport function filterArts(\n  arts: ArtifactsBySlot,\n  filters: RequestFilter\n): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objectKeyMap(allSlotKeys, (slot) => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case 'id':\n          return arts.values[slot].filter((art) => filter.ids.has(art.id))\n        case 'exclude':\n          return arts.values[slot].filter((art) => !filter.sets.has(art.set!))\n        case 'required':\n          return arts.values[slot].filter((art) => filter.sets.has(art.set!))\n      }\n    }),\n  }\n}\n\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\n  return builds\n    .flatMap((x) => x)\n    .sort((a, b) => b.value - a.value)\n    .slice(0, maxNum)\n}\nexport function mergePlot(plots: PlotData[]): PlotData {\n  let scale = 0.01\n  const reductionScaling = 2,\n    maxCount = 1500\n  let keys = new Set(\n    plots.flatMap((x) =>\n      Object.values(x).map((v) => Math.round(v.plot! / scale))\n    )\n  )\n  while (keys.size > maxCount) {\n    scale *= reductionScaling\n    keys = new Set([...keys].map((key) => Math.round(key / reductionScaling)))\n  }\n  const result: PlotData = {}\n  for (const plot of plots)\n    for (const build of Object.values(plot)) {\n      const x = Math.round(build.plot! / scale) * scale\n      if (!result[x] || result[x]!.value < build.value) result[x] = build\n    }\n  return result\n}\n\nexport function countBuilds(arts: ArtifactsBySlot): number {\n  return allSlotKeys.reduce(\n    (_count, slot) => _count * arts.values[slot].length,\n    1\n  )\n}\n\nexport function* filterFeasiblePerm(\n  filters: Iterable<RequestFilter>,\n  _artSets: ArtifactsBySlot\n): Iterable<RequestFilter> {\n  const artSets = objectMap(\n    _artSets.values,\n    (values) => new Set(values.map((v) => v.set))\n  )\n  filter_loop: for (const filter of filters) {\n    for (const [slot, f] of Object.entries(filter)) {\n      const available = artSets[slot]!\n      switch (f.kind) {\n        case 'required':\n          if ([...f.sets].every((s) => !available.has(s))) continue filter_loop\n          break\n        case 'exclude':\n          if ([...available].every((s) => f.sets.has(s!))) continue filter_loop\n          break\n        case 'id':\n          break\n      }\n    }\n    yield filter\n  }\n}\nexport function exclusionToAllowed(\n  exclusion: number[] | undefined\n): Set<number> {\n  return new Set(\n    exclusion?.includes(2)\n      ? exclusion.includes(4)\n        ? [0, 1]\n        : [0, 1, 4, 5]\n      : exclusion?.includes(4)\n      ? [0, 1, 2, 3]\n      : [0, 1, 2, 3, 4, 5]\n  )\n}\n/** A *disjoint* set of `RequestFilter` satisfying the exclusion rules */\nexport function* artSetPerm(\n  exclusion: ArtSetExclusion,\n  _artSets: ArtifactSetKey[]\n): Iterable<RequestFilter> {\n  /**\n   * This generation algorithm is separated into two parts:\n   * - \"Shape\" generation\n   *   - It first generates all build \"shapes\", e.g., AABBC, ABBCD\n   *   - It then filters the generated shapes according to the rainbow exclusion, e.g., removes ABBCD if excluding 3 rainbows\n   *   - It then merges the remaining shapes into wildcards, e.g. AABAA + AABAB + AABAC => AABA*\n   * - Shape filling\n   *   - From the given shapes, it tries to fill in all non-rainbow slots, e.g., slots A and B of AABBC, with actual artifacts\n   *   - It then fills the rainbow slots, e.g., slot C of AABBC while ensuring the exclusion rule of each sets\n   */\n  const artSets = [...new Set(_artSets)],\n    allowedRainbows = exclusionToAllowed(exclusion.rainbow)\n  let shapes: number[][] = []\n  function populateShapes(\n    current: number[],\n    list: Set<number>,\n    rainbows: number[]\n  ) {\n    if (current.length === 5) {\n      if (allowedRainbows.has(rainbows.length)) shapes.push(current)\n      return\n    }\n    for (const i of list)\n      populateShapes(\n        [...current, i],\n        list,\n        rainbows.filter((j) => j !== i)\n      )\n    populateShapes(\n      [...current, current.length],\n      new Set([...list, current.length]),\n      [...rainbows, current.length]\n    )\n  }\n  populateShapes([0], new Set([0]), [0])\n  function indexOfShape(shape: number[], replacing: number) {\n    if (range(replacing + 1, 4).some((i) => shape[i] !== 5)) return undefined\n    shape = [...shape]\n    shape[replacing] = 5\n    return shape.reduce((a, b) => a * 6 + b, 0)\n  }\n  for (let replacing = 4; replacing >= 0; replacing--) {\n    const required: Map<number, number> = new Map()\n    for (const shape of shapes) {\n      const id = indexOfShape(shape, replacing)\n      if (id === undefined) continue\n      required.set(\n        id,\n        (required.get(id) ?? new Set(shape.slice(0, replacing)).size + 1) - 1\n      )\n    }\n    for (const [id, remaining] of required.entries()) {\n      if (remaining === 0) {\n        const shape = [\n          ...shapes.find((shape) => indexOfShape(shape, replacing) === id)!,\n        ]\n        shape[replacing] = 5\n        shapes = shapes.filter((shape) => indexOfShape(shape, replacing) !== id)\n        shapes.push(shape)\n      }\n    }\n  }\n\n  // Shapes are now calculated and merged, proceed to fill in the sets\n\n  const noFilter = { kind: 'exclude' as const, sets: new Set<ArtifactSetKey>() }\n  const result: RequestFilter = objectKeyMap(allSlotKeys, (_) => noFilter)\n\n  const counts = {\n    ...objectMap(exclusion, (_) => 0),\n    ...objectKeyMap(artSets, (_) => 0),\n  }\n  const allowedCounts = objectMap(exclusion, exclusionToAllowed)\n\n  function* check(shape: number[]) {\n    const used: Set<ArtifactSetKey> = new Set(),\n      rainbows: number[] = []\n    let groupped: number[][] = []\n    for (const i of shape) {\n      groupped.push([])\n      if (i === 5) rainbows.push(groupped.length - 1)\n      else groupped[i].push(groupped.length - 1)\n    }\n    groupped = groupped\n      .filter((v) => v.length)\n      .sort((a, b) => b.length - a.length)\n    let usableRainbows = rainbows.length\n\n    // Inception.. because js doesn't like functions inside a for-loop\n    function* check(i: number) {\n      if (i === groupped.length) return yield* check_free(0)\n\n      for (const set of artSets) {\n        if (used.has(set)) continue\n        const length = groupped[i].length,\n          allowedSet = allowedCounts[set]\n        let requiredRainbows = 0\n\n        if (allowedSet && !allowedSet.has(length)) {\n          // Look ahead and see if we have enough rainbows to fill to the next `allowedSet` if we use the current set\n          requiredRainbows =\n            (range(length + 1, 5).find((l) => allowedSet.has(l)) ?? 6) - length\n          if (requiredRainbows > usableRainbows) continue // Not enough rainbows. Next..\n        }\n\n        used.add(set)\n        counts[set] = groupped[i].length\n        groupped[i].forEach(\n          (j) =>\n            (result[allSlotKeys[j]] = {\n              kind: 'required',\n              sets: new Set([set]),\n            })\n        )\n        usableRainbows -= requiredRainbows\n\n        yield* check(i + 1)\n\n        usableRainbows += requiredRainbows\n        counts[set] = 0\n        used.delete(set)\n      }\n    }\n    // We separate filling rainbow slots from groupped slots because it has an entirely\n    // different set of rules regarding what can be filled and what states to be kept.\n    function* check_free(i: number) {\n      const remaining = rainbows.length - i,\n        isolated: ArtifactSetKey[] = [],\n        missing: ArtifactSetKey[] = [],\n        rejected: ArtifactSetKey[] = []\n      let required = 0\n      for (const set of artSets) {\n        const allowedSet = allowedCounts[set],\n          count = counts[set]\n        if (!allowedSet) continue\n        if (range(1, remaining).every((j) => !allowedSet.has(count + j)))\n          rejected.push(set)\n        else if (!allowedSet.has(count)) {\n          required += [...allowedSet].find((x) => x > count)! - count\n          missing.push(set)\n        } else if (range(0, remaining).some((j) => !allowedSet.has(count + j)))\n          isolated.push(set)\n      }\n      if (required > remaining) return\n      if (i === rainbows.length) {\n        yield { ...result }\n        return\n      }\n      if (required === remaining) {\n        for (const set of missing) {\n          counts[set]++\n          result[allSlotKeys[rainbows[i]]] = {\n            kind: 'required',\n            sets: new Set([set]),\n          }\n          yield* check_free(i + 1)\n          counts[set]--\n        }\n        return\n      }\n      for (const set of [...isolated, ...missing]) {\n        counts[set]++\n        result[allSlotKeys[rainbows[i]]] = {\n          kind: 'required',\n          sets: new Set([set]),\n        }\n        yield* check_free(i + 1)\n        counts[set]--\n      }\n      result[allSlotKeys[rainbows[i]]] = {\n        kind: 'exclude',\n        sets: new Set([...missing, ...rejected, ...isolated]),\n      }\n      yield* check_free(i + 1)\n    }\n    yield* check(0)\n  }\n  for (const shape of shapes) yield* check(shape)\n}\n\nexport type RequestFilter = StrictDict<\n  SlotKey,\n  | { kind: 'required'; sets: Set<ArtifactSetKey> }\n  | { kind: 'exclude'; sets: Set<ArtifactSetKey> }\n  | { kind: 'id'; ids: Set<string> }\n>\n\nexport type DynStat = { [key in string]: number }\nexport type ArtifactBuildData = {\n  id: string\n  set?: ArtifactSetKey\n  values: DynStat\n}\nexport type ArtifactsBySlot = {\n  base: DynStat\n  values: StrictDict<SlotKey, ArtifactBuildData[]>\n}\n\nexport type PlotData = Dict<number, Build>\nexport interface Build {\n  value: number\n  plot?: number\n  artifactIds: string[]\n}\n\nexport type DynMinMax = { [key in string]: MinMax }\nexport type MinMax = { min: number; max: number }\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { customMapFormula, forEachNodes } from '../../Formula/internal'\nimport type { OptNode } from '../../Formula/optimization'\nimport { allOperations } from '../../Formula/optimization'\nimport type { ConstantNode } from '../../Formula/type'\nimport { prod, threshold } from '../../Formula/utils'\nimport { assertUnreachable, cartesian } from '../../Util/Util'\nimport type { ArtifactsBySlot, MinMax } from '../common'\nimport { computeFullArtRange, computeNodeRange } from '../common'\nimport type { Linear } from './linearUB'\n\n/**\n * With xi being the variables and pi(x1, x2, ...) being polynomials on xi\n *    LinTerm  = $c + w1*x1 + w2*x2 + ...\n *    PolyProd = $k * p1 * p2 * ...\n *    PolySum  = $c + p1 + p2 + ...\n *\n * $c is used as additive constant, $k is used as multiplicative constant.\n */\nexport type PolynomialWithBounds = PolyProd | PolySum | LinTerm\ntype LinTerm = { type: 'lin'; lin: Linear; min: number; max: number }\ntype PolyProd = {\n  type: 'prod'\n  terms: PolynomialWithBounds[]\n  $k: number\n  min: number\n  max: number\n}\ntype PolySum = {\n  type: 'sum'\n  terms: PolynomialWithBounds[]\n  $c: number\n  min: number\n  max: number\n}\n\nfunction constP(n: number): LinTerm {\n  return { type: 'lin', lin: { $c: n }, min: n, max: n }\n}\nfunction readP(k: string, minmax: MinMax): LinTerm {\n  return { type: 'lin', lin: { [k]: 1, $c: 0 }, ...minmax }\n}\nfunction sumP(...terms: (PolynomialWithBounds | number)[]): PolySum {\n  const c = (terms.filter((v) => typeof v === 'number') as number[]).reduce(\n    (a, b) => a + b,\n    0\n  )\n  const poly = terms.filter(\n    (v) => typeof v !== 'number'\n  ) as PolynomialWithBounds[]\n  return {\n    type: 'sum',\n    terms: poly,\n    $c: c,\n    min: poly.reduce((a, { min }) => a + min, c),\n    max: poly.reduce((a, { max }) => a + max, c),\n  }\n}\nfunction prodP(...terms: (PolynomialWithBounds | number)[]): PolyProd {\n  const k = (terms.filter((v) => typeof v === 'number') as number[]).reduce(\n    (a, b) => a * b,\n    1\n  )\n  const poly = terms.filter(\n    (v) => typeof v !== 'number'\n  ) as PolynomialWithBounds[]\n  const minMax = poly.reduce(\n    ({ min: min1, max: max1 }, { min: min2, max: max2 }) => {\n      return {\n        min: Math.min(min1 * min2, min1 * max2, max1 * min2, max1 * max2),\n        max: Math.max(min1 * min2, min1 * max2, max1 * min2, max1 * max2),\n      }\n    },\n    { min: k, max: k }\n  )\n  return { type: 'prod', terms: poly, $k: k, ...minMax }\n}\n\nfunction slopePoint(\n  slope: number,\n  x0: number,\n  y0: number,\n  poly: PolynomialWithBounds\n): PolynomialWithBounds {\n  return sumP(y0 - slope * x0, prodP(slope, poly))\n}\nfunction interpolate(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  poly: PolynomialWithBounds,\n  upper: boolean\n): PolynomialWithBounds {\n  if (Math.abs(x0 - x1) < 1e-10)\n    return constP(upper ? Math.max(y0, y1) : Math.min(y0, y1))\n  return slopePoint((y1 - y0) / (x1 - x0), x0, y0, poly)\n}\n\nexport function polyUB(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot\n): SumOfMonomials[] {\n  const minMaxes = new Map<OptNode, MinMax>()\n  forEachNodes(\n    nodes,\n    (f) => {\n      const { operation } = f\n      if (operation === 'mul') minMaxes.set(f, { min: NaN, max: NaN })\n      switch (operation) {\n        case 'mul':\n        case 'min':\n        case 'max':\n        case 'threshold':\n        case 'res':\n        case 'sum_frac':\n          f.operands.forEach((op) => minMaxes.set(op, { min: NaN, max: NaN }))\n      }\n    },\n    (_) => _\n  )\n  const statMinMax = computeFullArtRange(arts)\n  const nodeRanges = computeNodeRange([...minMaxes.keys()], statMinMax)\n  for (const [node, minMax] of nodeRanges.entries()) minMaxes.set(node, minMax)\n\n  const upper = 'u',\n    lower = 'l',\n    exact = 'e'\n  type Context = typeof upper | typeof lower | typeof exact\n  const poly = customMapFormula<Context, PolynomialWithBounds, OptNode>(\n    nodes,\n    upper,\n    (f, context, _map) => {\n      const { operation } = f\n      const map: (op: OptNode, c?: Context) => PolynomialWithBounds = (\n        op,\n        c = context\n      ) => _map(op, c)\n      const oppositeContext = context === upper ? lower : upper\n\n      switch (operation) {\n        case 'const':\n          return constP(f.value)\n        case 'read':\n          return readP(f.path[1], minMaxes.get(f)!)\n        case 'add':\n          return sumP(...f.operands.map((op) => map(op)))\n        case 'mul': {\n          if (context === exact)\n            return prodP(...f.operands.map((op) => map(op)))\n          const { min: minf, max: maxf } = minMaxes.get(f)!\n          if (minf === maxf) return constP(minf) // Handles zero coeff\n          const zeroCrossing =\n            minf * maxf < 0 ||\n            f.operands.some((op) => {\n              const { min, max } = minMaxes.get(op)!\n              return min * max < 0\n            })\n          if (zeroCrossing) return map(f, exact)\n\n          const signf = minf === 0 ? maxf : minf\n          const op = allOperations[operation]\n          const k = op(\n            f.operands\n              .filter((op) => op.operation === 'const')\n              .map((c) => (c as ConstantNode<number>).value)\n          )\n          const polys = f.operands\n            .filter((op) => op.operation !== 'const')\n            .map((op) => {\n              const { min, max } = minMaxes.get(op)!\n              const sign = min === 0 ? max : min\n              const ctx = signf * sign > 0 ? context : oppositeContext\n              const p = map(op, ctx)\n\n              if (\n                (ctx === lower && max > 0 && p.min < -min) ||\n                (ctx === upper && min < 0 && p.max > -max)\n              )\n                throw new PolyError(\n                  'Unallowed large crossing post approximation',\n                  operation\n                )\n\n              return p\n            })\n          return prodP(k, ...polys)\n        }\n        case 'min':\n        case 'max': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          const op = allOperations[operation]\n          const xs = f.operands.filter((op) => op.operation !== 'const'),\n            [xOp] = xs\n          if (xs.length !== 1) throw new PolyError('Multivariate', operation)\n\n          const x = map(xOp),\n            c = op(\n              f.operands\n                .filter((op) => op.operation === 'const')\n                .map((c) => (c as ConstantNode<number>).value)\n            )\n          if (\n            (operation === 'max' && context === lower) ||\n            (operation === 'min' && context === upper)\n          )\n            return x\n          const { min, max } = minMaxes.get(xOp)!,\n            yMin = op([min, c]),\n            yMax = op([max, c])\n          return interpolate(min, yMin, max, yMax, x, context === upper)\n        }\n        case 'res': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          if (context === lower)\n            throw new PolyError('Unsupported direction', operation)\n          const op = allOperations[operation]\n          const [xOp] = f.operands,\n            { min, max } = minMaxes.get(xOp)!\n          const x = map(xOp, oppositeContext)\n          // Linear region 1 - base/2 or concave region with peak at base = 0\n          if (min < 0 && max < 1.75) return sumP(1, prodP(-0.5, x))\n          // Clamp `min` to guarantee upper bound\n          else\n            return interpolate(\n              min,\n              op([min]),\n              max,\n              op([max]),\n              x,\n              context === upper\n            )\n        }\n        case 'sum_frac': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          if (context === lower)\n            throw new PolyError('Unsupported direction', operation)\n          const [xOp, cOp] = f.operands\n          if (cOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          const x = map(xOp),\n            c = cOp.value,\n            { min, max } = minMaxes.get(xOp)!\n          if (min <= -c)\n            throw new PolyError('Unallowed negative argument', operation)\n          const loc = Math.sqrt((min + c) * (max + c))\n          return slopePoint(c / (loc + c) / (loc + c), loc, loc / (loc + c), x)\n        }\n        case 'threshold': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          const [vOp, tOp, pOp, fOp] = f.operands\n          if (tOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          const { min, max } = minMaxes.get(vOp)!\n          if (min >= tOp.value) return map(pOp)\n          if (max < tOp.value) return map(fOp)\n\n          if (fOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          if (pOp.operation !== 'const') {\n            if (fOp.value !== 0)\n              throw new PolyError('Unsupported pattern', operation)\n\n            const threshOp = threshold(vOp, tOp, 1, fOp),\n              mulOp = prod(threshOp, pOp)\n            // Populate `minMaxes` to ensure consistency\n            const { min, max } = minMaxes.get(pOp)!\n            minMaxes.set(threshOp, { min: 0, max: 1 })\n            minMaxes.set(mulOp, {\n              min: Math.min(min, 0),\n              max: Math.max(max, 0),\n            })\n            return map(mulOp)\n          }\n          const thresh = tOp.value,\n            pass = pOp.value,\n            fail = fOp.value\n          const isFirstHalf = pass > fail === (context === upper)\n\n          const v = map(vOp, isFirstHalf ? upper : lower)\n          if (isFirstHalf) {\n            const slope = (pass - fail) / (thresh - min)\n            return slopePoint(slope, thresh, pass, v)\n          }\n          // not first half -> return const(fail)\n          // Can also interpolate slopePoint on 2nd half, but I choose not to\n          return constP(fail)\n        }\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n\n  return poly.map((p) => expandPoly(p))\n}\n\nexport type SumOfMonomials = Monomial[]\ntype Monomial = {\n  $k: number\n  terms: string[]\n}\nfunction constM(v: number): Monomial {\n  return { $k: v, terms: [] }\n}\nfunction weightedReadM(key: string, v: number): Monomial {\n  return { $k: v, terms: [key] }\n}\nfunction sumM(...monomials: Monomial[][]): Monomial[] {\n  return monomials.flat()\n}\nfunction prodM(...monomials: Monomial[][]): Monomial[] {\n  return cartesian(...monomials).map((monos) =>\n    monos.reduce(\n      (ret, nxt) => {\n        ret.$k *= nxt.$k\n        ret.terms.push(...nxt.terms)\n        return ret\n      },\n      { $k: 1, terms: [] }\n    )\n  )\n}\nfunction foldLikeTerms(mon: Monomial[]): Monomial[] {\n  mon.forEach((m) => m.terms.sort())\n  mon.sort(({ terms: termsA }, { terms: termsB }) => {\n    if (termsA.length !== termsB.length) return termsA.length - termsB.length\n    for (let i = 0; i < termsA.length; i++) {\n      if (termsA[i] !== termsB[i]) return termsA[i] < termsB[i] ? -1 : +1\n    }\n    return 0\n  })\n\n  for (let i = mon.length - 2; i >= 0; i--) {\n    if (mon[i].$k === 0) {\n      mon.splice(i, 1)\n      continue\n    }\n    const a = mon[i].terms\n    const b = mon[i + 1].terms\n    if (a.length !== b.length) continue\n    if (a.every((ai, i) => ai === b[i])) {\n      mon[i].$k = mon[i].$k + mon[i + 1].$k\n      mon.splice(i + 1, 1)\n    }\n  }\n  return mon\n}\nfunction expandPoly(node: PolynomialWithBounds): SumOfMonomials {\n  function toExpandedPoly(n: PolynomialWithBounds): Monomial[] {\n    switch (n.type) {\n      case 'lin':\n        return Object.entries(n.lin)\n          .filter(([_, v]) => v !== 0)\n          .map(([k, v]) => {\n            if (k === '$c') return constM(v)\n            return weightedReadM(k, v)\n          })\n      case 'sum':\n        return sumM(...n.terms.map((t) => toExpandedPoly(t)), [constM(n.$c)])\n      case 'prod':\n        return prodM(...n.terms.map((t) => toExpandedPoly(t)), [constM(n.$k)])\n    }\n  }\n\n  return foldLikeTerms(toExpandedPoly(node))\n}\n\nclass PolyError extends Error {\n  constructor(cause: string, operation: string) {\n    super(\n      `Found ${cause} in ${operation} node when generating polynomial upper bound`\n    )\n  }\n}\n","// Matrix convention is row-major, indexed A_{ij} = A[i][j]\ntype Pivot = { i: number; j: number }\nconst zero = 1e-8 // Small number equivalent to 0 for numerical instability\n\n/** Checks that all constraints are satisfied (Ax <= b) */\nexport function isFeasible(Ab: number[][], x: number[]): boolean {\n  const b = x.length\n  return Ab.every(\n    (row) => x.reduce((tot, xi, i) => tot + xi * row[i], 0) <= row[b] + zero\n  )\n}\n\n/**\n * Solve a Linear Program defined by:\n *              min  c^T x\n *               x\n *   Subject to:     Ax <= b\n *                    x >= 0\n *\n * Implemented according to the Simplex Method (Sec 4) of:\n *   Ferguson, https://www.math.ucla.edu/~tom/LP.pdf\n *\n * Does not implement any cycle detection, though that *shouldnt* be a problem for GO's use\n *   case. This algorithm will always return a feasible solution, though it may be suboptimal.\n *\n * @param c        Objective vector\n * @param Ab       Constraints matrix with thresholds. Inputted in block form [A, b]\n * @returns        a valid solution x, optimal if everything went well.\n */\nexport function solveLP(c: number[], Ab: number[][]) {\n  const rows = Ab.length + 1\n  const cols = Ab[0].length\n\n  const tableau = Array(rows)\n    .fill(0)\n    .map((_) => Array(cols).fill(0))\n  Ab.forEach((Ai, i) => Ai.forEach((Aij, j) => (tableau[i][j] = Aij)))\n  c.forEach((cj, j) => (tableau[rows - 1][j] = cj))\n\n  const pivotHistory: Pivot[] = [] // Keep track of all chosen pivots for backtracking later\n\n  while (tableau.some((t, i) => i < rows - 1 && t[cols - 1] < -zero)) {\n    const piv = findPiv2(tableau)\n    pivotHistory.push(piv)\n    pivotInplace(tableau, piv)\n  }\n\n  while (tableau[rows - 1].some((t, j) => j < cols - 1 && t < -zero)) {\n    const piv = findPiv1(tableau)\n    pivotHistory.push(piv)\n    pivotInplace(tableau, piv)\n  }\n\n  const xOpt = c.map((_, i) => backtrack(tableau, pivotHistory, i))\n  if (!isFeasible(Ab, xOpt)) throw Error('COMPUTED SOLUTION IS NOT FEASIBLE')\n  return xOpt\n}\n\n/** Standard `pivot` operation on LPs */\nfunction pivotInplace(A: number[][], { i, j }: Pivot) {\n  const Aij = A[i][j]\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    for (let k = 0; k < A[0].length; k++) {\n      if (k === j) continue\n      A[h][k] -= (A[i][k] * A[h][j]) / Aij\n    }\n  }\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    A[h][j] = -A[h][j] / Aij\n  }\n  for (let k = 0; k < A[0].length; k++) {\n    if (k === j) continue\n    A[i][k] = A[i][k] / Aij\n  }\n  A[i][j] = 1 / Aij\n}\n\n/** Find a pivot according to Case 1 (Ferguson p23) */\nfunction findPiv1(A: number[][]) {\n  const r = A.length,\n    c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let j = 0; j < c - 1; j++) {\n    if (A[r - 1][j] >= -zero) continue\n    for (let i = 0; i < r - 1; i++) {\n      if (A[i][j] > zero) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('UNBOUNDED FEASIBLE')\n  }\n  if (minloc.i < 0) throw Error('NO PIVOTS (done)')\n  return { i: minloc.i, j: minloc.j }\n}\n\n/** Find a pivot according to Case 2 (Ferguson p24) */\nfunction findPiv2(A: number[][]) {\n  const r = A.length,\n    c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let i = 0; i < r - 1; i++) {\n    if (A[i][c - 1] >= -zero) continue\n    for (let j = 0; j < c - 1; j++) {\n      if (A[i][j] < -zero) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('INFEASIBLE')\n    return { i: minloc.i, j: minloc.j }\n  }\n  throw Error('NO PIVOTS (done)')\n}\n\n/** Backtracking algorithm to find solution vector */\nfunction backtrack(tableau: number[][], pivotHistory: Pivot[], targ: number) {\n  let side = 1 // 0 left, 1 right\n  pivotHistory.forEach(({ i, j }) => {\n    if (side === 1 && j === targ) {\n      targ = i\n      side = 0\n    } else if (side === 0 && i === targ) {\n      targ = j\n      side = 1\n    }\n  })\n\n  const ncol = tableau[0].length\n  return side === 0 ? tableau[targ][ncol - 1] : 0\n}\n","import type { OptNode } from '../../Formula/optimization'\nimport { assertUnreachable, cartesian } from '../../Util/Util'\nimport type { ArtifactsBySlot, DynStat, MinMax } from '../common'\nimport { computeFullArtRange } from '../common'\nimport { polyUB } from './polyUB'\nimport { solveLP } from './solveLP'\n\nexport type Linear = DynStat & { $c: number }\n\nfunction weightedSum(\n  ...entries: readonly (readonly [number, Linear])[]\n): Linear {\n  const result = { $c: 0 }\n  for (const [weight, entry] of entries)\n    for (const [k, v] of Object.entries(entry))\n      result[k] = (result[k] ?? 0) + weight * v\n  return result\n}\n\nexport function linearUB(nodes: OptNode[], arts: ArtifactsBySlot): Linear[] {\n  const polys = polyUB(nodes, arts)\n  const minMax = computeFullArtRange(arts)\n\n  return polys.map((poly) =>\n    weightedSum(\n      ...poly.map((mon) => {\n        const bounds = mon.terms.map((key) => minMax[key])\n        const { w, $c } = linbound(bounds, mon.$k >= 0 ? 'upper' : 'lower')\n        const linboi: Linear = { $c }\n        mon.terms.forEach((key, i) => (linboi[key] = w[i] + (linboi[key] ?? 0)))\n        return [mon.$k, linboi] as readonly [number, Linear]\n      })\n    )\n  )\n}\n\n/**\n * Constructs a linear upper/lower bound for a monomial on a bounded domain using an LP.\n *\n * Monomial is assumed to be\n *    m(x) = x1 * x2 * ... * xn\n * on bounded domain\n *    min_1 <= x1 <= max_1\n *    min_2 <= x2 <= max_2\n *    ...\n *    min_n <= xn <= max_n\n *\n * @param bounds List of min & max bounds for each xi\n * @returns A linear function L(x) = w . x + $c\n *            satisfying      m(x) <= L(x) <= m(x) + err (resp. m(x) - err <= L(x) <= m(x))\n */\nfunction linbound(\n  bounds: MinMax[],\n  direction: 'upper' | 'lower' = 'upper'\n): { w: number[]; $c: number; err: number } {\n  if (bounds.length === 0) return { w: [], $c: 1, err: 0 } // vacuous product is 0\n  const nVar = bounds.length\n\n  // Re-scale bounds to [0, 1] for numerical stability.\n  const boundScale = bounds.map(({ min, max }) => Math.max(-min, max))\n  const scaleProd = boundScale.reduce((prod, v) => prod * v, 1)\n  bounds = bounds.map(({ min, max }, i) => ({\n    min: min / boundScale[i],\n    max: max / boundScale[i],\n  }))\n  // Setting up the linear program in terms of constraints.\n  //   cartesian(bounds) loops 2^nVar times\n  const cons = cartesian(...bounds.map(({ min, max }) => [min, max])).flatMap(\n    (coords) => {\n      const prod = coords.reduce((prod, v) => prod * v, 1)\n      const sum = coords.reduce((sum, v) => sum + v, 0)\n      switch (direction) {\n        case 'upper':\n          return [\n            [...coords, -1, 0, sum - prod - nVar],\n            [...coords.map((v) => -v), 1, -1, nVar + prod - sum],\n          ]\n        case 'lower':\n          return [\n            [...coords.map((v) => -v), -1, 0, prod - sum - nVar],\n            [...coords, 1, -1, nVar + sum - prod],\n          ]\n        default:\n          assertUnreachable(direction)\n      }\n    }\n  )\n\n  const objective = [...bounds.map((_) => 0), 0, 1]\n  try {\n    const soln = solveLP(objective, cons)\n    switch (direction) {\n      case 'upper':\n        return {\n          w: soln\n            .slice(0, nVar)\n            .map((wi, i) => ((1 - wi) * scaleProd) / boundScale[i]),\n          $c: scaleProd * (soln[nVar] - nVar),\n          err: scaleProd * soln[nVar + 1],\n        }\n      case 'lower':\n        return {\n          w: soln\n            .slice(0, nVar)\n            .map((wi, i) => ((1 - wi) * scaleProd) / boundScale[i]),\n          $c: scaleProd * (nVar - soln[nVar]),\n          err: scaleProd * soln[nVar + 1],\n        }\n      default:\n        assertUnreachable(direction)\n    }\n  } catch (e) {\n    console.log('ERROR on bounds', bounds)\n    console.log('Possibly numerical instability issue.')\n    console.log(e)\n    throw e\n  }\n}\n","import type { Interim, Setup } from '..'\nimport type { OptNode } from '../../Formula/optimization'\nimport type { ArtifactSlotKey } from '@genshin-optimizer/consts'\nimport { objectKeyValueMap, objectMap } from '../../Util/Util'\nimport type {\n  ArtifactBuildData,\n  ArtifactsBySlot,\n  DynStat,\n  RequestFilter,\n} from '../common'\nimport { countBuilds, filterArts, pruneAll } from '../common'\nimport type { SplitWorker } from './BackgroundWorker'\nimport { linearUB } from './linearUB'\n\ntype Approximation = {\n  base: number\n  /** optimization target contribution from a given artifact (id) */\n  conts: StrictDict<string, number>\n}\ntype Filter = {\n  nodes: OptNode[]\n  arts: ArtifactsBySlot\n  /**\n   * The contribution of each artifact to the optimization target. The (over)estimated\n   * optimization target value is the sum of contributions of all artifacts in the build.\n   */\n  approxs: Approximation[]\n  maxConts: Record<ArtifactSlotKey, number>[]\n  /** How many times has this filter been splitted */\n  age: number\n  /** Total number of builds in this filter */\n  count: number\n  /** Whether or not this filter is in a valid (calculated) state */\n  calculated?: boolean\n}\nexport class BNBSplitWorker implements SplitWorker {\n  min: number[]\n  nodes: OptNode[]\n  arts: ArtifactsBySlot\n  topN: number\n\n  /**\n   * Filters are not neccessarily in a valid state, i.e., \"calculated\".\n   * We amortize the calculation to 1-per-split so that the calculation\n   * overhead doesn't lead to lag.\n   */\n  filters: Filter[] = []\n  interim: Interim | undefined\n  firstUncalculated = 0\n\n  callback: (interim: Interim) => void\n\n  constructor(\n    { arts, optTarget, constraints, topN }: Setup,\n    callback: (interim: Interim) => void\n  ) {\n    this.arts = arts\n    this.min = [-Infinity, ...constraints.map((x) => x.min)]\n    this.nodes = [optTarget, ...constraints.map((x) => x.value)]\n    this.callback = callback\n    this.topN = topN\n\n    // make sure we can approximate it\n    linearUB(this.nodes, arts)\n  }\n\n  addFilter(filter: RequestFilter): void {\n    const arts = filterArts(this.arts, filter),\n      count = countBuilds(arts)\n    if (count)\n      this.filters.push({\n        nodes: this.nodes,\n        arts,\n        maxConts: [],\n        approxs: [],\n        age: 0,\n        count,\n      })\n  }\n  setThreshold(newThreshold: number): void {\n    if (newThreshold > this.min[0]) {\n      this.min[0] = newThreshold\n      // All calculations become stale\n      this.firstUncalculated = 0\n      this.filters.forEach((filter) => delete filter.calculated)\n    }\n  }\n  *split(filter: RequestFilter, minCount: number): Generator<RequestFilter> {\n    this.addFilter(filter)\n\n    while (this.filters.length) {\n      const filter = this.getApproxFilter(),\n        { arts, count } = filter\n\n      if (count <= minCount) {\n        if (!count) continue\n        if (this.firstUncalculated < this.filters.length)\n          this.calculateFilter(this.firstUncalculated++) // Amortize the filter calculation to 1-per-split\n\n        this.reportInterim(false)\n        yield objectMap(arts.values, (arts) => ({\n          kind: 'id' as const,\n          ids: new Set(arts.map((art) => art.id)),\n        }))\n      } else this.splitOldFilter(filter)\n    }\n\n    this.reportInterim(true)\n  }\n\n  reportInterim(forced = false) {\n    if (this.interim && (this.interim.skipped > 1000000 || forced === true)) {\n      this.callback(this.interim)\n      this.interim = undefined\n    }\n  }\n\n  splitOldFilter({ nodes, arts, approxs, age }: Filter) {\n    /**\n     * Split the artifacts in each slot into high/low main (index 0) contribution along 1/3 of the\n     * contribution range. If the main contribution of a slot is in range 500-2000, the the high-\n     * contibution artifact has contribution of at least 1500, and the rest are low-contribution.\n     */\n    const splitted = objectMap(arts.values, (arts) => {\n      const remaining = arts\n        .map((art) => ({ art, cont: approxs[0].conts[art.id] }))\n        .sort(({ cont: c1 }, { cont: c2 }) => c2 - c1)\n      const minCont = remaining[remaining.length - 1]?.cont ?? 0\n      let contCutoff =\n        remaining.reduce(\n          (accu, { cont }) => accu + cont,\n          -minCont * remaining.length\n        ) / 3\n\n      const index = Math.max(\n        1,\n        remaining.findIndex(({ cont }) => (contCutoff -= cont - minCont) <= 0)\n      )\n      const lowArts = remaining.splice(index).map(({ art }) => art),\n        highArts = remaining.map(({ art }) => art)\n      return {\n        high: {\n          arts: highArts,\n          maxConts: approxs.map((approx) => maxContribution(highArts, approx)),\n        },\n        low: {\n          arts: lowArts,\n          maxConts: approxs.map((approx) => maxContribution(lowArts, approx)),\n        },\n      }\n    })\n    const remaining = Object.keys(splitted),\n      { filters } = this\n    const current: StrictDict<ArtifactSlotKey, ArtifactBuildData[]> = {} as any\n    const currentCont: StrictDict<ArtifactSlotKey, number[]> = {} as any\n    function partialSplit(count: number) {\n      if (!remaining.length) {\n        const maxConts = approxs.map((_, i) =>\n          objectMap(currentCont, (val) => val[i])\n        )\n        const currentArts = { base: arts.base, values: { ...current } }\n        filters.push({\n          nodes,\n          arts: currentArts,\n          maxConts,\n          approxs,\n          age: age + 1,\n          count,\n        })\n        return\n      }\n      const slot = remaining.pop()!,\n        { high, low } = splitted[slot]\n      if (low.arts.length) {\n        current[slot] = low.arts\n        currentCont[slot] = low.maxConts\n        partialSplit(count * low.arts.length)\n      }\n      if (high.arts.length) {\n        current[slot] = high.arts\n        currentCont[slot] = high.maxConts\n        partialSplit(count * high.arts.length)\n      }\n      remaining.push(slot)\n    }\n    partialSplit(1)\n  }\n\n  /** *Precondition*: `this.filters` must not be empty */\n  getApproxFilter(): Filter {\n    this.calculateFilter(this.filters.length - 1)\n    if (this.firstUncalculated > this.filters.length)\n      this.firstUncalculated = this.filters.length\n    return this.filters.pop()!\n  }\n  /** Update calculate on filter at index `i` if not done so already */\n  calculateFilter(i: number): void {\n    let { nodes, arts, maxConts, approxs } = this.filters[i]\n    const { age, count: oldCount, calculated } = this.filters[i]\n    if (calculated) return\n    if (age < 3 || age % 5 === 2) {\n      // Make sure the condition includes initial filter `age === 0`\n      // Either the filter is so early that we can get a good cutoff, or the problem has\n      // gotten small enough that the old approximation becomes inaccurate\n      ;({ nodes, arts } = pruneAll(\n        nodes,\n        this.min,\n        arts,\n        this.topN,\n        {},\n        { pruneNodeRange: true }\n      ))\n      if (Object.values(arts.values).every((x) => x.length)) {\n        approxs = approximation(nodes, arts)\n        maxConts = approxs.map((approx) =>\n          objectMap(arts.values, (val) => maxContribution(val, approx))\n        )\n      }\n    }\n    // Removing artifacts that doesn't meet the required opt target contributions.\n    //\n    // We could actually loop `newValues` computation if the removed artifacts have\n    // the highest contribution in one of the target node as the removal will raise\n    // the required contribution even further. However, once is generally enough.\n    const leadingConts = maxConts.map((cont, i) =>\n      Object.values(cont).reduce(\n        (accu, val) => accu + val,\n        approxs[i].base - this.min[i]\n      )\n    )\n    const newValues = objectMap(arts.values, (arts, slot) => {\n      const requiredConts = leadingConts.map((lc, i) => maxConts[i][slot] - lc)\n      return arts.filter(({ id }) =>\n        approxs.every(({ conts }, i) => conts[id] >= requiredConts[i])\n      )\n    })\n    arts = { base: arts.base, values: newValues }\n    const newCount = countBuilds(arts)\n    if (newCount !== oldCount)\n      if (this.interim) this.interim.skipped += oldCount - newCount\n      else\n        this.interim = {\n          resultType: 'interim',\n          buildValues: undefined,\n          tested: 0,\n          failed: 0,\n          skipped: oldCount - newCount,\n        }\n    this.filters[i] = {\n      nodes,\n      arts,\n      maxConts,\n      approxs,\n      age,\n      count: newCount,\n      calculated: true,\n    }\n  }\n}\n\nfunction maxContribution(\n  arts: ArtifactBuildData[],\n  approximation: Approximation\n): number {\n  return Math.max(...arts.map(({ id }) => approximation.conts[id]!))\n}\nfunction approximation(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot\n): Approximation[] {\n  return linearUB(nodes, arts).map((weight) => ({\n    base: dot(arts.base, weight, weight.$c),\n    conts: objectKeyValueMap(Object.values(arts.values).flat(), (data) => [\n      data.id,\n      dot(data.values, weight, 0),\n    ]),\n  }))\n}\nfunction dot(values: DynStat, lin: DynStat, c: number): number {\n  return Object.entries(values).reduce(\n    (accu, [k, v]) => accu + (lin[k] ?? 0) * v,\n    c\n  )\n}\n","import type { Interim, Setup } from '..'\nimport type { OptNode } from '../../Formula/optimization'\nimport { optimize, precompute } from '../../Formula/optimization'\nimport type {\n  ArtifactBuildData,\n  ArtifactsBySlot,\n  Build,\n  PlotData,\n  RequestFilter,\n} from '../common'\nimport { countBuilds, filterArts, mergePlot, pruneAll } from '../common'\n\nexport class ComputeWorker {\n  builds: Build[] = []\n  buildValues: number[] | undefined = undefined\n  plotData: PlotData | undefined\n  threshold = -Infinity\n  topN: number\n  min: number[]\n\n  arts: ArtifactsBySlot\n  nodes: OptNode[]\n\n  callback: (interim: Interim) => void\n\n  constructor(\n    { arts, optTarget, constraints, plotBase, topN }: Setup,\n    callback: (interim: Interim) => void\n  ) {\n    this.arts = arts\n    this.min = constraints.map((x) => x.min)\n    this.topN = topN\n    this.callback = callback\n    this.nodes = constraints.map((x) => x.value)\n    this.nodes.push(optTarget)\n    if (plotBase) {\n      this.plotData = {}\n      this.nodes.push(plotBase)\n    }\n    this.nodes = optimize(this.nodes, {}, (_) => false)\n  }\n\n  setThreshold(newThreshold: number) {\n    if (this.threshold > newThreshold) this.threshold = newThreshold\n  }\n  compute(filter: RequestFilter) {\n    const { min } = this\n    let preArts = filterArts(this.arts, filter)\n    const totalCount = countBuilds(preArts),\n      oldMaxBuildCount = this.builds.length\n\n    let nodes = this.nodes\n    ;({ nodes, arts: preArts } = pruneAll(\n      nodes,\n      min,\n      preArts,\n      this.topN,\n      {},\n      {\n        pruneArtRange: true,\n        pruneNodeRange: true,\n      }\n    ))\n    const arts = Object.values(preArts.values).sort(\n      (a, b) => a.length - b.length\n    )\n    const compute = precompute(\n      nodes,\n      preArts.base,\n      (f) => f.path[1],\n      arts.length\n    )\n\n    const buffer = Array<ArtifactBuildData>(arts.length)\n    const count = {\n      tested: 0,\n      failed: 0,\n      skipped: totalCount - countBuilds(preArts),\n    }\n\n    const permute = (i: number) => {\n      if (i < 0) {\n        const result = compute(buffer)\n        if (min.every((m, i) => m <= result[i])) {\n          const value = result[min.length],\n            { builds, plotData } = this\n          let build: Build | undefined\n          if (value >= this.threshold) {\n            build = {\n              value,\n              artifactIds: buffer.map((x) => x.id).filter((id) => id),\n            }\n            builds.push(build)\n          }\n          if (plotData) {\n            const x = result[min.length + 1]\n            if (!plotData[x] || plotData[x]!.value < value) {\n              if (!build)\n                build = {\n                  value,\n                  artifactIds: buffer.map((x) => x.id).filter((id) => id),\n                }\n              build.plot = x\n              plotData[x] = build\n            }\n          }\n        } else count.failed += 1\n        return\n      }\n      arts[i].forEach((art) => {\n        buffer[i] = art\n        permute(i - 1)\n      })\n      if (i === 0) {\n        count.tested += arts[0].length\n        if (count.tested > 1 << 16) this.interimReport(count)\n      }\n    }\n\n    permute(arts.length - 1)\n    this.interimReport(count, this.builds.length > oldMaxBuildCount)\n  }\n\n  refresh(force: boolean): void {\n    const { topN } = this\n    if (Object.keys(this.plotData ?? {}).length >= 100000)\n      this.plotData = mergePlot([this.plotData!])\n\n    if (this.builds.length >= 1000 || force) {\n      this.builds = this.builds.sort((a, b) => b.value - a.value).slice(0, topN)\n      this.buildValues = this.builds.map((x) => x.value)\n      this.threshold = Math.max(\n        this.threshold,\n        this.buildValues[topN - 1] ?? -Infinity\n      )\n    }\n  }\n  interimReport(\n    count: { tested: number; failed: number; skipped: number },\n    forced = false\n  ) {\n    this.refresh(forced)\n    this.callback({\n      resultType: 'interim',\n      buildValues: this.buildValues,\n      ...count,\n    })\n    this.buildValues = undefined\n    count.tested = 0\n    count.failed = 0\n    count.skipped = 0\n  }\n}\n","import { allArtifactSlotKeys } from '@genshin-optimizer/consts'\nimport type { Interim, Setup } from '..'\nimport { assertUnreachable } from '../../Util/Util'\nimport type { ArtifactsBySlot, RequestFilter } from '../common'\nimport { countBuilds, filterArts } from '../common'\nimport type { SplitWorker } from './BackgroundWorker'\n\nexport class DefaultSplitWorker implements SplitWorker {\n  arts: ArtifactsBySlot\n  stack: { filter: RequestFilter; count: number; splittedBy: 'id' | 'set' }[] =\n    []\n\n  constructor({ arts }: Setup, _callback: (interim: Interim) => void) {\n    this.arts = arts\n  }\n\n  setThreshold(_newThreshold: number): void {}\n  add(\n    filter: RequestFilter,\n    splittedBy: (typeof this.stack)[number]['splittedBy']\n  ) {\n    this.stack.push({\n      filter,\n      count: countBuilds(filterArts(this.arts, filter)),\n      splittedBy,\n    })\n  }\n  *split(filter: RequestFilter, minCount: number): Generator<RequestFilter> {\n    this.add(filter, 'set')\n    for (let current = this.stack.pop(); current; current = this.stack.pop()) {\n      const { filter, count, splittedBy } = current\n      if (count <= minCount) {\n        yield filter\n        continue\n      }\n\n      switch (splittedBy) {\n        case 'set':\n          this.splitBySet(filter)\n          break\n        case 'id':\n          this.splitByID(filter, count, minCount)\n          break\n        default:\n          assertUnreachable(splittedBy)\n      }\n    }\n  }\n\n  splitBySet(filter: RequestFilter): void {\n    const arts = filterArts(this.arts, filter)\n    const candidates = allArtifactSlotKeys\n      .map((slot) => ({\n        slot,\n        sets: new Set(arts.values[slot].map((x) => x.set)),\n      }))\n      .filter(({ sets }) => sets.size > 1)\n\n    if (!candidates.length) return this.add(filter, 'id')\n\n    const { sets, slot } = candidates.reduce((a, b) =>\n      a.sets.size < b.sets.size ? a : b\n    )\n    sets.forEach((set) =>\n      this.add(\n        { ...filter, [slot]: { kind: 'required', sets: new Set([set]) } },\n        'set'\n      )\n    )\n  }\n  splitByID(filter: RequestFilter, count: number, minCount: number): void {\n    const arts = filterArts(this.arts, filter)\n    const { slot, length } = allArtifactSlotKeys\n      .map((slot) => ({ slot, length: arts.values[slot].length }))\n      .filter((x) => x.length > 1)\n      // We always have entries because `count > 1`\n      .reduce((a, b) => (a.length < b.length ? a : b))\n\n    const numChunks = Math.ceil(count / minCount)\n    const boundedNumChunks = Math.min(numChunks, length)\n    const chunk = Array(boundedNumChunks)\n      .fill(0)\n      .map((_) => new Set<string>())\n    arts.values[slot].forEach(({ id }, i) =>\n      chunk[i % boundedNumChunks].add(id)\n    )\n    chunk.forEach((ids) =>\n      this.add({ ...filter, [slot]: { kind: 'id', ids } }, 'id')\n    )\n  }\n}\n","import type { WorkerCommand, WorkerResult } from '..'\nimport { assertUnreachable } from '../../Util/Util'\nimport type { RequestFilter } from '../common'\nimport {\n  artSetPerm,\n  countBuilds,\n  filterArts,\n  filterFeasiblePerm,\n} from '../common'\nimport { BNBSplitWorker } from './BNBSplitWorker'\nimport { ComputeWorker } from './ComputeWorker'\nimport { DefaultSplitWorker } from './DefaultSplitWorker'\n\ndeclare function postMessage(command: WorkerCommand | WorkerResult): void\n\nlet splitWorker: SplitWorker, computeWorker: ComputeWorker\n\nasync function handleEvent(e: MessageEvent<WorkerCommand>): Promise<void> {\n  const { data } = e,\n    { command } = data\n  switch (command) {\n    case 'split':\n      for (const filter of splitWorker.split(\n        data.filter,\n        data.maxIterateSize\n      )) {\n        postMessage({ command: 'iterate', filter })\n        // Suspend here in case a `threshold` is sent over\n        //\n        // Make sure to use task-based mechanisms such as `setTimeout` so that\n        // this function suspends until the next event loop. If we instead use\n        // microtask-based ones such as `Promise.resolved`, the suspension will\n        // not be long enough.\n        await new Promise((r) => setTimeout(r))\n      }\n      break\n    case 'iterate':\n      computeWorker.compute(data.filter)\n      break\n    case 'threshold': {\n      splitWorker.setThreshold(data.threshold)\n      computeWorker.setThreshold(data.threshold)\n      return // This is a fire-and-forget command\n    }\n    case 'finalize': {\n      computeWorker.refresh(true)\n      const { builds, plotData } = computeWorker\n      postMessage({ resultType: 'finalize', builds, plotData })\n      break\n    }\n    case 'count': {\n      const { exclusion, maxIterateSize } = data,\n        arts = computeWorker.arts\n      const perms = filterFeasiblePerm(\n        artSetPerm(exclusion, [\n          ...new Set(\n            Object.values(arts.values).flatMap((x) => x.map((x) => x.set!))\n          ),\n        ]),\n        arts\n      )\n      let count = 0\n      for (const filter of perms) {\n        postMessage({ command: 'split', filter, maxIterateSize })\n        count += countBuilds(filterArts(arts, filter))\n      }\n      postMessage({ resultType: 'count', count })\n      break\n    }\n    case 'setup':\n      try {\n        splitWorker = new BNBSplitWorker(data, (x) => postMessage(x))\n      } catch {\n        splitWorker = new DefaultSplitWorker(data, (x) => postMessage(x))\n      }\n      computeWorker = new ComputeWorker(data, (x) => postMessage(x))\n      break\n    default:\n      assertUnreachable(command)\n  }\n  postMessage({ resultType: 'done' })\n}\nonmessage = async (e: MessageEvent<WorkerCommand>) => {\n  try {\n    await handleEvent(e)\n  } catch (e) {\n    postMessage({ resultType: 'err', message: (e as any).message })\n  }\n}\n\nexport interface SplitWorker {\n  split(filter: RequestFilter, minCount: number): Iterable<RequestFilter>\n  setThreshold(newThreshold: number): void\n}\n"],"names":["objPathValue","obj","keys","Array","isArray","console","error","reduce","a","k","objectKeyMap","map","Object","fromEntries","i","objectKeyValueMap","items","t","objectMap","fn","entries","v","rangeGen","from","to","range","assertUnreachable","value","Error","cartesian","q","b","flatMap","d","e","flat","constant","NaN","name","percent","info","operation","operands","type","Number","MAX_VALUE","Infinity","unit","intoOps","values","intoV","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","forEach","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","arrayEqual","set","result","customMapFormula","context","contextMapping","internalMap","current","mapping","old","newFormula","undefined","length","every","allCommutativeMonoidOperations","min","x","Math","max","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","flatten","f","_formula","flattened","dep","deduplicate","elementCounts","array","wrap","common","counts","next","factored","count","fill","candidatesByOperation","remainingCounts","filter","push","currentCounts","commonCounts","nextCounts","total","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","constantFold","topLevelData","shouldFold","origin","data","processed","nextContextMap","fold","c","foldStr","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","op","smallest","operand","v1","v2","match","unmatch","list","path","accu","reset","nextMap","nextContext","nonTravelerCharacterKeys","allTravelerKeys","allArtifactSlotKeys","allWeaponSwordKeys","allWeaponClaymoreKeys","allWeaponPolearmKeys","allWeaponBowKeys","allWeaponCatalystKeys","allSlotKeys","travelerKeys","pruneAll","nodes","minimum","arts","numTop","exclusion","forced","should","deps","pruneNodeRange","reaffine","pruneOrder","pruneArtRange","some","newArts","newNodes","forceRename","affineNodes","topLevelAffine","visit","node","isAffine","dynKeys","_","nonConst","base","size","nextDynKey","affine","affineMap","reaffineArt","stat","dyn","slot","id","offsets","key","baseValue","progress","allowRainbow","rainbow","noSwitchIn","noSwitchOut","includes","newList","art","other","otherBetterEqual","otherMaybeBetter","otherBetter","canSwitch","baseRange","artRanges","computeArtRange","otherArtRanges","addArtRange","read","newRange","computeNodeRange","nodeRange","operandRanges","newOperands","op1","op2","ranges","computeFullArtRange","reads","computeMinMax","sum","minMaxes","filterArts","filters","kind","ids","sets","countBuilds","_count","exclusionToAllowed","artSetPerm","_artSets","artSets","allowedRainbows","shapes","indexOfShape","shape","replacing","populateShapes","rainbows","j","required","slice","remaining","noFilter","allowedCounts","used","groupped","sort","usableRainbows","check_free","isolated","missing","rejected","allowedSet","requiredRainbows","l","constP","n","lin","$c","sumP","terms","poly","prodP","minMax","min1","max1","min2","max2","$k","slopePoint","slope","x0","y0","interpolate","x1","y1","upper","abs","polyUB","statMinMax","nodeRanges","lower","exact","_map","oppositeContext","minmax","minf","maxf","zeroCrossing","signf","polys","ctx","p","PolyError","xs","xOp","cOp","loc","sqrt","vOp","tOp","pOp","fOp","threshOp","ge","le","mulOp","prod","thresh","isFirstHalf","toExpandedPoly","constM","weightedReadM","monomials","sumM","monos","ret","nxt","prodM","mon","m","termsA","termsB","splice","ai","foldLikeTerms","expandPoly","constructor","cause","super","zero","solveLP","Ab","rows","cols","tableau","Ai","Aij","cj","pivotHistory","piv","findPiv2","pivotInplace","findPiv1","xOpt","targ","side","ncol","backtrack","row","tot","xi","isFeasible","A","h","r","minloc","cmp","linearUB","weight","entry","weightedSum","bounds","w","direction","err","nVar","boundScale","scaleProd","cons","coords","objective","soln","wi","log","linbound","linboi","BNBSplitWorker","optTarget","constraints","topN","callback","interim","firstUncalculated","this","addFilter","maxConts","approxs","age","setThreshold","newThreshold","calculated","minCount","getApproxFilter","calculateFilter","reportInterim","splitOldFilter","skipped","splitted","cont","conts","c1","c2","minCont","contCutoff","findIndex","lowArts","highArts","high","approx","maxContribution","low","currentCont","partialSplit","val","currentArts","pop","oldCount","dot","approximation","leadingConts","newValues","requiredConts","lc","newCount","resultType","buildValues","tested","failed","ComputeWorker","plotBase","builds","plotData","opts","optimize","compute","preArts","totalCount","oldMaxBuildCount","initial","binding","slotCount","body","names","operandNames","arr","toString","join","Function","precompute","buffer","permute","build","artifactIds","plot","interimReport","refresh","force","plots","scale","round","mergePlot","DefaultSplitWorker","_callback","stack","_newThreshold","splittedBy","splitBySet","splitByID","numChunks","ceil","boundedNumChunks","chunk","splitWorker","computeWorker","async","handleEvent","command","split","maxIterateSize","postMessage","Promise","setTimeout","perms","filter_loop","available","s","filterFeasiblePerm","onmessage","message"],"sourceRoot":""}