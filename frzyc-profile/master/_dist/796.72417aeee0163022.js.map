{"version":3,"file":"796.72417aeee0163022.js","mappings":"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EnCrE,EACP,CAAE8B,UAAWuB,EAAQZ,KAAMV,YAG3BsC,GAEJ,KACF,CACA,IAAK,OAAQ,CACPhB,EAAQoG,QAAOpF,EAAU2D,GAC7B,MAAM0B,EAAUvB,EAAenE,IAAIK,GACnC,IAAIsF,EAAcD,EAAQ1F,IAAIX,EAAQ4E,MACjC0B,IACHA,EAAc,CACZ1B,KAAM,IAAI5D,EAAQ4D,KAAM5E,EAAQ4E,MAChCC,UAAW,IAAIrE,KAEjBsE,EAAejE,IAAIyF,EAAa,IAAI9F,KACpC6F,EAAQxF,IAAIb,EAAQ4E,KAAM0B,IAE5BxF,EAASnE,EAAIqD,EAAQtB,SAAS,GAAI4H,GAClC,KACF,CACA,QACE5I,EAAkBe,GAOtB,OAJIqC,EAAOtC,OACTsC,EAAS,OAAH,UAAQA,UACPA,EAAOtC,MAETsC,CAAM,GAGnB,CAEO,MCndMyF,EAA2B,CACtC,SACA,YACA,OACA,QACA,cACA,UACA,SACA,UACA,UACA,WACA,SACA,OACA,QACA,QACA,QACA,OACA,OACA,UACA,SACA,QACA,QACA,QACA,OACA,kBACA,QACA,gBACA,gBACA,SACA,OACA,YACA,cACA,QACA,OACA,OACA,OACA,SACA,QACA,YACA,SACA,OACA,eACA,QACA,UACA,oBACA,OACA,SACA,kBACA,SACA,UACA,YACA,QACA,WACA,QACA,WACA,YACA,OACA,UACA,SACA,UACA,SACA,SACA,QACA,UACA,SACA,WAGWC,EAAkB,CAC7B,gBACA,cACA,kBACA,kBChHK,MAAMC,EAAqB,CAChC,aACA,eACA,YACA,kBACA,uBACA,aACA,uBACA,mBACA,gBACA,0BACA,qBACA,sBACA,uBACA,UACA,eACA,mBACA,eACA,sBACA,aACA,aACA,WACA,gBACA,gBACA,iBACA,cACA,gBACA,YACA,oBACA,yBACA,mBACA,sBACA,wBACA,kBACA,UACA,yBACA,yBACA,WACA,iBACA,iBACA,cACA,kBACA,sBACA,qBACA,kBACA,mBAIWC,EAAsB,CACjC,SACA,QACA,QACA,SACA,WC7CWC,EAAqB,CAChC,kBACA,gBACA,sBACA,kBACA,YACA,oBACA,gBACA,YACA,gBACA,kBACA,cACA,eACA,oBACA,kBACA,YACA,iBACA,wBACA,YACA,uBACA,uBACA,mBACA,iBACA,mBACA,eACA,cACA,gBACA,eACA,eACA,oBACA,gBACA,gBACA,WACA,kBACA,sBACA,mBAIWC,EAAwB,CACnC,YACA,qBACA,oBACA,yBACA,aACA,qBACA,gBACA,gBACA,wBACA,cACA,mBACA,eACA,qBACA,cACA,mBACA,cACA,uBACA,kBACA,wBACA,eACA,qBACA,eACA,uBACA,oBACA,UACA,cACA,mBACA,aACA,sBACA,mBAIWC,EAAuB,CAClC,qBACA,iBACA,cACA,kBACA,eACA,aACA,cACA,mBACA,qBACA,gBACA,UACA,YACA,mBACA,cACA,mBACA,cACA,4BACA,uBACA,aACA,eACA,cACA,yBACA,WACA,mBACA,kBACA,eAIWC,EAAmB,CAC9B,cACA,UACA,gBACA,mBACA,cACA,iBACA,eACA,iBACA,iBACA,WACA,aACA,cACA,cACA,YACA,oBACA,aACA,YACA,WACA,oBACA,WACA,aACA,WACA,OACA,iBACA,qBACA,oBACA,cACA,YACA,gBACA,qBACA,kBACA,gBAIWC,EAAwB,CACnC,mBACA,0BACA,kBACA,cACA,aACA,sBACA,kBACA,gBACA,cACA,qBACA,eACA,gBACA,6BACA,aACA,YACA,eACA,eACA,oBACA,iBACA,iBACA,kBACA,gBACA,uBACA,eACA,aACA,aACA,gCACA,0BACA,eACA,oBACA,eC3JWC,EAAc,CACzB,SACA,QACA,QACA,SACA,WA0EWC,EAAe,CAC1B,gBACA,cACA,kBACA,kBC9FK,SAASC,EACdC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIC,EAASD,EAEb,MAAME,EACQ,CAAEC,gBAAgB,GAD1BD,EAEW,CAAEC,gBAAgB,GAF7BD,EAGY,CAAEE,UAAU,GAHxBF,EAIM,CAAEG,YAAY,EAAMC,eAAe,EAAMH,gBAAgB,GAErE,IAAII,EAAQ,EACZ,KAAOnL,OAAOqC,OAAOwI,GAAQO,MAAM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","sources":["webpack:///./src/app/Util/Util.ts","webpack:///./src/app/Formula/utils.ts","webpack:///./src/app/Formula/internal.ts","webpack:///./src/app/Formula/optimization.ts","webpack:///../../libs/consts/src/character.ts","webpack:///../../libs/consts/src/artifact.ts","webpack:///../../libs/consts/src/weapon.ts","webpack:///./src/app/Types/consts.ts","webpack:///./src/app/Solver/common.ts","webpack:///./src/app/Solver/GOSolver/polyUB.ts","webpack:///./src/app/Solver/GOSolver/solveLP.ts","webpack:///./src/app/Solver/GOSolver/linearUB.ts","webpack:///./src/app/Solver/GOSolver/heuristicSplitting.ts","webpack:///./src/app/Solver/GOSolver/BNBSplitWorker.ts","webpack:///./src/app/Solver/GOSolver/ComputeWorker.ts","webpack:///./src/app/Solver/GOSolver/DefaultSplitWorker.ts","webpack:///./src/app/Solver/GOSolver/BackgroundWorker.ts"],"sourcesContent":["export const getRandomElementFromArray = <T>(array: readonly T[]): T =>\n  array[Math.floor(Math.random() * array.length)]\nexport function getRandomInt(min, max) {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  return Math.floor(Math.random() * (max - min) + min) //The maximum is exclusive and the minimum is inclusive\n}\nexport function getRandomIntInclusive(min, max) {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  return Math.floor(Math.random() * (max - min + 1) + min) //The maximum is inclusive and the minimum is inclusive\n}\nexport function getRandomArbitrary(min, max) {\n  return Math.random() * (max - min) + min\n}\n\n/**\n * Assumes that the object entries are all primitives + objects\n * shallow copy the object,\n * deep copy the\n * @param obj\n * @returns\n */\nexport function deepClone<T>(obj: T): T {\n  if (!obj) return obj\n  if (!Object.keys(obj).length) return {} as T\n  const ret = { ...obj }\n  Object.entries(obj).forEach(([k, v]: any) => {\n    if (typeof v !== 'object') return\n    ret[k] = JSON.parse(JSON.stringify(v))\n  })\n  return ret\n}\n\nexport const clamp = (val, low, high) => {\n  if (val < low) return low\n  if (val > high) return high\n  return val\n}\nexport const getArrLastElement = (arr) =>\n  arr.length ? arr[arr.length - 1] : null\n\nexport const clamp01 = (val) => clamp(val, 0, 1)\nexport const clampPercent = (val) => clamp(val, 0, 100)\n\n//use to pretty print timestamps, or anything really.\nexport function strPadLeft(string, pad, length) {\n  return (new Array(length + 1).join(pad) + string).slice(-length)\n}\n\n//fuzzy compare strings. longer the distance, the higher the mismatch.\nexport function hammingDistance(str1, str2) {\n  let dist = 0\n  str1 = str1.toLowerCase()\n  str2 = str2.toLowerCase()\n  for (let i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\n    let match = true\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i]) match = false\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i]) match = true\n    if (!match) dist++\n  }\n  return dist\n}\n\n//multiplies every numerical value in the obj by a multiplier.\nexport function objMultiplication(obj, multi) {\n  if (multi === 1) return obj\n  Object.keys(obj).forEach((prop: any) => {\n    if (typeof obj[prop] === 'object') objMultiplication(obj[prop], multi)\n    if (typeof obj[prop] === 'number') obj[prop] = obj[prop] * multi\n  })\n  return obj\n}\n\n//assign obj.[keys...] = value\nexport function layeredAssignment(obj, keys: readonly string[], value) {\n  keys.reduce((accu, key, i, arr) => {\n    if (i === arr.length - 1) return (accu[key] = value)\n    if (!accu[key]) accu[key] = {}\n    return accu[key]\n  }, obj)\n  return obj\n}\n//get the value in a nested object, giving array of path\nexport function objPathValue(\n  obj: object | undefined,\n  keys: readonly string[]\n): any {\n  if (!obj || !keys) return undefined\n  !Array.isArray(keys) && console.error(keys)\n  return keys.reduce((a, k) => a?.[k], obj)\n}\n//delete the value denoted by the path. Will also delete empty objects as well.\nexport function deletePropPath(obj, path) {\n  const tempPath = [...path]\n  const lastKey = tempPath.pop()\n  const objPathed = objPathValue(obj, tempPath)\n  delete objPathed?.[lastKey]\n}\n\nexport function objClearEmpties(o) {\n  for (const k in o) {\n    if (typeof o[k] !== 'object') continue\n    objClearEmpties(o[k])\n    if (!Object.keys(o[k]).length) delete o[k]\n  }\n}\nexport function crawlObject(\n  obj: any,\n  keys: string[] = [],\n  validate: (o: any, keys: string[]) => boolean,\n  cb: (o: any, keys: string[]) => void\n) {\n  if (validate(obj, keys)) cb(obj, keys)\n  else\n    obj &&\n      typeof obj === 'object' &&\n      Object.entries(obj).forEach(([key, val]) =>\n        crawlObject(val, [...keys, key], validate, cb)\n      )\n}\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\nexport const getObjectKeysRecursive = (obj) =>\n  typeof obj === 'object'\n    ? Object.values(obj)\n        .flatMap(getObjectKeysRecursive)\n        .concat(Object.keys(obj))\n    : typeof obj === 'string'\n    ? [obj]\n    : []\n\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\n  return typeof value === 'function' ? (value as any)(arg) : value\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyMap<K extends string | number, V>(\n  keys: readonly K[],\n  map: (key: K, i: number) => V\n): StrictDict<`${K}`, V> {\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyValueMap<T, K extends string | number, V>(\n  items: readonly T[],\n  map: (item: T, i: number) => [K, V]\n): StrictDict<`${K}`, V> {\n  return Object.fromEntries(items.map((t, i) => map(t, i))) as any\n}\n\nexport function objectMap<K extends string, V, T>(\n  obj: Record<K, Exclude<V, undefined>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Record<K, T>\nexport function objectMap<K extends string, V, T>(\n  obj: Partial<Record<K, V>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Partial<Record<K, T>>\nexport function objectMap<K extends string, V, T>(\n  obj: Partial<Record<K, V>>,\n  fn: (value: V, key: `${K}`, index: number) => T\n): Partial<Record<K, T>> {\n  return Object.fromEntries(\n    Object.entries(obj).map(([k, v], i) => [k, fn(v, k, i)])\n  ) as any\n}\n\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\n  for (let i = from; i <= to; i++) yield i\n}\n\n/** range of [from, to], inclusive */\nexport function range(from: number, to: number): number[] {\n  return [...rangeGen(from, to)]\n}\n\nexport function assertUnreachable(value: never): never {\n  throw new Error(`Should not reach this with value ${value}`)\n}\n\n// cartesian product of list of arrays\nexport function cartesian<T>(...q: T[][]): T[][] {\n  return q.reduce((a, b) => a.flatMap((d) => b.map((e) => [d, [e]].flat())), [\n    [],\n  ] as T[][])\n}\n\n/** Will change `arr` in-place */\nexport function toggleInArr<T>(arr: T[], value: T) {\n  const ind = arr.indexOf(value)\n  if (ind < 0) arr.push(value)\n  else arr.splice(ind, 1)\n  return arr\n}\n\nexport function toggleArr<T>(arr: T[], value: T) {\n  return arr.includes(value) ? arr.filter((a) => a !== value) : [...arr, value]\n}\n\nexport function deepFreeze<T>(obj: T, layers = 5): T {\n  if (layers === 0) return obj\n  if (typeof obj === 'object')\n    Object.values(Object.freeze(obj)).forEach((o) => deepFreeze(o, layers--))\n  return obj\n}\n\nexport function arrayMove<T>(arr: T[], oldIndex: number, newIndex: number) {\n  if (newIndex < 0 || newIndex >= arr.length) return arr\n  if (oldIndex < 0 || oldIndex >= arr.length) return arr\n  arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0])\n  return arr\n}\n","import { objectKeyMap } from '../Util/Util'\nimport type { OptNode } from './optimization'\nimport type {\n  ComputeNode,\n  ConstantNode,\n  Data,\n  DataNode,\n  Info,\n  LookupNode,\n  MatchNode,\n  NumNode,\n  ReadNode,\n  StrNode,\n  StrPrioNode,\n  SubscriptNode,\n  ThresholdNode,\n} from './type'\n\ntype Opt = number | OptNode\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype N_S = Num | Str\ntype AnyNode = NumNode | StrNode\n\nexport const todo: OptNode = constant(NaN, { name: 'TODO' })\nexport const one = percent(1),\n  naught = percent(0)\nexport const none = constant('none')\n\nexport function constant(value: number, info?: Info): ConstantNode<number>\nexport function constant(\n  value: string | undefined,\n  info?: Info\n): ConstantNode<string | undefined>\nexport function constant(\n  value: number | string | undefined,\n  info?: Info\n): ConstantNode<number> | ConstantNode<string | undefined>\nexport function constant(\n  value: number | string | undefined,\n  info?: Info\n): ConstantNode<number | string | undefined> {\n  return typeof value === 'number'\n    ? { operation: 'const', operands: [], type: 'number', value, info }\n    : { operation: 'const', operands: [], type: 'string', value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): ConstantNode<number> {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { unit: '%', ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: OptNode, info: Info): OptNode\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: AnyNode, info: Info): AnyNode\nexport function infoMut(node: AnyNode, info: Info): AnyNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, NumNode>,\n  defaultV: Num | 'none',\n  info?: Info\n): LookupNode<NumNode>\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, StrNode>,\n  defaultV: Str | 'none',\n  info?: Info\n): LookupNode<StrNode>\nexport function lookup(\n  index: StrNode,\n  table: Dict<string, AnyNode>,\n  defaultV: N_S | 'none',\n  info?: Info\n): LookupNode<AnyNode> {\n  return {\n    operation: 'lookup',\n    operands:\n      defaultV !== 'none' ? [intoV(index), intoV(defaultV)] : [intoV(index)],\n    table,\n    info,\n  }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function min(...values: Num[]): ComputeNode\nexport function min(...values: Num[]): ComputeNode {\n  return { operation: 'min', operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function max(...values: Num[]): ComputeNode\nexport function max(...values: Num[]): ComputeNode {\n  return { operation: 'max', operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function sum(...values: Num[]): ComputeNode\nexport function sum(...values: Num[]): ComputeNode {\n  return { operation: 'add', operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function prod(...values: Num[]): ComputeNode\nexport function prod(...values: Num[]): ComputeNode {\n  return { operation: 'mul', operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Opt, c: Opt): ComputeNode<OptNode, OptNode>\nexport function frac(x: Num, c: Num): ComputeNode\nexport function frac(x: Num, c: Num): ComputeNode {\n  return { operation: 'sum_frac', operands: intoOps([x, c]) }\n}\nexport function res(base: Opt): ComputeNode<OptNode, OptNode>\nexport function res(base: Num): ComputeNode\nexport function res(base: Num): ComputeNode {\n  return { operation: 'res', operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? eq : neq */\nexport function compareEq(\n  v1: Num,\n  v2: Num,\n  eq: Num,\n  neq: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function compareEq(\n  v1: Num,\n  v2: Num,\n  eq: Str,\n  neq: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function compareEq(\n  v1: Str,\n  v2: Str,\n  eq: Num,\n  neq: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function compareEq(\n  v1: Str,\n  v2: Str,\n  eq: Str,\n  neq: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function compareEq(\n  v1: N_S,\n  v2: N_S,\n  eq: N_S,\n  neq: N_S,\n  info?: Info\n): MatchNode<AnyNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(eq), intoV(neq)],\n    info,\n  }\n}\n/** v1 == v2 ? pass : 0 */\nexport function equal(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function equal(\n  v1: Str,\n  v2: Str,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function equal(\n  v1: N_S,\n  v2: N_S,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(0)],\n    emptyOn: 'unmatch',\n  }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function equalStr(\n  v1: Str,\n  v2: Str,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function equalStr(\n  v1: N_S,\n  v2: N_S,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(undefined)],\n    emptyOn: 'unmatch',\n  }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function unequal(\n  v1: Str,\n  v2: Str,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode>\nexport function unequal(\n  v1: N_S,\n  v2: N_S,\n  pass: Num,\n  info?: Info\n): MatchNode<NumNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(0), intoVInfo(pass, info)],\n    emptyOn: 'match',\n  }\n}\n/** v1 != v2 ? pass : `undefined` */\nexport function unequalStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function unequalStr(\n  v1: Str,\n  v2: Str,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode>\nexport function unequalStr(\n  v1: N_S,\n  v2: N_S,\n  pass: Str,\n  info?: Info\n): MatchNode<StrNode> {\n  return {\n    operation: 'match',\n    operands: [intoV(v1), intoV(v2), intoV(undefined), intoVInfo(pass, info)],\n    emptyOn: 'match',\n  }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(\n  v1: Opt,\n  v2: Opt,\n  pass: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function greaterEq(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function greaterEq(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(0)],\n    emptyOn: 'l',\n  }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(\n  v1: Num,\n  v2: Num,\n  pass: Str,\n  info?: Info\n): ThresholdNode<StrNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(undefined)],\n    emptyOn: 'l',\n  }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(\n  v1: Opt,\n  v2: Opt,\n  pass: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function lessThan(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function lessThan(\n  v1: Num,\n  v2: Num,\n  pass: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoV(0), intoVInfo(pass, info)],\n    emptyOn: 'ge',\n  }\n}\n/** v1 >= v2 ? ge : le */\nexport function threshold(\n  v1: Opt,\n  v2: Opt,\n  ge: Opt,\n  le: Opt,\n  info?: Info\n): ThresholdNode<OptNode, OptNode, OptNode>\nexport function threshold(\n  v1: Num,\n  v2: Num,\n  ge: Num,\n  le: Num,\n  info?: Info\n): ThresholdNode<NumNode>\nexport function threshold(\n  v1: Num,\n  v2: Num,\n  ge: Num,\n  le: Num,\n  info?: Info\n): ThresholdNode<NumNode> {\n  return {\n    operation: 'threshold',\n    operands: [intoV(v1), intoV(v2), intoV(ge), intoV(le)],\n    info,\n  }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(\n  nodeList: T,\n  prefix: string[] = []\n): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== 'read')\n      throw new Error(\n        `Found ${(nodeList as any).operation} node while making reader`\n      )\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), (key) =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])\n    ) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(\n  base: AnyNode,\n  data: Data\n): DataNode<NumNode> | DataNode<StrNode>\nexport function data(\n  base: AnyNode,\n  data: Data\n): DataNode<NumNode> | DataNode<StrNode> {\n  return { operation: 'data', operands: [base as any], data }\n}\nexport function resetData(\n  base: NumNode,\n  data: Data,\n  info?: Info\n): DataNode<NumNode>\nexport function resetData(\n  base: StrNode,\n  data: Data,\n  info?: Info\n): DataNode<StrNode>\nexport function resetData(\n  base: AnyNode,\n  data: Data,\n  info?: Info\n): DataNode<AnyNode>\nexport function resetData(\n  base: AnyNode,\n  data: Data,\n  info?: Info\n): DataNode<AnyNode> {\n  return { operation: 'data', operands: [base], data, reset: true, info }\n}\n\nexport function dynRead(\n  name: string,\n  accu: ReadNode<number>['accu'] = 'add',\n  info?: Info\n): ReadNode<number> {\n  return {\n    operation: 'read',\n    operands: [],\n    path: ['dyn', name],\n    accu,\n    type: 'number',\n    info,\n  }\n}\nexport function customRead(\n  path: readonly string[],\n  info?: Info\n): ReadNode<number> {\n  return { operation: 'read', operands: [], path, info, type: 'number' }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: 'read', operands: [], path, type: 'string' }\n}\nexport function read(\n  accu?: ReadNode<number>['accu'],\n  info?: Info\n): ReadNode<number> {\n  return {\n    operation: 'read',\n    operands: [],\n    path: [],\n    accu,\n    info,\n    type: 'number',\n  }\n}\n/**\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\n */\nexport function stringRead(\n  accu?: ReadNode<string | undefined>['accu']\n): ReadNode<string | undefined> {\n  return { operation: 'read', operands: [], path: [], accu, type: 'string' }\n}\nexport function stringPrio(...operands: Str[]): StrPrioNode {\n  return { operation: 'prio', operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(\n  index: NumNode,\n  list: V[],\n  info?: Info\n): SubscriptNode<V> {\n  return { operation: 'subscript', operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: N_S[]): AnyNode[] {\n  return values.map((value) =>\n    typeof value === 'object' ? value : constant(value)\n  )\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: N_S): AnyNode\nfunction intoV(value: N_S): AnyNode {\n  return typeof value !== 'object' ? constant(value) : value\n}\nfunction intoVInfo(value: Num, info: Info | undefined): NumNode\nfunction intoVInfo(value: Str, info: Info | undefined): StrNode\nfunction intoVInfo(value: N_S, info: Info | undefined): AnyNode\nfunction intoVInfo(value: N_S, info: Info | undefined): AnyNode {\n  if (!info) return intoV(value)\n  return typeof value !== 'object'\n    ? constant(value, info)\n    : infoMut({ ...value }, info)\n}\n\ntype _NodeList = { [key: string]: NodeList } & { operation?: never }\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n","import type { AnyNode, Base, NodeData, NumNode, StrNode } from './type'\nimport { constant } from './utils'\n\nexport function deepNodeClone<\n  T extends NodeData<NumNode | StrNode | undefined>\n>(data: T): T {\n  const map = new Map()\n  function internal(orig: any) {\n    if (typeof orig !== 'object') return orig\n    const old = map.get(orig)\n    if (old) return old\n\n    const cache: any = Array.isArray(orig)\n      ? orig.map((val) => internal(val))\n      : Object.fromEntries(\n          Object.entries(orig).map(([key, val]) => [\n            key,\n            key === 'info' ? val : internal(val),\n          ])\n        )\n    map.set(orig, cache)\n    return cache\n  }\n  return internal(data)\n}\n\nexport function forEachNodes<T extends Base<T> = AnyNode>(\n  formulas: T[],\n  topDown: (formula: T) => void,\n  bottomUp: (formula: T) => void\n): void {\n  const visiting = new Set<T>(),\n    visited = new Set<T>()\n\n  function traverse(formula: T) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error('Found cyclical dependency during formula traversal')\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas<\n  Input extends Base<Input> = AnyNode,\n  Interim extends Base<Interim> = Input,\n  Output extends Base<Output> = Interim\n>(\n  formulas: Input[],\n  topDownMap: (formula: Input | Interim) => Interim,\n  bottomUpMap: (current: Interim | Output, orig: Input | Interim) => Output\n): Output[] {\n  const visiting = new Set<Input | Interim>()\n  const topDownMapped = new Map<Input | Interim, Output>()\n  const bottomUpMapped = new Map<Interim, Output>()\n\n  function check(formula: Input | Interim): Output {\n    let topDown: Interim | Output | undefined = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error('Found cyclical dependency during formula mapping')\n      return constant(NaN) as any\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: Interim): Interim | Output {\n    const operands = formula.operands.map(check)\n    return arrayEqual<Interim | Output>(operands, formula.operands)\n      ? formula\n      : { ...formula, operands }\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual<Input | Output>(result, formulas)\n    ? (formulas as any)\n    : result\n}\n\nexport function customMapFormula<Context, Output, Input extends Base<Input>>(\n  formulas: Input[],\n  context: Context,\n  map: (\n    formula: Input,\n    context: Context,\n    map: (node: Input, context: Context) => Output\n  ) => Output\n): Output[] {\n  const contextMapping = new Map<Context, [Set<Input>, Map<Input, Output>]>()\n  function internalMap(formula: Input, context: Context): Output {\n    let current = contextMapping.get(context)\n    if (!current)\n      contextMapping.set(context, (current = [new Set(), new Map()]))\n    const [visiting, mapping] = current\n\n    const old = mapping.get(formula)\n    if (old) return old\n\n    if (visiting.has(formula))\n      throw new Error('Found cyclical dependency during formula mapping')\n\n    visiting.add(formula)\n    const newFormula = map(formula, context, internalMap)\n    mapping.set(formula, newFormula)\n    visiting.delete(formula)\n\n    return newFormula\n  }\n  return formulas.map((formula) => internalMap(formula, context))\n}\n\nfunction arrayEqual<T>(\n  a: readonly T[] | undefined,\n  b: readonly T[] | undefined\n): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import type { ArtifactBuildData } from '../Solver/common'\nimport { assertUnreachable, objPathValue } from '../Util/Util'\nimport { customMapFormula, forEachNodes, mapFormulas } from './internal'\nimport type {\n  AnyNode,\n  CommutativeMonoidOperation,\n  ComputeNode,\n  ConstantNode,\n  Data,\n  NumNode,\n  Operation,\n  ReadNode,\n  StrNode,\n  StrPrioNode,\n  ThresholdNode,\n} from './type'\nimport { constant } from './utils'\n\nexport type OptNode =\n  | ComputeNode<OptNode, OptNode>\n  | ThresholdNode<OptNode, OptNode, OptNode>\n  | ReadNode<number>\n  | ConstantNode<number>\n\nconst allCommutativeMonoidOperations: StrictDict<\n  CommutativeMonoidOperation,\n  (_: number[]) => number\n> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<\n  Operation | 'threshold',\n  (_: number[]) => number\n> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number =>\n    value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(\n  Object.keys(allCommutativeMonoidOperations) as NumNode['operation'][]\n)\n\nexport function optimize(\n  formulas: NumNode[],\n  topLevelData: Data,\n  shouldFold = (_formula: ReadNode<number | string | undefined>) => false\n): OptNode[] {\n  let opts = constantFold(formulas, topLevelData, shouldFold)\n  opts = flatten(opts)\n  opts = constantFold(opts, {})\n  return deduplicate(opts)\n}\nexport function precompute(\n  formulas: OptNode[],\n  initial: ArtifactBuildData['values'],\n  binding: (\n    readNode: ReadNode<number> | ReadNode<string | undefined>\n  ) => string,\n  slotCount: number\n): (_: ArtifactBuildData[]) => number[] {\n  let body = `\n\"use strict\";\n// copied from the code above\nfunction res(res) {\n  if (res < 0) return 1 - res / 2\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\n  return 1 - res\n}\nconst x0=0` // making sure `const` has at least one entry\n\n  let i = 1\n  const names = new Map<NumNode | StrNode, string>()\n  forEachNodes(\n    formulas,\n    (_) => {},\n    (f) => {\n      const { operation, operands } = f,\n        name = `x${i++}`,\n        operandNames = operands.map((x: OptNode) => names.get(x)!)\n      names.set(f, name)\n      switch (operation) {\n        case 'read': {\n          const key = binding(f)\n          let arr = new Array(slotCount)\n            .fill(null)\n            .map((x, i) => `(b[${i}].values[\"${key}\"] ?? 0)`)\n          if (initial[key] && initial[key] !== 0) {\n            arr = [initial[key].toString(), ...arr]\n          }\n          body += `,${name}=${arr.join('+')}`\n          break\n        }\n        case 'const':\n          names.set(f, `(${f.value})`)\n          break\n        case 'add':\n        case 'mul':\n          body += `,${name}=${operandNames.join(\n            operation === 'add' ? '+' : '*'\n          )}`\n          break\n        case 'min':\n        case 'max':\n          body += `,${name}=Math.${operation}(${operandNames})`\n          break\n        case 'threshold': {\n          const [value, threshold, pass, fail] = operandNames\n          body += `,${name}=(${value}>=${threshold})?${pass}:${fail}`\n          break\n        }\n        case 'res':\n          body += `,${name}=res(${operandNames[0]})`\n          break\n        case 'sum_frac':\n          body += `,${name}=${operandNames[0]}/(${operandNames[0]}+${operandNames[1]})`\n          break\n\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n  body += `;\\nreturn [${formulas.map((f) => names.get(f)!)}]`\n  return new (Function as any)(`b`, body)\n}\n\nfunction flatten(formulas: OptNode[]): OptNode[] {\n  return mapFormulas(\n    formulas,\n    (f) => f,\n    (_formula) => {\n      let result = _formula\n      if (commutativeMonoidOperationSet.has(_formula.operation as Operation)) {\n        const formula = _formula as ComputeNode<OptNode>\n        const { operation } = formula\n\n        let flattened = false\n        const operands = formula.operands.flatMap((dep) =>\n          dep.operation === operation\n            ? ((flattened = true), dep.operands)\n            : [dep]\n        )\n        result = flattened ? { ...formula, operands } : formula\n      }\n\n      return result\n    }\n  )\n}\n\nfunction arrayCompare<T>(\n  a: readonly T[],\n  b: readonly T[],\n  cmp: (a: T, b: T) => number\n): number {\n  if (a.length !== b.length) return a.length - b.length\n  for (let i = 0; i < a.length; i++) {\n    const cc = cmp(a[i], b[i])\n    if (cc !== 0) return cc\n  }\n  return 0\n}\n/**\n * Converts `formulas` to a unique normal form via sorting. Commutative operations are\n * also sorted to enforce unique operand ordering. As a consequence, duplicated nodes\n * become easy to find, so we combine identical nodes into the same reference. The\n * sort follows the below fields sequentially:\n *  ```\n *    node height  - height of subtree; distance to furthest leaf.\n *    node type    - Ordering is [const, read, add, mul, min, max, sum_frac, threshold, res]\n *    When types are same:\n *      const:             n.value\n *      read:              alphabetical on path\n *      add/mul/min/max:   sort the operands, then compare sequentially\n *      frac/thresh/res:   compare operands sequentially\n *  ```\n *\n * Sorting is efficient because sorting by ascending height first lets us memoize the\n * ordering of all the children and find a bijection with the natual numbers.\n */\nfunction deduplicate(formulas: OptNode[]): OptNode[] {\n  const nodeHeightMap = new Map<OptNode, number>()\n  const layers = [[]] as OptNode[][]\n  forEachNodes(\n    formulas,\n    (_) => {},\n    (n) => {\n      switch (n.operation) {\n        case 'const':\n        case 'read':\n          layers[0].push(n)\n          nodeHeightMap.set(n, 0)\n          break\n        default: {\n          const h =\n            Math.max(...n.operands.map((op) => nodeHeightMap.get(op)!)) + 1\n          if (layers.length <= h) layers.push([])\n          layers[h].push(n)\n          nodeHeightMap.set(n, h)\n          break\n        }\n      }\n    }\n  )\n\n  function cmpNode(n1: OptNode, n2: OptNode): number {\n    const h1 = nodeHeightMap.get(n1)!,\n      h2 = nodeHeightMap.get(n2)!\n    if (h1 !== h2) return h1 - h2\n    const op1 = n1.operation,\n      op2 = n2.operation\n    if (op1 !== op2) return op1.localeCompare(op2)\n\n    switch (op1) {\n      case 'const':\n        if (op1 !== op2) throw Error('ily jslint')\n        return n1.value - n2.value\n      case 'read':\n        if (op1 !== op2) throw Error('ily jslint')\n        return arrayCompare(n1.path, n2.path, (s1, s2) => s1.localeCompare(s2))\n      case 'res':\n      case 'threshold':\n      case 'sum_frac': {\n        if (op1 !== op2) throw Error('ily jslint')\n        const s1 = n1.operands.map((op) => nodeSortMap.get(op)!),\n          s2 = n2.operands.map((op) => nodeSortMap.get(op)!)\n        return arrayCompare(s1, s2, (n1, n2) => n1 - n2)\n      }\n      case 'add':\n      case 'mul':\n      case 'min':\n      case 'max': {\n        if (op1 !== op2) throw Error('ily jslint')\n        const s1 = n1.operands.map((op) => nodeSortMap.get(op)!),\n          s2 = n2.operands.map((op) => nodeSortMap.get(op)!)\n        s1.sort((a, b) => a - b)\n        s2.sort((a, b) => a - b)\n        return arrayCompare(s1, s2, (n1, n2) => n1 - n2)\n      }\n    }\n  }\n\n  let ix = 0\n  const nodeSortMap = new Map<OptNode, number>()\n  const sortedNodes = [] as OptNode[]\n  layers.forEach((layer) => {\n    layer.sort(cmpNode)\n    sortedNodes.push(layer[0])\n    nodeSortMap.set(layer[0], ix++)\n    for (let i = 1; i < layer.length; i++) {\n      if (cmpNode(layer[i - 1], layer[i]) === 0)\n        nodeSortMap.set(layer[i], nodeSortMap.get(layer[i - 1])!)\n      else {\n        sortedNodes.push(layer[i])\n        nodeSortMap.set(layer[i], ix++)\n      }\n    }\n  })\n\n  sortedNodes.forEach((n, i) => {\n    switch (n.operation) {\n      case 'add':\n      case 'mul':\n      case 'min':\n      case 'max':\n        sortedNodes[i] = {\n          ...n,\n          operands: [...n.operands].sort(\n            (a, b) => nodeSortMap.get(a)! - nodeSortMap.get(b)!\n          ),\n        }\n    }\n  })\n\n  return mapFormulas(\n    formulas,\n    (f) => sortedNodes[nodeSortMap.get(f)!],\n    (_) => _\n  )\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(\n  formulas: NumNode[],\n  topLevelData: Data,\n  shouldFold = (_formula: ReadNode<number | string | undefined>) => false\n): OptNode[] {\n  type Context = {\n    data: Data[]\n    processed: Map<NumNode | StrNode, OptNode | StrNode>\n  }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return customMapFormula<typeof context, OptNode | StrNode, AnyNode>(\n    formulas,\n    context,\n    (formula, context, map) => {\n      const { operation } = formula,\n        fold = (x: NumNode, c: typeof context) => map(x, c) as OptNode\n      const foldStr = (x: StrNode, c: typeof context) => map(x, c) as StrNode\n      let result: OptNode | StrNode\n      switch (operation) {\n        case 'const':\n          result = formula\n          break\n        case 'add':\n        case 'mul':\n        case 'max':\n        case 'min': {\n          const f = allOperations[operation]\n          const numericOperands: number[] = []\n          const formulaOperands: OptNode[] = formula.operands\n            .filter((formula) => {\n              const folded = fold(formula, context)\n              return folded.operation === 'const'\n                ? (numericOperands.push(folded.value), false)\n                : true\n            })\n            .map((x) => fold(x, context))\n          const numericValue = f(numericOperands)\n\n          // Fold degenerate cases. This may incorrectly compute NaN\n          // results, which shouldn't appear under expected usage.\n          // - zero\n          //   - 0 * ... = 0\n          // - infinity\n          //   - max(infinity, ...) = infinity\n          //   - infinity + ... = infinity\n          // - (-infinity)\n          //   - min(-infinity, ...) - infinity\n          //   - (-infinity) + ... = -infinity\n          // - NaN\n          //   - operation(NaN, ...) = NaN\n          if (!isFinite(numericValue)) {\n            if (\n              operation !== 'mul' &&\n              (operation !== 'max' || numericValue > 0) &&\n              (operation !== 'min' || numericValue < 0)\n            ) {\n              result = constant(numericValue)\n              break\n            }\n          } else if (operation === 'mul' && numericValue === 0) {\n            result = constant(numericValue)\n            break\n          }\n\n          if (numericValue !== f([]))\n            // Skip vacuous values\n            formulaOperands.push(constant(numericValue))\n          if (formulaOperands.length <= 1)\n            result = formulaOperands[0] ?? constant(f([]))\n          else result = { operation, operands: formulaOperands }\n          break\n        }\n        case 'res':\n        case 'sum_frac': {\n          const operands = formula.operands.map((x) => fold(x, context))\n          const f = allOperations[operation]\n          if (operands.every((x) => x.operation === 'const'))\n            result = constant(\n              f(operands.map((x) => (x as ConstantNode<number>).value))\n            )\n          else result = { ...formula, operands }\n          break\n        }\n        case 'lookup': {\n          const index = foldStr(formula.operands[0], context)\n          if (index.operation === 'const') {\n            const selected = formula.table[index.value!] ?? formula.operands[1]\n            if (selected) {\n              result = map(selected, context)\n              break\n            }\n          }\n          throw new Error(`Unsupported ${operation} node while folding`)\n        }\n        case 'prio': {\n          const first = formula.operands.find((op) => {\n            const folded = foldStr(op, context)\n            if (folded.operation !== 'const')\n              throw new Error(`Unsupported ${operation} node while folding`)\n            return folded.value !== undefined\n          })\n          result = first ? foldStr(first, context) : constant(undefined)\n          break\n        }\n        case 'small': {\n          let smallest = undefined as\n            | ConstantNode<string | undefined>\n            | undefined\n          for (const operand of formula.operands) {\n            const folded = foldStr(operand, context)\n            if (folded.operation !== 'const')\n              throw new Error(`Unsupported ${operation} node while folding`)\n            if (\n              smallest?.value === undefined ||\n              (folded.value !== undefined && folded.value < smallest.value)\n            )\n              smallest = folded\n          }\n          result = smallest ?? constant(undefined)\n          break\n        }\n        case 'match': {\n          const [v1, v2, match, unmatch] = formula.operands.map(\n            (x: NumNode | StrNode) => map(x, context)\n          )\n          if (v1.operation !== 'const' || v2.operation !== 'const')\n            throw new Error(`Unsupported ${operation} node while folding`)\n          result = v1.value === v2.value ? match : unmatch\n          break\n        }\n        case 'threshold': {\n          const [value, threshold, pass, fail] = formula.operands.map(\n            (x) => map(x, context) as OptNode\n          )\n          if (\n            pass.operation === 'const' &&\n            fail.operation === 'const' &&\n            pass.value === fail.value\n          )\n            result = pass\n          else if (\n            value.operation === 'const' &&\n            threshold.operation === 'const'\n          )\n            result = value.value >= threshold.value ? pass : fail\n          else result = { ...formula, operands: [value, threshold, pass, fail] }\n          break\n        }\n        case 'subscript': {\n          const index = fold(formula.operands[0], context)\n          if (index.operation !== 'const')\n            throw new Error('Found non-constant subscript node while folding')\n          result = constant(formula.list[index.value])\n          break\n        }\n        case 'read': {\n          const operands = context.data\n            .map((x) => objPathValue(x, formula.path) as NumNode | StrNode)\n            .filter((x) => x)\n\n          if (operands.length === 0) {\n            if (shouldFold(formula)) {\n              const { accu } = formula\n              if (accu === undefined || accu === 'small')\n                result =\n                  formula.type === 'string'\n                    ? constant(undefined)\n                    : constant(NaN)\n              else result = constant(allOperations[accu]([]))\n            } else result = formula\n          } else if (formula.accu === undefined || operands.length === 1)\n            result = map(operands[operands.length - 1], context)\n          else\n            result = map(\n              { operation: formula.accu, operands } as\n                | ComputeNode\n                | StrPrioNode,\n              context\n            )\n          break\n        }\n        case 'data': {\n          if (formula.reset) context = origin\n          const nextMap = nextContextMap.get(context)!\n          let nextContext = nextMap.get(formula.data)\n          if (!nextContext) {\n            nextContext = {\n              data: [...context.data, formula.data],\n              processed: new Map(),\n            }\n            nextContextMap.set(nextContext, new Map())\n            nextMap.set(formula.data, nextContext)\n          }\n          result = map(formula.operands[0], nextContext)\n          break\n        }\n        default:\n          assertUnreachable(operation)\n      }\n\n      if (result.info) {\n        result = { ...result }\n        delete result.info\n      }\n      return result\n    }\n  ) as OptNode[]\n}\n\nexport const testing = {\n  constantFold,\n  flatten,\n  deduplicate,\n}\n","export const allGenderKeys = ['F', 'M'] as const\nexport type GenderKey = (typeof allGenderKeys)[number]\n\nexport const allElementKeys = [\n  'anemo',\n  'geo',\n  'electro',\n  'hydro',\n  'pyro',\n  'cryo',\n  'dendro',\n] as const\nexport type ElementKey = (typeof allElementKeys)[number]\n\nexport const allElementWithPhyKeys = ['physical', ...allElementKeys] as const\nexport type ElementWithPhyKey = (typeof allElementWithPhyKeys)[number]\n\nexport const allRegionKeys = [\n  'mondstadt',\n  'liyue',\n  'inazuma',\n  'sumeru',\n  'fontaine',\n  'natlan',\n  'snezhnaya',\n  'khaenriah',\n] as const\nexport type RegionKey = (typeof allRegionKeys)[number]\n\nexport const allAscensionKeys = [0, 1, 2, 3, 4, 5, 6] as const\nexport type AscensionKey = (typeof allAscensionKeys)[number]\n\nexport const allMoveKeys = [\n  'normal',\n  'charged',\n  'plunging',\n  'skill',\n  'burst',\n  'elemental',\n] as const\nexport type MoveKey = (typeof allMoveKeys)[number]\n\nexport const nonTravelerCharacterKeys = [\n  'Albedo',\n  'Alhaitham',\n  'Aloy',\n  'Amber',\n  'AratakiItto',\n  'Barbara',\n  'Beidou',\n  'Bennett',\n  'Candace',\n  'Chongyun',\n  'Collei',\n  'Cyno',\n  'Dehya',\n  'Diluc',\n  'Diona',\n  'Dori',\n  'Eula',\n  'Faruzan',\n  'Fischl',\n  'Ganyu',\n  'Gorou',\n  'HuTao',\n  'Jean',\n  'KaedeharaKazuha',\n  'Kaeya',\n  'KamisatoAyaka',\n  'KamisatoAyato',\n  'Keqing',\n  'Klee',\n  'KujouSara',\n  'KukiShinobu',\n  'Layla',\n  'Lisa',\n  'Mika',\n  'Mona',\n  'Nahida',\n  'Nilou',\n  'Ningguang',\n  'Noelle',\n  'Qiqi',\n  'RaidenShogun',\n  'Razor',\n  'Rosaria',\n  'SangonomiyaKokomi',\n  'Sayu',\n  'Shenhe',\n  'ShikanoinHeizou',\n  'Somnia',\n  'Sucrose',\n  'Tartaglia',\n  'Thoma',\n  'Tighnari',\n  'Venti',\n  'Wanderer',\n  'Xiangling',\n  'Xiao',\n  'Xingqiu',\n  'Xinyan',\n  'YaeMiko',\n  'Yanfei',\n  'Yaoyao',\n  'Yelan',\n  'Yoimiya',\n  'YunJin',\n  'Zhongli',\n] as const\n\nexport const allTravelerKeys = [\n  'TravelerAnemo',\n  'TravelerGeo',\n  'TravelerElectro',\n  'TravelerDendro',\n] as const\nexport type TravelerKey = (typeof allTravelerKeys)[number]\n\nexport const locationGenderedCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  'TravelerF',\n  'TravelerM',\n] as const\nexport type LocationGenderedCharacterKey =\n  (typeof locationGenderedCharacterKeys)[number]\n\nexport const allCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  ...allTravelerKeys,\n] as const\nexport type CharacterKey = (typeof allCharacterKeys)[number]\n\nexport const allLocationCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  'Traveler',\n] as const\nexport type LocationCharacterKey = (typeof allLocationCharacterKeys)[number]\n\nexport type LocationKey = LocationCharacterKey | ''\n\nexport function charKeyToLocGenderedCharKey(\n  charKey: CharacterKey,\n  gender: GenderKey\n): LocationGenderedCharacterKey {\n  if (allTravelerKeys.includes(charKey as TravelerKey))\n    return `Traveler${gender}`\n  return charKey as LocationGenderedCharacterKey\n}\n\nexport function charKeyToLocCharKey(\n  charKey: CharacterKey\n): LocationCharacterKey {\n  if (allTravelerKeys.includes(charKey as TravelerKey)) return 'Traveler'\n  return charKey as LocationCharacterKey\n}\n","import type { RarityKey } from './common'\n\nexport const allArtifactSetKeys = [\n  'Adventurer',\n  'ArchaicPetra',\n  'Berserker',\n  'BlizzardStrayer',\n  'BloodstainedChivalry',\n  'BraveHeart',\n  'CrimsonWitchOfFlames',\n  'DeepwoodMemories',\n  'DefendersWill',\n  'DesertPavilionChronicle',\n  'EchoesOfAnOffering',\n  'EmblemOfSeveredFate',\n  'FlowerOfParadiseLost',\n  'Gambler',\n  'GildedDreams',\n  'GladiatorsFinale',\n  'HeartOfDepth',\n  'HuskOfOpulentDreams',\n  'Instructor',\n  'Lavawalker',\n  'LuckyDog',\n  'MaidenBeloved',\n  'MartialArtist',\n  'NoblesseOblige',\n  'NymphsDream',\n  'OceanHuedClam',\n  'PaleFlame',\n  'PrayersForDestiny',\n  'PrayersForIllumination',\n  'PrayersForWisdom',\n  'PrayersToSpringtime',\n  'ResolutionOfSojourner',\n  'RetracingBolide',\n  'Scholar',\n  'ShimenawasReminiscence',\n  'TenacityOfTheMillelith',\n  'TheExile',\n  'ThunderingFury',\n  'Thundersoother',\n  'TinyMiracle',\n  'TravelingDoctor',\n  'VermillionHereafter',\n  'ViridescentVenerer',\n  'VourukashasGlow',\n  'WanderersTroupe',\n] as const\nexport type ArtifactSetKey = (typeof allArtifactSetKeys)[number]\n\nexport const allArtifactSlotKeys = [\n  'flower',\n  'plume',\n  'sands',\n  'goblet',\n  'circlet',\n] as const\nexport type ArtifactSlotKey = (typeof allArtifactSlotKeys)[number]\n\nexport const artMaxLevel: Record<RarityKey, number> = {\n  1: 4,\n  2: 4,\n  3: 12,\n  4: 16,\n  5: 20,\n} as const\n","import type { RarityKey } from './common'\n\nexport const allWeaponTypeKeys = [\n  'sword',\n  'claymore',\n  'polearm',\n  'bow',\n  'catalyst',\n] as const\nexport type WeaponTypeKey = (typeof allWeaponTypeKeys)[number]\n\nexport const allWeaponSwordKeys = [\n  'AmenomaKageuchi',\n  'AquilaFavonia',\n  'BlackcliffLongsword',\n  'CinnabarSpindle',\n  'CoolSteel',\n  'KagotsurubeIsshin',\n  'DarkIronSword',\n  'DullBlade',\n  'FavoniusSword',\n  'FesteringDesire',\n  'FilletBlade',\n  'FreedomSworn',\n  'HaranGeppakuFutsu',\n  'HarbingerOfDawn',\n  'IronSting',\n  'KeyOfKhajNisut',\n  'LightOfFoliarIncision',\n  'LionsRoar',\n  'MistsplitterReforged',\n  'PrimordialJadeCutter',\n  'PrototypeRancour',\n  'RoyalLongsword',\n  'SacrificialSword',\n  'SapwoodBlade',\n  'SilverSword',\n  'SkyriderSword',\n  'SkywardBlade',\n  'SummitShaper',\n  'SwordOfDescension',\n  'TheAlleyFlash',\n  'TheBlackSword',\n  'TheFlute',\n  'ToukabouShigure',\n  'TravelersHandySword',\n  'XiphosMoonlight',\n] as const\nexport type WeaponSwordKey = (typeof allWeaponSwordKeys)[number]\n\nexport const allWeaponClaymoreKeys = [\n  'Akuoumaru',\n  'BeaconOfTheReedSea',\n  'BlackcliffSlasher',\n  'BloodtaintedGreatsword',\n  'DebateClub',\n  'FavoniusGreatsword',\n  'FerrousShadow',\n  'ForestRegalia',\n  'KatsuragikiriNagamasa',\n  'LithicBlade',\n  'LuxuriousSeaLord',\n  'MailedFlower',\n  'MakhairaAquamarine',\n  'OldMercsPal',\n  'PrototypeArchaic',\n  'Rainslasher',\n  'RedhornStonethresher',\n  'RoyalGreatsword',\n  'SacrificialGreatsword',\n  'SerpentSpine',\n  'SkyriderGreatsword',\n  'SkywardPride',\n  'SnowTombedStarsilver',\n  'SongOfBrokenPines',\n  'TheBell',\n  'TheUnforged',\n  'WasterGreatsword',\n  'Whiteblind',\n  'WhiteIronGreatsword',\n  'WolfsGravestone',\n] as const\nexport type WeaponClaymoreKey = (typeof allWeaponClaymoreKeys)[number]\n\nexport const allWeaponPolearmKeys = [\n  'BeginnersProtector',\n  'BlackcliffPole',\n  'BlackTassel',\n  'CalamityQueller',\n  'CrescentPike',\n  'Deathmatch',\n  'DragonsBane',\n  'DragonspineSpear',\n  'EngulfingLightning',\n  'FavoniusLance',\n  'Halberd',\n  'IronPoint',\n  'KitainCrossSpear',\n  'LithicSpear',\n  'MissiveWindspear',\n  'Moonpiercer',\n  'PrimordialJadeWingedSpear',\n  'PrototypeStarglitter',\n  'RoyalSpear',\n  'SkywardSpine',\n  'StaffOfHoma',\n  'StaffOfTheScarletSands',\n  'TheCatch',\n  'VortexVanquisher',\n  'WavebreakersFin',\n  'WhiteTassel',\n] as const\nexport type WeaponPoleArmKey = (typeof allWeaponPolearmKeys)[number]\n\nexport const allWeaponBowKeys = [\n  'AlleyHunter',\n  'AmosBow',\n  'AquaSimulacra',\n  'BlackcliffWarbow',\n  'CompoundBow',\n  'ElegyForTheEnd',\n  'EndOfTheLine',\n  'FadingTwilight',\n  'FavoniusWarbow',\n  'Hamayumi',\n  'HuntersBow',\n  'HuntersPath',\n  'KingsSquire',\n  'Messenger',\n  'MitternachtsWaltz',\n  'MouunsMoon',\n  'PolarStar',\n  'Predator',\n  'PrototypeCrescent',\n  'RavenBow',\n  'RecurveBow',\n  'RoyalBow',\n  'Rust',\n  'SacrificialBow',\n  'SeasonedHuntersBow',\n  'SharpshootersOath',\n  'SkywardHarp',\n  'Slingshot',\n  'TheStringless',\n  'TheViridescentHunt',\n  'ThunderingPulse',\n  'WindblumeOde',\n] as const\nexport type WeaponBowKey = (typeof allWeaponBowKeys)[number]\n\nexport const allWeaponCatalystKeys = [\n  'ApprenticesNotes',\n  'AThousandFloatingDreams',\n  'BlackcliffAgate',\n  'DodocoTales',\n  'EmeraldOrb',\n  'EverlastingMoonglow',\n  'EyeOfPerception',\n  'FavoniusCodex',\n  'Frostbearer',\n  'FruitOfFulfillment',\n  'HakushinRing',\n  'KagurasVerity',\n  'LostPrayerToTheSacredWinds',\n  'MagicGuide',\n  'MappaMare',\n  'MemoryOfDust',\n  'OathswornEye',\n  'OtherworldlyStory',\n  'PocketGrimoire',\n  'PrototypeAmber',\n  'QuantumCatalyst',\n  'RoyalGrimoire',\n  'SacrificialFragments',\n  'SkywardAtlas',\n  'SolarPearl',\n  'TheWidsith',\n  'ThrillingTalesOfDragonSlayers',\n  'TulaytullahsRemembrance',\n  'TwinNephrite',\n  'WanderingEvenstar',\n  'WineAndSong',\n] as const\nexport type WeaponCatalystKey = (typeof allWeaponCatalystKeys)[number]\n\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\nexport type WeaponKey =\n  | WeaponSwordKey\n  | WeaponClaymoreKey\n  | WeaponPoleArmKey\n  | WeaponBowKey\n  | WeaponCatalystKey\n\nexport const weaponMaxLevel: Record<RarityKey, number> = {\n  1: 70,\n  2: 70,\n  3: 90,\n  4: 90,\n  5: 90,\n} as const\n","import type {\n  allArtifactSetKeys,\n  WeaponBowKey,\n  WeaponCatalystKey,\n  WeaponClaymoreKey,\n  WeaponPoleArmKey,\n  WeaponSwordKey,\n} from '@genshin-optimizer/consts'\nimport {\n  allWeaponBowKeys,\n  allWeaponCatalystKeys,\n  allWeaponClaymoreKeys,\n  allWeaponPolearmKeys,\n  allWeaponSwordKeys,\n  nonTravelerCharacterKeys,\n} from '@genshin-optimizer/consts'\n\nexport const allHitModes = ['hit', 'avgHit', 'critHit'] as const\nexport const allAmpReactions = ['vaporize', 'melt'] as const\nexport const allAdditiveReactions = ['spread', 'aggravate'] as const\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\n\nexport const allArtifactRarities = [5, 4, 3] as const\n/**\n * @deprecated\n */\nexport const allSlotKeys = [\n  'flower',\n  'plume',\n  'sands',\n  'goblet',\n  'circlet',\n] as const\n/**\n * @deprecated\n */\nexport const allElements = [\n  'anemo',\n  'geo',\n  'electro',\n  'hydro',\n  'pyro',\n  'cryo',\n  'dendro',\n] as const\n/**\n * @deprecated\n */\nexport const allElementsWithPhy = ['physical', ...allElements] as const\nexport const allInfusionAuraElements = [\n  'pyro',\n  'cryo',\n  'hydro',\n  'electro',\n] as const\n/**\n * @deprecated\n */\nexport const allWeaponTypeKeys = [\n  'sword',\n  'claymore',\n  'polearm',\n  'bow',\n  'catalyst',\n] as const\nexport const allRollColorKeys = [\n  'roll1',\n  'roll2',\n  'roll3',\n  'roll4',\n  'roll5',\n  'roll6',\n] as const\n/**\n * @deprecated\n */\nexport const allAscension = [0, 1, 2, 3, 4, 5, 6] as const\nexport const allRefinement = [1, 2, 3, 4, 5] as const\nexport const substatType = ['max', 'mid', 'min'] as const\nexport const genderKeys = ['F', 'M'] as const\nexport type Gender = (typeof genderKeys)[number]\n\n/**\n * @deprecated\n */\nexport const allLocationCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  'Traveler',\n] as const\nexport const travelerElements = ['anemo', 'geo', 'electro', 'dendro'] as const\nexport const travelerFKeys = [\n  'TravelerAnemoF',\n  'TravelerGeoF',\n  'TravelerElectroF',\n  'TravelerDendroF',\n] as const\nexport const travelerMKeys = [\n  'TravelerAnemoM',\n  'TravelerGeoM',\n  'TravelerElectroM',\n  'TravelerDendroM',\n] as const\n/**\n * @deprecated\n */\nexport const travelerKeys = [\n  'TravelerAnemo',\n  'TravelerGeo',\n  'TravelerElectro',\n  'TravelerDendro',\n] as const\n/**\n * @deprecated\n */\nexport const allCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  ...travelerKeys,\n] as const\n\nexport const allCharacterSheetKeys = [\n  ...nonTravelerCharacterKeys,\n  ...travelerFKeys,\n  ...travelerMKeys,\n]\n\n/**\n * @deprecated\n */\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\n/**\n * @deprecated\n */\nexport type WeaponKey =\n  | WeaponSwordKey\n  | WeaponClaymoreKey\n  | WeaponPoleArmKey\n  | WeaponBowKey\n  | WeaponCatalystKey\n\nexport const characterSpecializedStatKeys = [\n  'hp_',\n  'atk_',\n  'def_',\n  'eleMas',\n  'enerRech_',\n  'heal_',\n  'critRate_',\n  'critDMG_',\n  'physical_dmg_',\n  'anemo_dmg_',\n  'geo_dmg_',\n  'electro_dmg_',\n  'hydro_dmg_',\n  'pyro_dmg_',\n  'cryo_dmg_',\n  'dendro_dmg_',\n] as const\n\nexport type HitModeKey = (typeof allHitModes)[number]\nexport type AmpReactionKey = (typeof allAmpReactions)[number]\nexport type AdditiveReactionKey = (typeof allAdditiveReactions)[number]\nexport type SetNum = (typeof allArtifactSetCount)[number]\nexport type ArtifactRarity = (typeof allArtifactRarities)[number]\n/**\n * @deprecated\n */\nexport type SlotKey = (typeof allSlotKeys)[number]\n/**\n * @deprecated\n */\nexport type ElementKey = (typeof allElements)[number]\n/**\n * @deprecated\n */\nexport type ElementKeyWithPhy = (typeof allElementsWithPhy)[number]\nexport type InfusionAuraElements = (typeof allInfusionAuraElements)[number]\n/**\n * @deprecated\n */\nexport type ArtifactSetKey = (typeof allArtifactSetKeys)[number]\n/**\n * @deprecated\n */\nexport type CharacterKey = (typeof allCharacterKeys)[number]\nexport type CharacterSheetKey = (typeof allCharacterSheetKeys)[number]\n/**\n * @deprecated\n */\nexport type LocationCharacterKey = (typeof allLocationCharacterKeys)[number]\n/**\n * @deprecated\n */\nexport type TravelerKey = (typeof travelerKeys)[number]\nexport type TravelerElementKey = (typeof travelerElements)[number]\n/**\n * @deprecated\n */\nexport type WeaponTypeKey = (typeof allWeaponTypeKeys)[number]\nexport type RollColorKey = (typeof allRollColorKeys)[number]\n/**\n * @deprecated\n */\nexport type Ascension = (typeof allAscension)[number]\nexport type Refinement = (typeof allRefinement)[number]\nexport type CharacterSpecializedStatKey =\n  (typeof characterSpecializedStatKeys)[number]\nexport const absorbableEle = [\n  'hydro',\n  'pyro',\n  'cryo',\n  'electro',\n] as ElementKey[]\nexport const allowedAmpReactions: Dict<ElementKey, AmpReactionKey[]> = {\n  pyro: ['vaporize', 'melt'],\n  hydro: ['vaporize'],\n  cryo: ['melt'],\n  anemo: ['vaporize', 'melt'],\n}\nexport const allowedAdditiveReactions: Dict<ElementKey, AdditiveReactionKey[]> =\n  {\n    dendro: ['spread'],\n    electro: ['aggravate'],\n    anemo: ['aggravate'],\n  }\n\nexport type SubstatType = (typeof substatType)[number]\n\n/**\n * @deprecated\n */\nexport function charKeyToLocCharKey(\n  charKey: CharacterKey\n): LocationCharacterKey {\n  if (travelerKeys.includes(charKey as TravelerKey)) return 'Traveler'\n  return charKey as LocationCharacterKey\n}\n\nexport function TravelerToElement(\n  key: TravelerKey,\n  element: TravelerElementKey\n): TravelerKey {\n  return ('Traveler' +\n    element.toUpperCase().slice(0, 1) +\n    element.slice(1)) as TravelerKey\n}\n\n/**\n * @deprecated\n */\nexport type LocationKey = LocationCharacterKey | ''\n\nexport function charKeyToCharName(ck: CharacterKey, gender: Gender): string {\n  return ck.startsWith('Traveler') ? 'Traveler' + gender : ck\n}\n","import type { ArtSetExclusion } from '../Database/DataManagers/BuildSettingData'\nimport { forEachNodes, mapFormulas } from '../Formula/internal'\nimport type { OptNode } from '../Formula/optimization'\nimport { allOperations, constantFold } from '../Formula/optimization'\nimport type { ConstantNode } from '../Formula/type'\nimport { constant, dynRead, max, min, sum, threshold } from '../Formula/utils'\nimport type { ArtifactSetKey, SlotKey } from '../Types/consts'\nimport { allSlotKeys } from '../Types/consts'\nimport { assertUnreachable, objectKeyMap, objectMap, range } from '../Util/Util'\n\ntype MicropassOperation =\n  | 'reaffine'\n  | 'pruneArtRange'\n  | 'pruneNodeRange'\n  | 'pruneOrder'\nexport function pruneAll(\n  nodes: OptNode[],\n  minimum: number[],\n  arts: ArtifactsBySlot,\n  numTop: number,\n  exclusion: ArtSetExclusion,\n  forced: Dict<MicropassOperation, boolean>\n): { nodes: OptNode[]; arts: ArtifactsBySlot } {\n  let should = forced\n  /** If `key` makes progress, all operations in `value` should be performed */\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\n    pruneOrder: { pruneNodeRange: true },\n    pruneArtRange: { pruneNodeRange: true },\n    pruneNodeRange: { reaffine: true },\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true },\n  }\n  let count = 0\n  while (Object.values(should).some((x) => x) && count++ < 20) {\n    if (should.pruneOrder) {\n      delete should.pruneOrder\n      const newArts = pruneOrder(arts, numTop, exclusion)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneOrder }\n      }\n    }\n    if (should.pruneArtRange) {\n      delete should.pruneArtRange\n      const newArts = pruneArtRange(nodes, arts, minimum)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneArtRange }\n      }\n    }\n    if (should.pruneNodeRange) {\n      delete should.pruneNodeRange\n      const newNodes = pruneNodeRange(nodes, arts)\n      if (nodes !== newNodes) {\n        nodes = newNodes\n        should = { ...should, ...deps.pruneNodeRange }\n      }\n    }\n    if (should.reaffine) {\n      delete should.reaffine\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\n      if (nodes !== newNodes || arts !== newArts) {\n        nodes = newNodes\n        arts = newArts\n        should = { ...should, ...deps.reaffine }\n      }\n    }\n  }\n  return { nodes, arts }\n}\n\nexport function pruneExclusion(\n  nodes: OptNode[],\n  exclusion: ArtSetExclusion\n): OptNode[] {\n  const maxValues: Dict<keyof typeof exclusion, number> = {}\n  for (const [key, e] of Object.entries(exclusion)) {\n    if (!e.includes(4)) continue\n    maxValues[key] = e.includes(2) ? 1 : 3\n  }\n  return mapFormulas(\n    nodes,\n    (f) => f,\n    (f) => {\n      if (f.operation !== 'threshold') return f\n\n      const [v, t, pass, fail] = f.operands\n      if (v.operation === 'read' && t.operation === 'const') {\n        const key = v.path[v.path.length - 1],\n          thres = t.value\n        if (key in maxValues) {\n          const max: number = maxValues[key]\n          if (max < thres) return fail\n          if (thres === 2 && exclusion[key]!.includes(2))\n            return threshold(v, 4, pass, fail)\n        }\n      }\n      return f\n    }\n  )\n}\n\nfunction reaffine(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot,\n  forceRename = false\n): { nodes: OptNode[]; arts: ArtifactsBySlot } {\n  const affineNodes = new Set<OptNode>(),\n    topLevelAffine = new Set<OptNode>()\n\n  function visit(node: OptNode, isAffine: boolean): OptNode {\n    if (isAffine) affineNodes.add(node)\n    else\n      node.operands.forEach(\n        (op) => affineNodes.has(op) && topLevelAffine.add(op)\n      )\n    return node\n  }\n\n  const dynKeys = new Set<string>()\n\n  nodes = mapFormulas(\n    nodes,\n    (_) => _,\n    (f) => {\n      const { operation } = f\n      switch (operation) {\n        case 'read':\n          dynKeys.add(f.path[1])\n          return visit(f, true)\n        case 'add': {\n          const affineOps = f.operands.filter((op) => affineNodes.has(op))\n          const nonAffineOps = f.operands.filter((op) => !affineNodes.has(op))\n          if (nonAffineOps.length === 0) return visit(f, true)\n          if (affineOps.length <= 1) return visit(f, false)\n          const affine = visit(sum(...affineOps), true)\n          return visit(sum(affine, ...nonAffineOps), false)\n        }\n        case 'mul': {\n          const nonConst = f.operands.filter((op) => op.operation !== 'const')\n          return visit(\n            f,\n            nonConst.length === 0 ||\n              (nonConst.length === 1 && affineNodes.has(nonConst[0]))\n          )\n        }\n        case 'const':\n          return visit(f, true)\n        case 'res':\n        case 'threshold':\n        case 'sum_frac':\n        case 'max':\n        case 'min':\n          return visit(f, false)\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n\n  nodes\n    .filter((node) => affineNodes.has(node))\n    .forEach((node) => topLevelAffine.add(node))\n  if (\n    [...topLevelAffine].every(\n      ({ operation }) => operation === 'read' || operation === 'const'\n    ) &&\n    Object.keys(arts.base).length === dynKeys.size\n  )\n    return { nodes, arts }\n\n  let current = -1\n  function nextDynKey(): string {\n    while (dynKeys.has(`${++current}`));\n    return `${current}`\n  }\n\n  const affine = [...topLevelAffine].filter((f) => f.operation !== 'const')\n  const affineMap = new Map(\n    affine.map((node) => [\n      node,\n      !forceRename && node.operation === 'read' && node.path[0] === 'dyn'\n        ? node\n        : dynRead(nextDynKey()),\n    ])\n  )\n  nodes = mapFormulas(\n    nodes,\n    (f) => affineMap.get(f) ?? f,\n    (f) => f\n  )\n\n  function reaffineArt(stat: DynStat): DynStat {\n    const values = constantFold(\n      [...affineMap.keys()],\n      {\n        dyn: objectMap(stat, (value) => constant(value)),\n      } as any,\n      (_) => true\n    )\n    return Object.fromEntries(\n      [...affineMap.values()].map((v, i) => [\n        v.path[1],\n        (values[i] as ConstantNode<number>).value,\n      ])\n    )\n  }\n  const result = {\n    nodes,\n    arts: {\n      base: reaffineArt(arts.base),\n      values: objectKeyMap(allSlotKeys, (slot) =>\n        arts.values[slot].map(({ id, set, values }) => ({\n          id,\n          set,\n          values: reaffineArt(values),\n        }))\n      ),\n    },\n  }\n  const offsets = Object.entries(reaffineArt({}))\n  for (const arts of Object.values(result.arts.values))\n    for (const { values } of arts)\n      for (const [key, baseValue] of offsets) values[key] -= baseValue\n  return result\n}\n/** Remove artifacts that cannot be in top `numTop` builds */\nfunction pruneOrder(\n  arts: ArtifactsBySlot,\n  numTop: number,\n  exclusion: ArtSetExclusion\n): ArtifactsBySlot {\n  let progress = false\n  /**\n   * Note:\n   * This function assumes that every base (reaffined) stats are monotonically increasing. That is, artifacts\n   * with higher stats are better. This remains true as long as the main and substats are in increasing. Set\n   * effects that decrease enemy resistance (which is monotonically decreasing) does not violate this assumption\n   * as set effects are not handled here.\n   */\n  const allowRainbow = !exclusion.rainbow?.length,\n    keys = Object.keys(arts.base)\n  const noSwitchIn = new Set(\n    Object.entries(exclusion)\n      .filter(([_, v]) => v.length)\n      .map(([k]) => k) as ArtifactSetKey[]\n  )\n  const noSwitchOut = new Set(\n    Object.entries(exclusion)\n      .filter(([_, v]) => v.includes(2) && !v.includes(4))\n      .map(([k]) => k) as ArtifactSetKey[]\n  )\n  const values = objectKeyMap(allSlotKeys, (slot) => {\n    const list = arts.values[slot]\n    const newList = list.filter((art) => {\n      let count = 0\n      return list.every((other) => {\n        const otherBetterEqual = keys.every(\n          (k) => (other.values[k] ?? 0) >= (art.values[k] ?? 0)\n        )\n        const otherMaybeBetter = keys.some(\n          (k) => (other.values[k] ?? 0) > (art.values[k] ?? 0)\n        )\n        const otherBetter =\n          otherBetterEqual && (otherMaybeBetter || other.id > art.id)\n        const canSwitch =\n          (allowRainbow &&\n            !noSwitchIn.has(other.set!) &&\n            !noSwitchOut.has(art.set!)) ||\n          art.set === other.set\n        if (otherBetter && canSwitch) count++\n        return count < numTop\n      })\n    })\n    if (newList.length !== list.length) progress = true\n    return newList\n  })\n  return progress ? { base: arts.base, values } : arts\n}\n/** Remove artifacts that cannot reach `minimum` in any build */\nfunction pruneArtRange(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot,\n  minimum: number[]\n): ArtifactsBySlot {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  const wrap = { arts }\n  while (true) {\n    const artRanges = objectKeyMap(allSlotKeys, (slot) =>\n      computeArtRange(wrap.arts.values[slot])\n    )\n    const otherArtRanges = objectKeyMap(allSlotKeys, (key) =>\n      addArtRange(\n        Object.entries(artRanges)\n          .map((a) => (a[0] === key ? baseRange : a[1]))\n          .filter((x) => x)\n      )\n    )\n\n    let progress = false\n    const values = objectKeyMap(allSlotKeys, (slot) => {\n      const result = wrap.arts.values[slot].filter((art) => {\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\n        const newRange = computeNodeRange(nodes, read)\n        return nodes.every(\n          (node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity)\n        )\n      })\n      if (result.length !== wrap.arts.values[slot].length) progress = true\n      return result\n    })\n    if (!progress) break\n    wrap.arts = { base: wrap.arts.base, values }\n  }\n  return wrap.arts\n}\nfunction pruneNodeRange(nodes: OptNode[], arts: ArtifactsBySlot): OptNode[] {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  const reads = addArtRange([\n    baseRange,\n    ...Object.values(arts.values).map((values) => computeArtRange(values)),\n  ])\n  const nodeRange = computeNodeRange(nodes, reads)\n\n  return mapFormulas(\n    nodes,\n    (f) => {\n      {\n        const { min, max } = nodeRange.get(f)!\n        if (min === max) return constant(min)\n      }\n      const { operation } = f\n      const operandRanges = f.operands.map((x) => nodeRange.get(x)!)\n      switch (operation) {\n        case 'threshold': {\n          const [value, threshold, pass, fail] = operandRanges\n          if (value.min >= threshold.max) return f.operands[2]\n          else if (value.max < threshold.min) return f.operands[3]\n          if (\n            pass.max === pass.min &&\n            fail.max === fail.min &&\n            pass.min === fail.min &&\n            isFinite(pass.min)\n          )\n            return constant(pass.max)\n          break\n        }\n        case 'min': {\n          const newOperands = f.operands.filter((_, i) => {\n            const op1 = operandRanges[i]\n            return operandRanges.every((op2) => op1.min <= op2.max)\n          })\n          if (newOperands.length < operandRanges.length)\n            return min(...newOperands)\n          break\n        }\n        case 'max': {\n          const newOperands = f.operands.filter((_, i) => {\n            const op1 = operandRanges[i]\n            return operandRanges.every((op2) => op1.max >= op2.min)\n          })\n          if (newOperands.length < operandRanges.length)\n            return max(...newOperands)\n          break\n        }\n      }\n      return f\n    },\n    (f) => f\n  )\n}\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\n  const result: DynMinMax = {}\n  ranges.forEach((range) => {\n    Object.entries(range).forEach(([key, value]) => {\n      if (result[key]) {\n        result[key].min += value.min\n        result[key].max += value.max\n      } else result[key] = { ...value }\n    })\n  })\n  return result\n}\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\n  const result: DynMinMax = {}\n  if (arts.length) {\n    Object.keys(arts[0].values)\n      .filter((key) => arts.every((art) => art.values[key]))\n      .forEach(\n        (key) =>\n          (result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\n      )\n    arts.forEach(({ values }) => {\n      for (const [key, value] of Object.entries(values)) {\n        if (!result[key]) result[key] = { min: 0, max: value }\n        else {\n          if (result[key].max < value) result[key].max = value\n          if (result[key].min > value) result[key].min = value\n        }\n      }\n    })\n  }\n  return result\n}\nexport function computeFullArtRange(arts: ArtifactsBySlot): DynMinMax {\n  const baseRange = Object.fromEntries(\n    Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }])\n  )\n  return addArtRange([\n    baseRange,\n    ...Object.values(arts.values).map((values) => computeArtRange(values)),\n  ])\n}\nexport function computeNodeRange(\n  nodes: OptNode[],\n  reads: DynMinMax\n): Map<OptNode, MinMax> {\n  const range = new Map<OptNode, MinMax>()\n\n  forEachNodes(\n    nodes,\n    (_) => {},\n    (f) => {\n      const { operation } = f\n      const operands = f.operands.map((op) => range.get(op)!)\n      let current: MinMax\n      switch (operation) {\n        case 'read':\n          if (f.path[0] !== 'dyn')\n            throw new Error(\n              `Found non-dyn path ${f.path} while computing range`\n            )\n          current = reads[f.path[1]] ?? { min: 0, max: 0 }\n          break\n        case 'const':\n          current = computeMinMax([f.value])\n          break\n        case 'add':\n        case 'min':\n        case 'max':\n          current = {\n            min: allOperations[operation](operands.map((x) => x.min)),\n            max: allOperations[operation](operands.map((x) => x.max)),\n          }\n          break\n        case 'res':\n          current = {\n            min: allOperations[operation]([operands[0].max]),\n            max: allOperations[operation]([operands[0].min]),\n          }\n          break\n        case 'mul':\n          current = operands.reduce((accu, current) =>\n            computeMinMax([\n              accu.min * current.min,\n              accu.min * current.max,\n              accu.max * current.min,\n              accu.max * current.max,\n            ])\n          )\n          break\n        case 'threshold':\n          if (operands[0].min >= operands[1].max) current = operands[2]\n          else if (operands[0].max < operands[1].min) current = operands[3]\n          else current = computeMinMax([], [operands[2], operands[3]])\n          break\n        case 'sum_frac': {\n          const [x, c] = operands,\n            sum = { min: x.min + c.min, max: x.max + c.max }\n          if (sum.min <= 0 && sum.max >= 0)\n            current =\n              x.min <= 0 && x.max >= 0\n                ? { min: NaN, max: NaN }\n                : { min: -Infinity, max: Infinity }\n          // TODO: Check this\n          else\n            current = computeMinMax([\n              x.min / sum.min,\n              x.min / sum.max,\n              x.max / sum.min,\n              x.max / sum.max,\n            ])\n          break\n        }\n        default:\n          assertUnreachable(operation)\n      }\n      range.set(f, current)\n    }\n  )\n  return range\n}\nfunction computeMinMax(\n  values: readonly number[],\n  minMaxes: readonly MinMax[] = []\n): MinMax {\n  const max = Math.max(...values, ...minMaxes.map((x) => x.max))\n  const min = Math.min(...values, ...minMaxes.map((x) => x.min))\n  return { min, max }\n}\n\nexport function filterArts(\n  arts: ArtifactsBySlot,\n  filters: RequestFilter\n): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objectKeyMap(allSlotKeys, (slot) => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case 'id':\n          return arts.values[slot].filter((art) => filter.ids.has(art.id))\n        case 'exclude':\n          return arts.values[slot].filter((art) => !filter.sets.has(art.set!))\n        case 'required':\n          return arts.values[slot].filter((art) => filter.sets.has(art.set!))\n      }\n    }),\n  }\n}\n\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\n  return builds\n    .flatMap((x) => x)\n    .sort((a, b) => b.value - a.value)\n    .slice(0, maxNum)\n}\nexport function mergePlot(plots: PlotData[]): PlotData {\n  let scale = 0.01\n  const reductionScaling = 2,\n    maxCount = 1500\n  let keys = new Set(\n    plots.flatMap((x) =>\n      Object.values(x).map((v) => Math.round(v.plot! / scale))\n    )\n  )\n  while (keys.size > maxCount) {\n    scale *= reductionScaling\n    keys = new Set([...keys].map((key) => Math.round(key / reductionScaling)))\n  }\n  const result: PlotData = {}\n  for (const plot of plots)\n    for (const build of Object.values(plot)) {\n      const x = Math.round(build.plot! / scale) * scale\n      if (!result[x] || result[x]!.value < build.value) result[x] = build\n    }\n  return result\n}\n\nexport function countBuilds(arts: ArtifactsBySlot): number {\n  return allSlotKeys.reduce(\n    (_count, slot) => _count * arts.values[slot].length,\n    1\n  )\n}\n\nexport function* filterFeasiblePerm(\n  filters: Iterable<RequestFilter>,\n  _artSets: ArtifactsBySlot\n): Iterable<RequestFilter> {\n  const artSets = objectMap(\n    _artSets.values,\n    (values) => new Set(values.map((v) => v.set))\n  )\n  filter_loop: for (const filter of filters) {\n    for (const [slot, f] of Object.entries(filter)) {\n      const available = artSets[slot]!\n      switch (f.kind) {\n        case 'required':\n          if ([...f.sets].every((s) => !available.has(s))) continue filter_loop\n          break\n        case 'exclude':\n          if ([...available].every((s) => f.sets.has(s!))) continue filter_loop\n          break\n        case 'id':\n          break\n      }\n    }\n    yield filter\n  }\n}\nexport function exclusionToAllowed(\n  exclusion: number[] | undefined\n): Set<number> {\n  return new Set(\n    exclusion?.includes(2)\n      ? exclusion.includes(4)\n        ? [0, 1]\n        : [0, 1, 4, 5]\n      : exclusion?.includes(4)\n      ? [0, 1, 2, 3]\n      : [0, 1, 2, 3, 4, 5]\n  )\n}\n/** A *disjoint* set of `RequestFilter` satisfying the exclusion rules */\nexport function* artSetPerm(\n  exclusion: ArtSetExclusion,\n  _artSets: ArtifactSetKey[]\n): Iterable<RequestFilter> {\n  /**\n   * This generation algorithm is separated into two parts:\n   * - \"Shape\" generation\n   *   - It first generates all build \"shapes\", e.g., AABBC, ABBCD\n   *   - It then filters the generated shapes according to the rainbow exclusion, e.g., removes ABBCD if excluding 3 rainbows\n   *   - It then merges the remaining shapes into wildcards, e.g. AABAA + AABAB + AABAC => AABA*\n   * - Shape filling\n   *   - From the given shapes, it tries to fill in all non-rainbow slots, e.g., slots A and B of AABBC, with actual artifacts\n   *   - It then fills the rainbow slots, e.g., slot C of AABBC while ensuring the exclusion rule of each sets\n   */\n  const artSets = [...new Set(_artSets)],\n    allowedRainbows = exclusionToAllowed(exclusion.rainbow)\n  let shapes: number[][] = []\n  function populateShapes(\n    current: number[],\n    list: Set<number>,\n    rainbows: number[]\n  ) {\n    if (current.length === 5) {\n      if (allowedRainbows.has(rainbows.length)) shapes.push(current)\n      return\n    }\n    for (const i of list)\n      populateShapes(\n        [...current, i],\n        list,\n        rainbows.filter((j) => j !== i)\n      )\n    populateShapes(\n      [...current, current.length],\n      new Set([...list, current.length]),\n      [...rainbows, current.length]\n    )\n  }\n  populateShapes([0], new Set([0]), [0])\n  function indexOfShape(shape: number[], replacing: number) {\n    if (range(replacing + 1, 4).some((i) => shape[i] !== 5)) return undefined\n    shape = [...shape]\n    shape[replacing] = 5\n    return shape.reduce((a, b) => a * 6 + b, 0)\n  }\n  for (let replacing = 4; replacing >= 0; replacing--) {\n    const required: Map<number, number> = new Map()\n    for (const shape of shapes) {\n      const id = indexOfShape(shape, replacing)\n      if (id === undefined) continue\n      required.set(\n        id,\n        (required.get(id) ?? new Set(shape.slice(0, replacing)).size + 1) - 1\n      )\n    }\n    for (const [id, remaining] of required.entries()) {\n      if (remaining === 0) {\n        const shape = [\n          ...shapes.find((shape) => indexOfShape(shape, replacing) === id)!,\n        ]\n        shape[replacing] = 5\n        shapes = shapes.filter((shape) => indexOfShape(shape, replacing) !== id)\n        shapes.push(shape)\n      }\n    }\n  }\n\n  // Shapes are now calculated and merged, proceed to fill in the sets\n\n  const noFilter = { kind: 'exclude' as const, sets: new Set<ArtifactSetKey>() }\n  const result: RequestFilter = objectKeyMap(allSlotKeys, (_) => noFilter)\n\n  const counts = {\n    ...objectMap(exclusion, (_) => 0),\n    ...objectKeyMap(artSets, (_) => 0),\n  }\n  const allowedCounts = objectMap(exclusion, exclusionToAllowed)\n\n  function* check(shape: number[]) {\n    const used: Set<ArtifactSetKey> = new Set(),\n      rainbows: number[] = []\n    let groupped: number[][] = []\n    for (const i of shape) {\n      groupped.push([])\n      if (i === 5) rainbows.push(groupped.length - 1)\n      else groupped[i].push(groupped.length - 1)\n    }\n    groupped = groupped\n      .filter((v) => v.length)\n      .sort((a, b) => b.length - a.length)\n    let usableRainbows = rainbows.length\n\n    // Inception.. because js doesn't like functions inside a for-loop\n    function* check(i: number) {\n      if (i === groupped.length) return yield* check_free(0)\n\n      for (const set of artSets) {\n        if (used.has(set)) continue\n        const length = groupped[i].length,\n          allowedSet = allowedCounts[set]\n        let requiredRainbows = 0\n\n        if (allowedSet && !allowedSet.has(length)) {\n          // Look ahead and see if we have enough rainbows to fill to the next `allowedSet` if we use the current set\n          requiredRainbows =\n            (range(length + 1, 5).find((l) => allowedSet.has(l)) ?? 6) - length\n          if (requiredRainbows > usableRainbows) continue // Not enough rainbows. Next..\n        }\n\n        used.add(set)\n        counts[set] = groupped[i].length\n        groupped[i].forEach(\n          (j) =>\n            (result[allSlotKeys[j]] = {\n              kind: 'required',\n              sets: new Set([set]),\n            })\n        )\n        usableRainbows -= requiredRainbows\n\n        yield* check(i + 1)\n\n        usableRainbows += requiredRainbows\n        counts[set] = 0\n        used.delete(set)\n      }\n    }\n    // We separate filling rainbow slots from groupped slots because it has an entirely\n    // different set of rules regarding what can be filled and what states to be kept.\n    function* check_free(i: number) {\n      const remaining = rainbows.length - i,\n        isolated: ArtifactSetKey[] = [],\n        missing: ArtifactSetKey[] = [],\n        rejected: ArtifactSetKey[] = []\n      let required = 0\n      for (const set of artSets) {\n        const allowedSet = allowedCounts[set],\n          count = counts[set]\n        if (!allowedSet) continue\n        if (range(1, remaining).every((j) => !allowedSet.has(count + j)))\n          rejected.push(set)\n        else if (!allowedSet.has(count)) {\n          required += [...allowedSet].find((x) => x > count)! - count\n          missing.push(set)\n        } else if (range(0, remaining).some((j) => !allowedSet.has(count + j)))\n          isolated.push(set)\n      }\n      if (required > remaining) return\n      if (i === rainbows.length) {\n        yield { ...result }\n        return\n      }\n      if (required === remaining) {\n        for (const set of missing) {\n          counts[set]++\n          result[allSlotKeys[rainbows[i]]] = {\n            kind: 'required',\n            sets: new Set([set]),\n          }\n          yield* check_free(i + 1)\n          counts[set]--\n        }\n        return\n      }\n      for (const set of [...isolated, ...missing]) {\n        counts[set]++\n        result[allSlotKeys[rainbows[i]]] = {\n          kind: 'required',\n          sets: new Set([set]),\n        }\n        yield* check_free(i + 1)\n        counts[set]--\n      }\n      result[allSlotKeys[rainbows[i]]] = {\n        kind: 'exclude',\n        sets: new Set([...missing, ...rejected, ...isolated]),\n      }\n      yield* check_free(i + 1)\n    }\n    yield* check(0)\n  }\n  for (const shape of shapes) yield* check(shape)\n}\n\nexport type RequestFilter = StrictDict<\n  SlotKey,\n  | { kind: 'required'; sets: Set<ArtifactSetKey> }\n  | { kind: 'exclude'; sets: Set<ArtifactSetKey> }\n  | { kind: 'id'; ids: Set<string> }\n>\n\nexport type DynStat = { [key in string]: number }\nexport type ArtifactBuildData = {\n  id: string\n  set?: ArtifactSetKey\n  values: DynStat\n}\nexport type ArtifactsBySlot = {\n  base: DynStat\n  values: StrictDict<SlotKey, ArtifactBuildData[]>\n}\n\nexport type PlotData = Dict<number, Build>\nexport interface Build {\n  value: number\n  plot?: number\n  artifactIds: string[]\n}\n\nexport type DynMinMax = { [key in string]: MinMax }\nexport type MinMax = { min: number; max: number }\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { customMapFormula, forEachNodes } from '../../Formula/internal'\nimport type { OptNode } from '../../Formula/optimization'\nimport { allOperations } from '../../Formula/optimization'\nimport type { ConstantNode } from '../../Formula/type'\nimport { prod, threshold } from '../../Formula/utils'\nimport { assertUnreachable, cartesian } from '../../Util/Util'\nimport type { ArtifactsBySlot, MinMax } from '../common'\nimport { computeFullArtRange, computeNodeRange } from '../common'\nimport type { Linear } from './linearUB'\n\n/**\n * With xi being the variables and pi(x1, x2, ...) being polynomials on xi\n *    LinTerm  = $c + w1*x1 + w2*x2 + ...\n *    PolyProd = $k * p1 * p2 * ...\n *    PolySum  = $c + p1 + p2 + ...\n *\n * $c is used as additive constant, $k is used as multiplicative constant.\n */\nexport type PolynomialWithBounds = PolyProd | PolySum | LinTerm\ntype LinTerm = { type: 'lin'; lin: Linear; min: number; max: number }\ntype PolyProd = {\n  type: 'prod'\n  terms: PolynomialWithBounds[]\n  $k: number\n  min: number\n  max: number\n}\ntype PolySum = {\n  type: 'sum'\n  terms: PolynomialWithBounds[]\n  $c: number\n  min: number\n  max: number\n}\n\nfunction constP(n: number): LinTerm {\n  return { type: 'lin', lin: { $c: n }, min: n, max: n }\n}\nfunction readP(k: string, minmax: MinMax): LinTerm {\n  return { type: 'lin', lin: { [k]: 1, $c: 0 }, ...minmax }\n}\nfunction sumP(...terms: (PolynomialWithBounds | number)[]): PolySum {\n  const c = (terms.filter((v) => typeof v === 'number') as number[]).reduce(\n    (a, b) => a + b,\n    0\n  )\n  const poly = terms.filter(\n    (v) => typeof v !== 'number'\n  ) as PolynomialWithBounds[]\n  return {\n    type: 'sum',\n    terms: poly,\n    $c: c,\n    min: poly.reduce((a, { min }) => a + min, c),\n    max: poly.reduce((a, { max }) => a + max, c),\n  }\n}\nfunction prodP(...terms: (PolynomialWithBounds | number)[]): PolyProd {\n  const k = (terms.filter((v) => typeof v === 'number') as number[]).reduce(\n    (a, b) => a * b,\n    1\n  )\n  const poly = terms.filter(\n    (v) => typeof v !== 'number'\n  ) as PolynomialWithBounds[]\n  const minMax = poly.reduce(\n    ({ min: min1, max: max1 }, { min: min2, max: max2 }) => {\n      return {\n        min: Math.min(min1 * min2, min1 * max2, max1 * min2, max1 * max2),\n        max: Math.max(min1 * min2, min1 * max2, max1 * min2, max1 * max2),\n      }\n    },\n    { min: k, max: k }\n  )\n  return { type: 'prod', terms: poly, $k: k, ...minMax }\n}\n\nfunction slopePoint(\n  slope: number,\n  x0: number,\n  y0: number,\n  poly: PolynomialWithBounds\n): PolynomialWithBounds {\n  return sumP(y0 - slope * x0, prodP(slope, poly))\n}\nfunction interpolate(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  poly: PolynomialWithBounds,\n  upper: boolean\n): PolynomialWithBounds {\n  if (Math.abs(x0 - x1) < 1e-10)\n    return constP(upper ? Math.max(y0, y1) : Math.min(y0, y1))\n  return slopePoint((y1 - y0) / (x1 - x0), x0, y0, poly)\n}\n\nexport function polyUB(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot\n): SumOfMonomials[] {\n  const minMaxes = new Map<OptNode, MinMax>()\n  forEachNodes(\n    nodes,\n    (f) => {\n      const { operation } = f\n      if (operation === 'mul') minMaxes.set(f, { min: NaN, max: NaN })\n      switch (operation) {\n        case 'mul':\n        case 'min':\n        case 'max':\n        case 'threshold':\n        case 'res':\n        case 'sum_frac':\n          f.operands.forEach((op) => minMaxes.set(op, { min: NaN, max: NaN }))\n      }\n    },\n    (_) => _\n  )\n  const statMinMax = computeFullArtRange(arts)\n  const nodeRanges = computeNodeRange([...minMaxes.keys()], statMinMax)\n  for (const [node, minMax] of nodeRanges.entries()) minMaxes.set(node, minMax)\n\n  const upper = 'u',\n    lower = 'l',\n    exact = 'e'\n  type Context = typeof upper | typeof lower | typeof exact\n  const poly = customMapFormula<Context, PolynomialWithBounds, OptNode>(\n    nodes,\n    upper,\n    (f, context, _map) => {\n      const { operation } = f\n      const map: (op: OptNode, c?: Context) => PolynomialWithBounds = (\n        op,\n        c = context\n      ) => _map(op, c)\n      const oppositeContext = context === upper ? lower : upper\n\n      switch (operation) {\n        case 'const':\n          return constP(f.value)\n        case 'read':\n          return readP(f.path[1], minMaxes.get(f)!)\n        case 'add':\n          return sumP(...f.operands.map((op) => map(op)))\n        case 'mul': {\n          if (context === exact)\n            return prodP(...f.operands.map((op) => map(op)))\n          const { min: minf, max: maxf } = minMaxes.get(f)!\n          if (minf === maxf) return constP(minf) // Handles zero coeff\n          const zeroCrossing =\n            minf * maxf < 0 ||\n            f.operands.some((op) => {\n              const { min, max } = minMaxes.get(op)!\n              return min * max < 0\n            })\n          if (zeroCrossing) return map(f, exact)\n\n          const signf = minf === 0 ? maxf : minf\n          const op = allOperations[operation]\n          const k = op(\n            f.operands\n              .filter((op) => op.operation === 'const')\n              .map((c) => (c as ConstantNode<number>).value)\n          )\n          const polys = f.operands\n            .filter((op) => op.operation !== 'const')\n            .map((op) => {\n              const { min, max } = minMaxes.get(op)!\n              const sign = min === 0 ? max : min\n              const ctx = signf * sign > 0 ? context : oppositeContext\n              const p = map(op, ctx)\n\n              if (\n                (ctx === lower && max > 0 && p.min < -min) ||\n                (ctx === upper && min < 0 && p.max > -max)\n              )\n                throw new PolyError(\n                  'Unallowed large crossing post approximation',\n                  operation\n                )\n\n              return p\n            })\n          return prodP(k, ...polys)\n        }\n        case 'min':\n        case 'max': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          const op = allOperations[operation]\n          const xs = f.operands.filter((op) => op.operation !== 'const'),\n            [xOp] = xs\n          if (xs.length !== 1) throw new PolyError('Multivariate', operation)\n\n          const x = map(xOp),\n            c = op(\n              f.operands\n                .filter((op) => op.operation === 'const')\n                .map((c) => (c as ConstantNode<number>).value)\n            )\n          if (\n            (operation === 'max' && context === lower) ||\n            (operation === 'min' && context === upper)\n          )\n            return x\n          const { min, max } = minMaxes.get(xOp)!,\n            yMin = op([min, c]),\n            yMax = op([max, c])\n          return interpolate(min, yMin, max, yMax, x, context === upper)\n        }\n        case 'res': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          if (context === lower)\n            throw new PolyError('Unsupported direction', operation)\n          const op = allOperations[operation]\n          const [xOp] = f.operands,\n            { min, max } = minMaxes.get(xOp)!\n          const x = map(xOp, oppositeContext)\n          // Linear region 1 - base/2 or concave region with peak at base = 0\n          if (min < 0 && max < 1.75) return sumP(1, prodP(-0.5, x))\n          // Clamp `min` to guarantee upper bound\n          else\n            return interpolate(\n              min,\n              op([min]),\n              max,\n              op([max]),\n              x,\n              context === upper\n            )\n        }\n        case 'sum_frac': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          if (context === lower)\n            throw new PolyError('Unsupported direction', operation)\n          const [xOp, cOp] = f.operands\n          if (cOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          const x = map(xOp),\n            c = cOp.value,\n            { min, max } = minMaxes.get(xOp)!\n          if (min <= -c)\n            throw new PolyError('Unallowed negative argument', operation)\n          const loc = Math.sqrt((min + c) * (max + c))\n          return slopePoint(c / (loc + c) / (loc + c), loc, loc / (loc + c), x)\n        }\n        case 'threshold': {\n          if (context === exact)\n            throw new PolyError('Cannot be exactly represented', operation)\n          const [vOp, tOp, pOp, fOp] = f.operands\n          if (tOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          const { min, max } = minMaxes.get(vOp)!\n          if (min >= tOp.value) return map(pOp)\n          if (max < tOp.value) return map(fOp)\n\n          if (fOp.operation !== 'const')\n            throw new PolyError('Non-constant node', operation)\n          if (pOp.operation !== 'const') {\n            if (fOp.value !== 0)\n              throw new PolyError('Unsupported pattern', operation)\n\n            const threshOp = threshold(vOp, tOp, 1, fOp),\n              mulOp = prod(threshOp, pOp)\n            // Populate `minMaxes` to ensure consistency\n            const { min, max } = minMaxes.get(pOp)!\n            minMaxes.set(threshOp, { min: 0, max: 1 })\n            minMaxes.set(mulOp, {\n              min: Math.min(min, 0),\n              max: Math.max(max, 0),\n            })\n            return map(mulOp)\n          }\n          const thresh = tOp.value,\n            pass = pOp.value,\n            fail = fOp.value\n          const isFirstHalf = pass > fail === (context === upper)\n\n          const v = map(vOp, isFirstHalf ? upper : lower)\n          if (isFirstHalf) {\n            const slope = (pass - fail) / (thresh - min)\n            return slopePoint(slope, thresh, pass, v)\n          }\n          // not first half -> return const(fail)\n          // Can also interpolate slopePoint on 2nd half, but I choose not to\n          return constP(fail)\n        }\n        default:\n          assertUnreachable(operation)\n      }\n    }\n  )\n\n  return poly.map((p) => expandPoly(p))\n}\n\nexport type SumOfMonomials = Monomial[]\ntype Monomial = {\n  $k: number\n  terms: string[]\n}\nfunction constM(v: number): Monomial {\n  return { $k: v, terms: [] }\n}\nfunction weightedReadM(key: string, v: number): Monomial {\n  return { $k: v, terms: [key] }\n}\nfunction sumM(...monomials: Monomial[][]): Monomial[] {\n  return monomials.flat()\n}\nfunction prodM(...monomials: Monomial[][]): Monomial[] {\n  return cartesian(...monomials).map((monos) =>\n    monos.reduce(\n      (ret, nxt) => {\n        ret.$k *= nxt.$k\n        ret.terms.push(...nxt.terms)\n        return ret\n      },\n      { $k: 1, terms: [] }\n    )\n  )\n}\nfunction foldLikeTerms(mon: Monomial[]): Monomial[] {\n  mon.forEach((m) => m.terms.sort())\n  mon.sort(({ terms: termsA }, { terms: termsB }) => {\n    if (termsA.length !== termsB.length) return termsA.length - termsB.length\n    for (let i = 0; i < termsA.length; i++) {\n      if (termsA[i] !== termsB[i]) return termsA[i] < termsB[i] ? -1 : +1\n    }\n    return 0\n  })\n\n  for (let i = mon.length - 2; i >= 0; i--) {\n    if (mon[i].$k === 0) {\n      mon.splice(i, 1)\n      continue\n    }\n    const a = mon[i].terms\n    const b = mon[i + 1].terms\n    if (a.length !== b.length) continue\n    if (a.every((ai, i) => ai === b[i])) {\n      mon[i].$k = mon[i].$k + mon[i + 1].$k\n      mon.splice(i + 1, 1)\n    }\n  }\n  return mon\n}\nfunction expandPoly(node: PolynomialWithBounds): SumOfMonomials {\n  function toExpandedPoly(n: PolynomialWithBounds): Monomial[] {\n    switch (n.type) {\n      case 'lin':\n        return Object.entries(n.lin)\n          .filter(([_, v]) => v !== 0)\n          .map(([k, v]) => {\n            if (k === '$c') return constM(v)\n            return weightedReadM(k, v)\n          })\n      case 'sum':\n        return sumM(...n.terms.map((t) => toExpandedPoly(t)), [constM(n.$c)])\n      case 'prod':\n        return prodM(...n.terms.map((t) => toExpandedPoly(t)), [constM(n.$k)])\n    }\n  }\n\n  return foldLikeTerms(toExpandedPoly(node))\n}\n\nclass PolyError extends Error {\n  constructor(cause: string, operation: string) {\n    super(\n      `Found ${cause} in ${operation} node when generating polynomial upper bound`\n    )\n  }\n}\n","// Matrix convention is row-major, indexed A_{ij} = A[i][j]\ntype Pivot = { i: number; j: number }\nconst zero = 1e-8 // Small number equivalent to 0 for numerical instability\n\n/** Checks that all constraints are satisfied (Ax <= b) */\nexport function isFeasible(Ab: number[][], x: number[]): boolean {\n  const b = x.length\n  return Ab.every(\n    (row) => x.reduce((tot, xi, i) => tot + xi * row[i], 0) <= row[b] + zero\n  )\n}\n\n/**\n * Solve a Linear Program defined by:\n *              min  c^T x\n *               x\n *   Subject to:     Ax <= b\n *                    x >= 0\n *\n * Implemented according to the Simplex Method (Sec 4) of:\n *   Ferguson, https://www.math.ucla.edu/~tom/LP.pdf\n *\n * Does not implement any cycle detection, though that *shouldnt* be a problem for GO's use\n *   case. This algorithm will always return a feasible solution, though it may be suboptimal.\n *\n * @param c        Objective vector\n * @param Ab       Constraints matrix with thresholds. Inputted in block form [A, b]\n * @returns        a valid solution x, optimal if everything went well.\n */\nexport function solveLP(c: number[], Ab: number[][]) {\n  const rows = Ab.length + 1\n  const cols = Ab[0].length\n\n  const tableau = Array(rows)\n    .fill(0)\n    .map((_) => Array(cols).fill(0))\n  Ab.forEach((Ai, i) => Ai.forEach((Aij, j) => (tableau[i][j] = Aij)))\n  c.forEach((cj, j) => (tableau[rows - 1][j] = cj))\n\n  const pivotHistory: Pivot[] = [] // Keep track of all chosen pivots for backtracking later\n\n  while (tableau.some((t, i) => i < rows - 1 && t[cols - 1] < -zero)) {\n    const piv = findPiv2(tableau)\n    pivotHistory.push(piv)\n    pivotInplace(tableau, piv)\n  }\n\n  while (tableau[rows - 1].some((t, j) => j < cols - 1 && t < -zero)) {\n    const piv = findPiv1(tableau)\n    pivotHistory.push(piv)\n    pivotInplace(tableau, piv)\n  }\n\n  const xOpt = c.map((_, i) => backtrack(tableau, pivotHistory, i))\n  if (!isFeasible(Ab, xOpt)) throw Error('COMPUTED SOLUTION IS NOT FEASIBLE')\n  return xOpt\n}\n\n/** Standard `pivot` operation on LPs */\nfunction pivotInplace(A: number[][], { i, j }: Pivot) {\n  const Aij = A[i][j]\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    for (let k = 0; k < A[0].length; k++) {\n      if (k === j) continue\n      A[h][k] -= (A[i][k] * A[h][j]) / Aij\n    }\n  }\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    A[h][j] = -A[h][j] / Aij\n  }\n  for (let k = 0; k < A[0].length; k++) {\n    if (k === j) continue\n    A[i][k] = A[i][k] / Aij\n  }\n  A[i][j] = 1 / Aij\n}\n\n/** Find a pivot according to Case 1 (Ferguson p23) */\nfunction findPiv1(A: number[][]) {\n  const r = A.length,\n    c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let j = 0; j < c - 1; j++) {\n    if (A[r - 1][j] >= -zero) continue\n    for (let i = 0; i < r - 1; i++) {\n      if (A[i][j] > zero) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('UNBOUNDED FEASIBLE')\n  }\n  if (minloc.i < 0) throw Error('NO PIVOTS (done)')\n  return { i: minloc.i, j: minloc.j }\n}\n\n/** Find a pivot according to Case 2 (Ferguson p24) */\nfunction findPiv2(A: number[][]) {\n  const r = A.length,\n    c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let i = 0; i < r - 1; i++) {\n    if (A[i][c - 1] >= -zero) continue\n    for (let j = 0; j < c - 1; j++) {\n      if (A[i][j] < -zero) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('INFEASIBLE')\n    return { i: minloc.i, j: minloc.j }\n  }\n  throw Error('NO PIVOTS (done)')\n}\n\n/** Backtracking algorithm to find solution vector */\nfunction backtrack(tableau: number[][], pivotHistory: Pivot[], targ: number) {\n  let side = 1 // 0 left, 1 right\n  pivotHistory.forEach(({ i, j }) => {\n    if (side === 1 && j === targ) {\n      targ = i\n      side = 0\n    } else if (side === 0 && i === targ) {\n      targ = j\n      side = 1\n    }\n  })\n\n  const ncol = tableau[0].length\n  return side === 0 ? tableau[targ][ncol - 1] : 0\n}\n","import type { OptNode } from '../../Formula/optimization'\nimport { assertUnreachable, cartesian } from '../../Util/Util'\nimport type { ArtifactsBySlot, DynStat, MinMax } from '../common'\nimport { computeFullArtRange } from '../common'\nimport { polyUB } from './polyUB'\nimport { solveLP } from './solveLP'\n\nexport type Linear = DynStat & { $c: number }\n\nfunction weightedSum(\n  ...entries: readonly (readonly [number, Linear])[]\n): Linear {\n  const result = { $c: 0 }\n  for (const [weight, entry] of entries)\n    for (const [k, v] of Object.entries(entry))\n      result[k] = (result[k] ?? 0) + weight * v\n  return result\n}\n\nexport function linearUB(nodes: OptNode[], arts: ArtifactsBySlot): Linear[] {\n  const polys = polyUB(nodes, arts)\n  const minMax = computeFullArtRange(arts)\n\n  return polys.map((poly) =>\n    weightedSum(\n      ...poly.map((mon) => {\n        const bounds = mon.terms.map((key) => minMax[key])\n        const { w, $c } = linbound(bounds, mon.$k >= 0 ? 'upper' : 'lower')\n        const linboi: Linear = { $c }\n        mon.terms.forEach((key, i) => (linboi[key] = w[i] + (linboi[key] ?? 0)))\n        return [mon.$k, linboi] as readonly [number, Linear]\n      })\n    )\n  )\n}\n\n/**\n * Constructs a linear upper/lower bound for a monomial on a bounded domain using an LP.\n *\n * Monomial is assumed to be\n *    m(x) = x1 * x2 * ... * xn\n * on bounded domain\n *    min_1 <= x1 <= max_1\n *    min_2 <= x2 <= max_2\n *    ...\n *    min_n <= xn <= max_n\n *\n * @param bounds List of min & max bounds for each xi\n * @returns A linear function L(x) = w . x + $c\n *            satisfying      m(x) <= L(x) <= m(x) + err (resp. m(x) - err <= L(x) <= m(x))\n */\nfunction linbound(\n  bounds: MinMax[],\n  direction: 'upper' | 'lower' = 'upper'\n): { w: number[]; $c: number; err: number } {\n  if (bounds.length === 0) return { w: [], $c: 1, err: 0 } // vacuous product is 0\n  const nVar = bounds.length\n\n  // Re-scale bounds to [-1, 1] for numerical stability.\n  const boundScale = bounds.map(({ min, max }) => Math.max(-min, max))\n  if (boundScale.some((bnd) => bnd === 0)) {\n    return { w: bounds.map((_) => 0), $c: 0, err: 0 }\n  }\n  const scaleProd = boundScale.reduce((prod, v) => prod * v, 1)\n  bounds = bounds.map(({ min, max }, i) => ({\n    min: min / boundScale[i],\n    max: max / boundScale[i],\n  }))\n  // Setting up the linear program in terms of constraints.\n  //   cartesian(bounds) loops 2^nVar times\n  const cons = cartesian(...bounds.map(({ min, max }) => [min, max])).flatMap(\n    (coords) => {\n      const prod = coords.reduce((prod, v) => prod * v, 1)\n      const sum = coords.reduce((sum, v) => sum + v, 0)\n      switch (direction) {\n        case 'upper':\n          return [\n            [...coords, -1, 0, sum - prod - nVar],\n            [...coords.map((v) => -v), 1, -1, nVar + prod - sum],\n          ]\n        case 'lower':\n          return [\n            [...coords.map((v) => -v), -1, 0, prod - sum - nVar],\n            [...coords, 1, -1, nVar + sum - prod],\n          ]\n        default:\n          assertUnreachable(direction)\n      }\n    }\n  )\n\n  const objective = [...bounds.map((_) => 0), 0, 1]\n  try {\n    const soln = solveLP(objective, cons)\n    switch (direction) {\n      case 'upper':\n        return {\n          w: soln\n            .slice(0, nVar)\n            .map((wi, i) => ((1 - wi) * scaleProd) / boundScale[i]),\n          $c: scaleProd * (soln[nVar] - nVar),\n          err: scaleProd * soln[nVar + 1],\n        }\n      case 'lower':\n        return {\n          w: soln\n            .slice(0, nVar)\n            .map((wi, i) => ((1 - wi) * scaleProd) / boundScale[i]),\n          $c: scaleProd * (nVar - soln[nVar]),\n          err: scaleProd * soln[nVar + 1],\n        }\n      default:\n        assertUnreachable(direction)\n    }\n  } catch (e) {\n    console.log('ERROR on bounds', bounds)\n    console.log('Possibly numerical instability issue.')\n    console.log(e)\n    throw e\n  }\n}\n","import type { ArtifactSetKey } from '@genshin-optimizer/consts'\nimport { allArtifactSlotKeys } from '@genshin-optimizer/consts'\nimport {\n  computeFullArtRange,\n  type ArtifactsBySlot,\n  countBuilds,\n  type ArtifactBuildData,\n} from '../common'\nimport { cartesian, objectKeyMap } from '../../Util/Util'\nimport type { Linear } from './linearUB'\n\n/**\n * Heuristically picks splitting key based on minimizing the approximation error.\n *\n * Computing approximation error is difficult, so we use this scuffed guesstimate is:\n *   \\sqrt[ \\sum ((u_i - l_i) * w_i)^2 ]\n */\nexport function pickSplitKey(\n  appxs: Linear[],\n  arts: ArtifactsBySlot\n): { splitOn: string; splitVal: number } {\n  const minMax = computeFullArtRange(arts)\n\n  const allKeys = [\n    ...new Set(\n      appxs.flatMap((appx) => Object.keys(appx).filter((k) => k !== '$c'))\n    ),\n  ]\n\n  const { bestKey } = allKeys.reduce(\n    ({ bestKey, minHeur }, stat) => {\n      const { min, max } = minMax[stat]\n      const oldHeur = appxs.reduce(\n        (h, lin) => h + ((max - min) * (lin[stat] ?? 0)) ** 2,\n        0\n      )\n\n      const { lowerRange, upperRange } = allArtifactSlotKeys.reduce(\n        ({ lowerRange, upperRange }, slot) => {\n          const vals = arts.values[slot].map((art) => art.values[stat])\n          const minv = Math.min(...vals),\n            maxv = Math.max(...vals),\n            mid = (minv + maxv) / 2,\n            glb = Math.max(...vals.filter((v) => v <= mid)),\n            lub = Math.min(...vals.filter((v) => v >= mid))\n          // Heuristic could be improved by tracking lowerRange & upperRange for all stats.\n          return {\n            lowerRange: lowerRange + (glb - minv),\n            upperRange: upperRange + (maxv - lub),\n          }\n        },\n        { lowerRange: 0, upperRange: 0 }\n      )\n      const newHeur =\n        appxs.reduce(\n          (h, lin) =>\n            h +\n            (lowerRange * (lin[stat] ?? 0)) ** 2 +\n            (upperRange * (lin[stat] ?? 0)) ** 2,\n          0\n        ) / 2\n\n      const heur = newHeur - oldHeur\n      if (heur < minHeur) return { bestKey: stat, minHeur: heur }\n      return { bestKey, minHeur }\n    },\n    { bestKey: '', minHeur: Infinity }\n  )\n\n  // Pick key that gives minimum heur (maximum reduction old -> new)\n  return {\n    splitOn: bestKey,\n    splitVal: (minMax[bestKey].min + minMax[bestKey].max) / 2,\n  }\n}\n\n/** Splits a filter based on the set key into 32 chunks. */\nexport function splitOnSet(\n  setKey: ArtifactSetKey,\n  arts: ArtifactsBySlot\n): ArtifactsBySlot[] {\n  return splitArts(arts, (arts) => arts.map((art) => art.set === setKey))\n}\n\n/**\n * Splits `arts` into 32 chunks such that the total `stat` of min split is below `threshold`, and that the max\n * split is above.\n */\nexport function splitAtValue(\n  stat: string,\n  threshold: number,\n  arts: ArtifactsBySlot\n): ArtifactsBySlot[] {\n  threshold -= arts.base[stat]\n  const valsBySlot = allArtifactSlotKeys.map((slot) =>\n    arts.values[slot]\n      .map((art) => ({ art, val: art.values[stat] }))\n      .sort((a, b) => a.val - b.val)\n  )\n  const mins = valsBySlot.map(([first]) => first.val)\n  const ranges = valsBySlot.map(\n    (arts) => arts[arts.length - 1].val - arts[0].val\n  )\n  const totalRange = ranges.reduce((a, b) => a + b)\n  const cutoff =\n    (threshold - mins.reduce((a, b) => a + b)) / Math.max(totalRange, 1e-9)\n  const split = valsBySlot.map((arts, slot) => {\n    const splitVal = mins[slot] + cutoff * ranges[slot]\n    let start = 0,\n      end = arts.length\n    while (start !== end) {\n      const mid = Math.floor((start + end) / 2)\n      if (splitVal > arts[mid].val) start = mid + 1\n      else end = mid\n    }\n    return end\n  })\n\n  return splitArts(arts, (arts, si) => {\n    const upper = new Set(valsBySlot[si].slice(split[si]).map((a) => a.art))\n    return arts.map((art) => upper.has(art))\n  })\n}\n\nfunction splitArts(\n  { base, values }: ArtifactsBySlot,\n  predicate: (arts: ArtifactBuildData[], slotIndex: number) => boolean[]\n): ArtifactsBySlot[] {\n  const partition = allArtifactSlotKeys.map((slot, si) => {\n    const arts = values[slot]\n    const group = predicate(arts, si)\n    return [\n      arts.filter((_, i) => group[i]),\n      arts.filter((_, i) => !group[i]),\n    ].filter((a) => a.length)\n  })\n  return cartesian(...partition)\n    .map((partition) => ({\n      base,\n      values: objectKeyMap(allArtifactSlotKeys, (_, i) => partition[i]),\n    }))\n    .sort((a, b) => countBuilds(b) - countBuilds(a))\n}\n","import type { Interim, Setup } from '..'\nimport { optimize, type OptNode } from '../../Formula/optimization'\nimport type { ArtifactSetKey, ArtifactSlotKey } from '@genshin-optimizer/consts'\nimport { allArtifactSetKeys } from '@genshin-optimizer/consts'\nimport { objectKeyValueMap, objectMap } from '../../Util/Util'\nimport type {\n  ArtifactBuildData,\n  ArtifactsBySlot,\n  DynStat,\n  RequestFilter,\n} from '../common'\nimport { countBuilds, filterArts, pruneAll } from '../common'\nimport type { SplitWorker } from './BackgroundWorker'\nimport type { Linear } from './linearUB'\nimport { linearUB } from './linearUB'\nimport { pickSplitKey, splitOnSet, splitAtValue } from './heuristicSplitting'\n\ntype Approximation = {\n  base: number\n  /** optimization target contribution from a given artifact (id) */\n  conts: StrictDict<string, number>\n}\ntype Filter = {\n  nodes: OptNode[]\n  lins: Linear[]\n  arts: ArtifactsBySlot\n  /**\n   * The contribution of each artifact to the optimization target. The (over)estimated\n   * optimization target value is the sum of contributions of all artifacts in the build.\n   */\n  approxs: Approximation[]\n  maxConts: Record<ArtifactSlotKey, number>[]\n  /** Total number of builds in this filter */\n  count: number\n  /** Whether or not this filter is in a valid (calculated) state */\n  calculated?: boolean\n}\nexport class BNBSplitWorker implements SplitWorker {\n  min: number[]\n  nodes: OptNode[]\n  arts: ArtifactsBySlot\n  topN: number\n\n  /**\n   * Filters are not neccessarily in a valid state, i.e., \"calculated\".\n   * We amortize the calculation to 1-per-split so that the calculation\n   * overhead doesn't lead to lag.\n   */\n  filters: Filter[] = []\n  interim: Interim | undefined\n  firstUncalculated = 0\n\n  callback: (interim: Interim) => void\n\n  constructor(\n    { arts, optTarget, constraints, topN }: Setup,\n    callback: (interim: Interim) => void\n  ) {\n    this.arts = arts\n    this.min = [-Infinity, ...constraints.map((x) => x.min)]\n    this.nodes = [optTarget, ...constraints.map((x) => x.value)]\n    this.callback = callback\n    this.topN = topN\n\n    // make sure we can approximate it\n    linearUB(this.nodes, arts)\n  }\n\n  addFilter(filter: RequestFilter): void {\n    const arts = filterArts(this.arts, filter),\n      count = countBuilds(arts)\n    if (count)\n      this.filters.push({\n        nodes: this.nodes,\n        arts,\n        maxConts: [],\n        lins: [],\n        approxs: [],\n        count,\n      })\n  }\n  setThreshold(newThreshold: number): void {\n    if (newThreshold > this.min[0]) {\n      this.min[0] = newThreshold\n      // All calculations become stale\n      this.firstUncalculated = 0\n      this.filters.forEach((filter) => delete filter.calculated)\n    }\n  }\n  *split(filter: RequestFilter, minCount: number): Generator<RequestFilter> {\n    this.addFilter(filter)\n\n    while (this.filters.length) {\n      const filter = this.getApproxFilter(),\n        { arts, count } = filter\n\n      if (count <= minCount || Object.keys(arts.base).length === 0) {\n        if (!count) continue\n        if (this.firstUncalculated < this.filters.length)\n          this.calculateFilter(this.firstUncalculated++) // Amortize the filter calculation to 1-per-split\n\n        this.reportInterim(false)\n        yield objectMap(arts.values, (arts) => ({\n          kind: 'id' as const,\n          ids: new Set(arts.map((art) => art.id)),\n        }))\n      } else this.splitOldFilter(filter)\n    }\n\n    this.reportInterim(true)\n  }\n\n  reportInterim(forced = false) {\n    if (this.interim && (this.interim.skipped > 1000000 || forced === true)) {\n      this.callback(this.interim)\n      this.interim = undefined\n    }\n  }\n\n  splitOldFilter(filter: Filter) {\n    const { nodes, arts, lins } = filter\n    if (countBuilds(arts) === 0) return\n\n    const { splitOn, splitVal } = pickSplitKey(lins, arts)\n    const newFilters = allArtifactSetKeys.includes(splitOn as any)\n      ? splitOnSet(splitOn as ArtifactSetKey, arts)\n      : splitAtValue(splitOn, splitVal, arts)\n\n    for (const arts of newFilters) {\n      const count = countBuilds(arts)\n      this.filters.push({\n        nodes,\n        arts,\n        maxConts: [],\n        lins: [],\n        approxs: [],\n        count,\n      })\n    }\n  }\n\n  /** *Precondition*: `this.filters` must not be empty */\n  getApproxFilter(): Filter {\n    this.calculateFilter(this.filters.length - 1)\n    if (this.firstUncalculated > this.filters.length)\n      this.firstUncalculated = this.filters.length\n    return this.filters.pop()!\n  }\n  /** Update calculate on filter at index `i` if not done so already */\n  calculateFilter(i: number): void {\n    let { nodes, arts, maxConts, lins, approxs } = this.filters[i]\n    const { count: oldCount, calculated } = this.filters[i]\n    if (calculated) return\n    ;({ nodes, arts } = pruneAll(\n      nodes,\n      this.min,\n      arts,\n      this.topN,\n      {},\n      { pruneNodeRange: true }\n    ))\n    nodes = optimize(nodes, {}, (_) => false)\n    if (Object.values(arts.values).every((x) => x.length)) {\n      ;({ lins, approxs } = approximation(nodes, arts))\n      maxConts = approxs.map((approx) =>\n        objectMap(arts.values, (val) => maxContribution(val, approx))\n      )\n    }\n    // Removing artifacts that doesn't meet the required opt target contributions.\n    //\n    // We could actually loop `newValues` computation if the removed artifacts have\n    // the highest contribution in one of the target node as the removal will raise\n    // the required contribution even further. However, once is generally enough.\n    const leadingConts = maxConts.map((cont, i) =>\n      Object.values(cont).reduce(\n        (accu, val) => accu + val,\n        approxs[i].base - this.min[i]\n      )\n    )\n    const newValues = objectMap(arts.values, (arts, slot) => {\n      const requiredConts = leadingConts.map((lc, i) => maxConts[i][slot] - lc)\n      return arts.filter(({ id }) =>\n        approxs.every(({ conts }, i) => conts[id] >= requiredConts[i])\n      )\n    })\n    arts = { base: arts.base, values: newValues }\n    const newCount = countBuilds(arts)\n    if (newCount !== oldCount)\n      if (this.interim) this.interim.skipped += oldCount - newCount\n      else\n        this.interim = {\n          resultType: 'interim',\n          buildValues: undefined,\n          tested: 0,\n          failed: 0,\n          skipped: oldCount - newCount,\n        }\n    this.filters[i] = {\n      nodes,\n      arts,\n      maxConts,\n      lins,\n      approxs,\n      count: newCount,\n      calculated: true,\n    }\n  }\n}\n\nfunction maxContribution(\n  arts: ArtifactBuildData[],\n  approximation: Approximation\n): number {\n  return Math.max(...arts.map(({ id }) => approximation.conts[id]!))\n}\nfunction approximation(\n  nodes: OptNode[],\n  arts: ArtifactsBySlot\n): { lins: Linear[]; approxs: Approximation[] } {\n  const lins = linearUB(nodes, arts)\n  return {\n    lins,\n    approxs: lins.map((weight) => ({\n      base: dot(arts.base, weight, weight.$c),\n      conts: objectKeyValueMap(Object.values(arts.values).flat(), (data) => [\n        data.id,\n        dot(data.values, weight, 0),\n      ]),\n    })),\n  }\n}\nfunction dot(values: DynStat, lin: DynStat, c: number): number {\n  return Object.entries(values).reduce(\n    (accu, [k, v]) => accu + (lin[k] ?? 0) * v,\n    c\n  )\n}\n","import type { Interim, Setup } from '..'\nimport type { OptNode } from '../../Formula/optimization'\nimport { optimize, precompute } from '../../Formula/optimization'\nimport type {\n  ArtifactBuildData,\n  ArtifactsBySlot,\n  Build,\n  PlotData,\n  RequestFilter,\n} from '../common'\nimport { countBuilds, filterArts, mergePlot, pruneAll } from '../common'\n\nexport class ComputeWorker {\n  builds: Build[] = []\n  buildValues: number[] | undefined = undefined\n  plotData: PlotData | undefined\n  threshold = -Infinity\n  topN: number\n  min: number[]\n\n  arts: ArtifactsBySlot\n  nodes: OptNode[]\n\n  callback: (interim: Interim) => void\n\n  constructor(\n    { arts, optTarget, constraints, plotBase, topN }: Setup,\n    callback: (interim: Interim) => void\n  ) {\n    this.arts = arts\n    this.min = constraints.map((x) => x.min)\n    this.topN = topN\n    this.callback = callback\n    this.nodes = constraints.map((x) => x.value)\n    this.nodes.push(optTarget)\n    if (plotBase) {\n      this.plotData = {}\n      this.nodes.push(plotBase)\n    }\n    this.nodes = optimize(this.nodes, {}, (_) => false)\n  }\n\n  setThreshold(newThreshold: number) {\n    if (this.threshold > newThreshold) this.threshold = newThreshold\n  }\n  compute(filter: RequestFilter) {\n    const { min } = this\n    let preArts = filterArts(this.arts, filter)\n    const totalCount = countBuilds(preArts),\n      oldMaxBuildCount = this.builds.length\n\n    let nodes = this.nodes\n    ;({ nodes, arts: preArts } = pruneAll(\n      nodes,\n      min,\n      preArts,\n      this.topN,\n      {},\n      {\n        pruneArtRange: true,\n        pruneNodeRange: true,\n      }\n    ))\n    const arts = Object.values(preArts.values).sort(\n      (a, b) => a.length - b.length\n    )\n    const compute = precompute(\n      nodes,\n      preArts.base,\n      (f) => f.path[1],\n      arts.length\n    )\n\n    const buffer = Array<ArtifactBuildData>(arts.length)\n    const count = {\n      tested: 0,\n      failed: 0,\n      skipped: totalCount - countBuilds(preArts),\n    }\n\n    const permute = (i: number) => {\n      if (i < 0) {\n        const result = compute(buffer)\n        if (min.every((m, i) => m <= result[i])) {\n          const value = result[min.length],\n            { builds, plotData } = this\n          let build: Build | undefined\n          if (value >= this.threshold) {\n            build = {\n              value,\n              artifactIds: buffer.map((x) => x.id).filter((id) => id),\n            }\n            builds.push(build)\n          }\n          if (plotData) {\n            const x = result[min.length + 1]\n            if (!plotData[x] || plotData[x]!.value < value) {\n              if (!build)\n                build = {\n                  value,\n                  artifactIds: buffer.map((x) => x.id).filter((id) => id),\n                }\n              build.plot = x\n              plotData[x] = build\n            }\n          }\n        } else count.failed += 1\n        return\n      }\n      arts[i].forEach((art) => {\n        buffer[i] = art\n        permute(i - 1)\n      })\n      if (i === 0) {\n        count.tested += arts[0].length\n        if (count.tested > 1 << 16) this.interimReport(count)\n      }\n    }\n\n    permute(arts.length - 1)\n    this.interimReport(count, this.builds.length > oldMaxBuildCount)\n  }\n\n  refresh(force: boolean): void {\n    const { topN } = this\n    if (Object.keys(this.plotData ?? {}).length >= 100000)\n      this.plotData = mergePlot([this.plotData!])\n\n    if (this.builds.length >= 1000 || force) {\n      this.builds = this.builds.sort((a, b) => b.value - a.value).slice(0, topN)\n      this.buildValues = this.builds.map((x) => x.value)\n      this.threshold = Math.max(\n        this.threshold,\n        this.buildValues[topN - 1] ?? -Infinity\n      )\n    }\n  }\n  interimReport(\n    count: { tested: number; failed: number; skipped: number },\n    forced = false\n  ) {\n    this.refresh(forced)\n    this.callback({\n      resultType: 'interim',\n      buildValues: this.buildValues,\n      ...count,\n    })\n    this.buildValues = undefined\n    count.tested = 0\n    count.failed = 0\n    count.skipped = 0\n  }\n}\n","import { allArtifactSlotKeys } from '@genshin-optimizer/consts'\nimport type { Interim, Setup } from '..'\nimport { assertUnreachable } from '../../Util/Util'\nimport type { ArtifactsBySlot, RequestFilter } from '../common'\nimport { countBuilds, filterArts } from '../common'\nimport type { SplitWorker } from './BackgroundWorker'\n\nexport class DefaultSplitWorker implements SplitWorker {\n  arts: ArtifactsBySlot\n  stack: { filter: RequestFilter; count: number; splittedBy: 'id' | 'set' }[] =\n    []\n\n  constructor({ arts }: Setup, _callback: (interim: Interim) => void) {\n    this.arts = arts\n  }\n\n  setThreshold(_newThreshold: number): void {}\n  add(\n    filter: RequestFilter,\n    splittedBy: (typeof this.stack)[number]['splittedBy']\n  ) {\n    this.stack.push({\n      filter,\n      count: countBuilds(filterArts(this.arts, filter)),\n      splittedBy,\n    })\n  }\n  *split(filter: RequestFilter, minCount: number): Generator<RequestFilter> {\n    this.add(filter, 'set')\n    for (let current = this.stack.pop(); current; current = this.stack.pop()) {\n      const { filter, count, splittedBy } = current\n      if (count <= minCount) {\n        yield filter\n        continue\n      }\n\n      switch (splittedBy) {\n        case 'set':\n          this.splitBySet(filter)\n          break\n        case 'id':\n          this.splitByID(filter, count, minCount)\n          break\n        default:\n          assertUnreachable(splittedBy)\n      }\n    }\n  }\n\n  splitBySet(filter: RequestFilter): void {\n    const arts = filterArts(this.arts, filter)\n    const candidates = allArtifactSlotKeys\n      .map((slot) => ({\n        slot,\n        sets: new Set(arts.values[slot].map((x) => x.set)),\n      }))\n      .filter(({ sets }) => sets.size > 1)\n\n    if (!candidates.length) return this.add(filter, 'id')\n\n    const { sets, slot } = candidates.reduce((a, b) =>\n      a.sets.size < b.sets.size ? a : b\n    )\n    sets.forEach((set) =>\n      this.add(\n        { ...filter, [slot]: { kind: 'required', sets: new Set([set]) } },\n        'set'\n      )\n    )\n  }\n  splitByID(filter: RequestFilter, count: number, minCount: number): void {\n    const arts = filterArts(this.arts, filter)\n    const { slot, length } = allArtifactSlotKeys\n      .map((slot) => ({ slot, length: arts.values[slot].length }))\n      .filter((x) => x.length > 1)\n      // We always have entries because `count > 1`\n      .reduce((a, b) => (a.length < b.length ? a : b))\n\n    const numChunks = Math.ceil(count / minCount)\n    const boundedNumChunks = Math.min(numChunks, length)\n    const chunk = Array(boundedNumChunks)\n      .fill(0)\n      .map((_) => new Set<string>())\n    arts.values[slot].forEach(({ id }, i) =>\n      chunk[i % boundedNumChunks].add(id)\n    )\n    chunk.forEach((ids) =>\n      this.add({ ...filter, [slot]: { kind: 'id', ids } }, 'id')\n    )\n  }\n}\n","import type { WorkerCommand, WorkerResult } from '..'\nimport { assertUnreachable } from '../../Util/Util'\nimport type { RequestFilter } from '../common'\nimport {\n  artSetPerm,\n  countBuilds,\n  filterArts,\n  filterFeasiblePerm,\n} from '../common'\nimport { BNBSplitWorker } from './BNBSplitWorker'\nimport { ComputeWorker } from './ComputeWorker'\nimport { DefaultSplitWorker } from './DefaultSplitWorker'\n\ndeclare function postMessage(command: WorkerCommand | WorkerResult): void\n\nlet splitWorker: SplitWorker, computeWorker: ComputeWorker\n\nasync function handleEvent(e: MessageEvent<WorkerCommand>): Promise<void> {\n  const { data } = e,\n    { command } = data\n  switch (command) {\n    case 'split':\n      for (const filter of splitWorker.split(\n        data.filter,\n        data.maxIterateSize\n      )) {\n        postMessage({ command: 'iterate', filter })\n        // Suspend here in case a `threshold` is sent over\n        //\n        // Make sure to use task-based mechanisms such as `setTimeout` so that\n        // this function suspends until the next event loop. If we instead use\n        // microtask-based ones such as `Promise.resolved`, the suspension will\n        // not be long enough.\n        await new Promise((r) => setTimeout(r))\n      }\n      break\n    case 'iterate':\n      computeWorker.compute(data.filter)\n      break\n    case 'threshold': {\n      splitWorker.setThreshold(data.threshold)\n      computeWorker.setThreshold(data.threshold)\n      return // This is a fire-and-forget command\n    }\n    case 'finalize': {\n      computeWorker.refresh(true)\n      const { builds, plotData } = computeWorker\n      postMessage({ resultType: 'finalize', builds, plotData })\n      break\n    }\n    case 'count': {\n      const { exclusion, maxIterateSize } = data,\n        arts = computeWorker.arts\n      const perms = filterFeasiblePerm(\n        artSetPerm(exclusion, [\n          ...new Set(\n            Object.values(arts.values).flatMap((x) => x.map((x) => x.set!))\n          ),\n        ]),\n        arts\n      )\n      let count = 0\n      for (const filter of perms) {\n        postMessage({ command: 'split', filter, maxIterateSize })\n        count += countBuilds(filterArts(arts, filter))\n      }\n      postMessage({ resultType: 'count', count })\n      break\n    }\n    case 'setup':\n      try {\n        splitWorker = new BNBSplitWorker(data, (x) => postMessage(x))\n      } catch {\n        splitWorker = new DefaultSplitWorker(data, (x) => postMessage(x))\n      }\n      computeWorker = new ComputeWorker(data, (x) => postMessage(x))\n      break\n    default:\n      assertUnreachable(command)\n  }\n  postMessage({ resultType: 'done' })\n}\nonmessage = async (e: MessageEvent<WorkerCommand>) => {\n  try {\n    await handleEvent(e)\n  } catch (e) {\n    postMessage({ resultType: 'err', message: (e as any).message })\n  }\n}\n\nexport interface SplitWorker {\n  split(filter: RequestFilter, minCount: number): Iterable<RequestFilter>\n  setThreshold(newThreshold: number): void\n}\n"],"names":["objPathValue","obj","keys","Array","isArray","console","error","reduce","a","k","objectKeyMap","map","Object","fromEntries","i","objectKeyValueMap","items","t","objectMap","fn","entries","v","rangeGen","from","to","range","assertUnreachable","value","Error","cartesian","q","b","flatMap","d","e","flat","constant","NaN","name","percent","info","operation","operands","type","Number","MAX_VALUE","Infinity","unit","sum","values","intoOps","dynRead","accu","path","intoV","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","forEach","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","arrayEqual","set","result","customMapFormula","context","contextMapping","internalMap","current","mapping","old","newFormula","undefined","length","every","allCommutativeMonoidOperations","min","x","Math","max","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","optimize","topLevelData","shouldFold","_formula","opts","constantFold","flatten","deduplicate","f","flattened","dep","arrayCompare","cmp","cc","nodeHeightMap","layers","cmpNode","n1","n2","h1","h2","op1","op2","localeCompare","s1","s2","op","nodeSortMap","sort","_","n","push","h","ix","sortedNodes","layer","origin","data","processed","nextContextMap","fold","c","foldStr","numericOperands","formulaOperands","filter","folded","numericValue","isFinite","index","selected","table","first","find","smallest","operand","v1","v2","match","unmatch","list","reset","nextMap","nextContext","nonTravelerCharacterKeys","allTravelerKeys","allArtifactSetKeys","allArtifactSlotKeys","allWeaponSwordKeys","allWeaponClaymoreKeys","allWeaponPolearmKeys","allWeaponBowKeys","allWeaponCatalystKeys","allSlotKeys","travelerKeys","pruneAll","nodes","minimum","arts","numTop","exclusion","forced","should","deps","pruneNodeRange","reaffine","pruneOrder","pruneArtRange","count","some","newArts","newNodes","forceRename","affineNodes","topLevelAffine","visit","node","isAffine","dynKeys","affineOps","nonAffineOps","affine","nonConst","base","size","nextDynKey","affineMap","reaffineArt","stat","dyn","slot","id","offsets","key","baseValue","progress","allowRainbow","rainbow","noSwitchIn","noSwitchOut","includes","newList","art","other","otherBetterEqual","otherMaybeBetter","otherBetter","canSwitch","baseRange","wrap","artRanges","computeArtRange","otherArtRanges","addArtRange","read","newRange","computeNodeRange","nodeRange","operandRanges","newOperands","ranges","computeFullArtRange","reads","computeMinMax","minMaxes","filterArts","filters","kind","ids","sets","countBuilds","_count","exclusionToAllowed","artSetPerm","_artSets","artSets","allowedRainbows","shapes","indexOfShape","shape","replacing","populateShapes","rainbows","j","required","slice","remaining","noFilter","counts","allowedCounts","used","groupped","usableRainbows","check_free","isolated","missing","rejected","allowedSet","requiredRainbows","l","constP","lin","$c","sumP","terms","poly","prodP","minMax","min1","max1","min2","max2","$k","slopePoint","slope","x0","y0","interpolate","x1","y1","upper","abs","polyUB","statMinMax","nodeRanges","lower","exact","_map","oppositeContext","minmax","minf","maxf","zeroCrossing","signf","polys","ctx","p","PolyError","xs","xOp","cOp","loc","sqrt","vOp","tOp","pOp","fOp","threshOp","ge","le","mulOp","prod","thresh","isFirstHalf","toExpandedPoly","constM","weightedReadM","monomials","sumM","monos","ret","nxt","prodM","mon","m","termsA","termsB","splice","ai","foldLikeTerms","expandPoly","constructor","cause","super","zero","solveLP","Ab","rows","cols","tableau","fill","Ai","Aij","cj","pivotHistory","piv","findPiv2","pivotInplace","findPiv1","xOpt","targ","side","ncol","backtrack","row","tot","xi","isFeasible","A","r","minloc","linearUB","weight","entry","weightedSum","bounds","w","direction","err","nVar","boundScale","bnd","scaleProd","cons","coords","objective","soln","wi","log","linbound","linboi","splitArts","predicate","si","group","partition","BNBSplitWorker","optTarget","constraints","topN","callback","interim","firstUncalculated","this","addFilter","maxConts","lins","approxs","setThreshold","newThreshold","calculated","minCount","getApproxFilter","calculateFilter","reportInterim","splitOldFilter","skipped","splitOn","splitVal","appxs","allKeys","appx","bestKey","minHeur","oldHeur","lowerRange","upperRange","vals","minv","maxv","mid","heur","pickSplitKey","newFilters","setKey","splitOnSet","valsBySlot","val","mins","totalRange","cutoff","split","start","end","floor","splitAtValue","pop","oldCount","dot","conts","approximation","approx","maxContribution","leadingConts","cont","newValues","requiredConts","lc","newCount","resultType","buildValues","tested","failed","ComputeWorker","plotBase","builds","plotData","compute","preArts","totalCount","oldMaxBuildCount","initial","binding","slotCount","body","names","operandNames","arr","toString","join","Function","precompute","buffer","permute","build","artifactIds","plot","interimReport","refresh","force","plots","scale","round","mergePlot","DefaultSplitWorker","_callback","stack","_newThreshold","splittedBy","splitBySet","splitByID","candidates","numChunks","ceil","boundedNumChunks","chunk","splitWorker","computeWorker","async","handleEvent","command","maxIterateSize","postMessage","Promise","setTimeout","perms","filter_loop","available","s","filterFeasiblePerm","onmessage","message"],"sourceRoot":""}